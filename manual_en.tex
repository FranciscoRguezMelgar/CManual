\documentclass[a4paper]{article}
\widowpenalties 1 10000
\usepackage{parskip}
\usepackage{newcent}
\usepackage[scaled=.95]{helvet}
\usepackage{nimbusmononarrow}
\renewcommand{\familydefault}{\sfdefault}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{titlesec}
\usepackage{babel}
\usepackage{eurosym}
\usepackage{graphicx}
\usepackage{float}
\usepackage{hyperref}
\hypersetup{
   linkbordercolor={1 1 1},
   pdfborderstyle={/S/U/W 1}
}
\usepackage{fancyhdr}
\usepackage{lastpage}
\usepackage[backend=biber, style=apa, citestyle=apa]{biblatex}
\addbibresource{bibliography/sources.bib}
\usepackage[]{geometry}
\geometry{
    a4paper,
    left=30mm,
    right=30mm,
    bottom=35mm,
    headheight=25mm
}

\usepackage{amsfonts}
\usepackage{subcaption}
\usepackage{listings}
\usepackage[dvipsnames,table]{xcolor}
    \definecolor{gray}{rgb}{0.5,0.5,0.5}
    \definecolor{lightYellow}{RGB}{251, 255, 212}
    \definecolor{lightBlue}{RGB}{56,184,255}
    \definecolor{backgroundColor}{RGB}{248,248,248}
    \definecolor{keywordColor}{RGB}{0,0,255}
    \definecolor{stringColor}{RGB}{163,21,21}
    \definecolor{commentColor}{RGB}{0,128,0}
    \definecolor{textColor}{RGB}{25,25,25}
\usepackage{cancel}
\usepackage{multirow}
\usepackage{array}
\usepackage{rotating}
\usepackage{newfloat}
\usepackage{caption}
\DeclareFloatingEnvironment[fileext=ecc,
                            placement={H},
                            name=Ecuación,
                            listname={Índice de ecuaciones}]
                            {ecuacion}
\captionsetup[ecuacion]{labelfont=normal}
\usepackage{multicol}
\usepackage{pdfpages}
\usepackage{tabularx}
\renewcommand{\tabularxcolumn}[1]{m{#1}}
\newcolumntype{Y}{>{\centering\arraybackslash}X}
\newcolumntype{R}{>{\raggedleft\arraybackslash}X}
\usepackage{tikz}
\usepackage{enumitem}
\newlist{exercises}{enumerate}{1}
\setlist[exercises]{label=\textbf{Ej. \arabic*:}, wide}
\newlist{stack}{enumerate}{6}
\setlist[stack]{leftmargin=*, label=\arabic*.}
\lstdefinestyle{C}{
    language=C,
    basicstyle=\ttfamily\color{textColor},
    numberstyle=\ttfamily,
    frame=none, % draw a frame at the top and bottom of the code block
    tabsize=4, % tab space width
    showstringspaces=false, % don't mark spaces in strings
    numbers=left, % display line numbers on the left
    commentstyle=\color{commentColor}, % comment color
    keywordstyle=\color{keywordColor}, % keyword color
    stringstyle=\color{stringColor}, % string color
    backgroundcolor=\color{backgroundColor},
    captionpos=b,
    morekeywords={bool},
    breaklines=true,
    literate=
            {Á}{{\'{A}}}1
            {É}{{\'{E}}}1
            {Í}{{\'{I}}}1
            {Ó}{{\'{O}}}1
            {Ú}{{\'{U}}}1
            {á}{{\'{a}}}1
            {é}{{\'{e}}}1
            {í}{{\'{i}}}1
            {ó}{{\'{o}}}1
            {ú}{{\'{u}}}1
            {ñ}{{\~{n}}}1
            {Ñ}{{\~{N}}}1
            {ü}{{\"{u}}}1
            {Ü}{{\"{U}}}1
            {¡}{{\char189}}1
            {¿}{{\char190}}1
            {\\\$}{{\$}}1
}
\lstdefinestyle{pseudoCode}{
    language= ,
    basicstyle=\normalfont \rm,
    frame=tb,
    numbers=none,
    commentstyle=\color{lightBlue}, % comment color
    keywordstyle= \bfseries \itshape, % keyword color
    stringstyle=\color{red}, % string color
    backgroundcolor=\color{white},
    captionpos=b,
    morekeywords={si,mientras,retornar,para,desde,hasta,en,otro,caso,FALSO,CIERTO,algoritmo,es,igual,no,menor,mayor,que},
    breaklines=true,
    literate=
            {Á}{{\'{A}}}1
            {É}{{\'{E}}}1
            {Í}{{\'{I}}}1
            {Ó}{{\'{O}}}1
            {Ú}{{\'{U}}}1
            {á}{{\'{a}}}1
            {é}{{\'{e}}}1
            {í}{{\'{i}}}1
            {ó}{{\'{o}}}1
            {ú}{{\'{u}}}1
            {ñ}{{\~{n}}}1
            {Ñ}{{\~{N}}}1
            {ü}{{\"{u}}}1
            {Ü}{{\"{U}}}1
            {¡}{{\char189}}1
            {¿}{{\char190}}1
            {\\\$}{{\$}}1
}
\definecolor{terminalRuler}{RGB}{231,234,237}
\lstdefinestyle{terminalStyle}{
    frame=none,
    numbers=none,
    rulecolor=\color{terminalRuler},
    language={},
    basicstyle=\ttfamily\color{textColor},
    numberstyle=\ttfamily,
    tabsize=4, % tab space width
    showstringspaces=false, % don't mark spaces in strings
    commentstyle=\color{lightBlue}, % comment color
    keywordstyle=\color{green}, % keyword color
    stringstyle=\color{red}, % string color
    backgroundcolor=\color{backgroundColor},
    captionpos=b,
    breaklines=true,
    literate=
            {Á}{{\'{A}}}1
            {É}{{\'{E}}}1
            {Í}{{\'{I}}}1
            {Ó}{{\'{O}}}1
            {Ú}{{\'{U}}}1
            {á}{{\'{a}}}1
            {é}{{\'{e}}}1
            {í}{{\'{i}}}1
            {ó}{{\'{o}}}1
            {ú}{{\'{u}}}1
            {ñ}{{\~{n}}}1
            {Ñ}{{\~{N}}}1
            {ü}{{\"{u}}}1
            {Ü}{{\"{U}}}1
            {¡}{{\char189}}1
            {¿}{{\char190}}1
            {\\\$}{{\$}}1
}
\renewcommand{\lstlistingname}{Program}
\renewcommand{\lstlistlistingname}{List of Programs}
\newcommand{\mod}{\mathop{\mathrm{m\acute{o}d}}}
\newcommand{\division}[1]{\begin{array}{|l}#1\\\hline\end{array}}
\newcommand{\padding}{\phantom{0}}
\newcommand{\centigrade}{°C}
\setcounter{secnumdepth}{5}
\setcounter{tocdepth}{3}
\newcommand{\sectionbreak}{\newpage}
\titleformat{\section}[hang]{\Large \rm \bfseries}{\thesection .}{1em}{}[]
\titleformat{\subsection}{\large \rm \bfseries }{\thesubsection .}{.75em}{}
\titleformat{\subsubsection}{\rm \bfseries }{\thesubsubsection .}{.5em}{}
\titleformat{\paragraph}{\bfseries\rm}{\theparagraph .}{1em}{}
\titlespacing*{\paragraph}{0pt}{3.25ex plus 1ex minus .2ex}{1.5ex plus .2ex}
\titleformat{\subparagraph}{\bfseries\rm}{\thesubparagraph .}{1em}{}
\titlespacing*{\subparagraph}{0pt}{3.25ex plus 1ex minus .2ex}{1.5ex plus .2ex}
\graphicspath{{img/}}
\def \autor{Francisco Rodríguez Melgar}
\def \titulo{Easy manual for C}
\def \organizacion{Computer engineer}
\title{\rm \textbf{\Huge{\titulo}}\normalfont }
\author{\LARGE{\autor}\\ \\ \Large{\organizacion}}
\begin{document}
\pagenumbering{gobble}
\maketitle
\begin{figure}[H]
    \center
    \includegraphics[width=.5\linewidth]{c_icon}
\end{figure}
\newpage
\cleardoublepage
\begin{flushright}
    \textit{<<Since it is more what you ignore than what you know, do not speak too much.>>}

    \textit{--Raimundo Lulio, scholar and saint from the island of Mallorca, Spain}
\end{flushright}
\cleardoublepage
\pagestyle{fancy}
\fancyhf{}
\fancyhead[C]{
\textrm{\Large\titulo\normalsize}\\
\rule[1mm]{0.3\hsize}{.5pt}\\
\textrm{ÍNDICES}
}
\fancyhead[R]{\includegraphics[height=2cm]{c_icon}}
\rfoot{\textrm{page \textsc{\thepage{}} of \textsc{\pageref*{startSectionContent}}}}
\fancyfoot[L]{\textrm{\today}}
\renewcommand{\footrulewidth}{0.5pt}
\pagenumbering{roman}
\tableofcontents
\newpage
\listoffigures
\newpage
\listoftables
\newpage
\lstlistoflistings
\label{startSectionContent}
\newpage
\hypersetup{
   linkbordercolor=black,
   urlbordercolor=black,
   pdfborderstyle={/S/U/W 1}
}
\pagenumbering{arabic}
\pagestyle{fancy}
\fancyhf{}
\fancyhead[C]{
\Large\rm\titulo\normalsize\normalfont\\
\rule[1mm]{0.3\hsize}{.5pt}\\
\textrm{\leftmark}
}
\fancyhead[R]{\includegraphics[height=2cm]{c_icon}}
% El único cambio es que aquí referencio la última página del documento.
\fancyfoot[R]{\textrm{page \thepage{} of \pageref*{LastPage}}}
\fancyfoot[L]{\textrm{\today}}
\renewcommand{\footrulewidth}{0.5pt}

\section{Introduction}
In this document I hope to be able to explain, at least, the basic fundamentals
of the C programming language. Also, I hope to offer reasons to learn it and
I will try to communicate to the reader part of the beauty I find in it.
Under this first header I will explain what is programming, which kinds
of languages do exist and offer an explanation about how we will structure this
document.

\label{section:queEsLaProgramacion}
\subsection{What is programming?}
Since this is a not very advanced manual, it is possible you have never had any
experience programming. If this is the case, I will explain shallowly what
``programming'' is. Programming is, according to the Oxford dictionary: ``the
process of writting and testing computer programs''. I am a simple guy and
have not put a foot in Oxford University but, perhaps naively, I expected a more
enlightening definition. It allows us to start, though, programming is to write
programs, therefore, to know what programming is, we need to know what a program
is.

A program is the set of instructions that a computer follows to perform a
concrete task. As an example, if you were a computer, and we made a program to
make you buy a coffee in a vending machine, the program that you as living
computer would follow would be something like this:

\begin{enumerate}
    \item Get up, if you're sit
    \item Walk to the coffe machine
    \item Choose the coffe you'd like to have
    \item Read the price of the coffee
    \item Put coins up to the price in the slot for coins
    \item Push the button of the desired variety of coffee
    \item Wait until it's done
    \item Pick up the coffee, and be careful no to scorch yourself!
\end{enumerate}

Put that way, it would be wonderful to tell to your computer, or to any
computer, something like ``solve this differential equation'' or ``predict the
weather of tomorrow.'' Sadly, this is where the craftiness of the programmer
comes in. Computers do not understand the language of humans. They do not know
what weather is nor what a coffe is. Computers only understand mathematical
operations (and not a lot) and logic operations. If you do not know what logic
is, as a science, do not worry, we will talk about it later.
The programmer must be able to turn a complex
task into a set of instructions a computer understands.

Finally, we could say that programming is ``articulate complex tasks in human
language in terms of simple tasks that a computer understands''.

\subsection{How does one program?}
Now we know \textbf{what} programming is, let's see how it is done, in
general terms. Following the methaphor I used before, a ``program'', as we
understand it, is a text file (or several) where those instruction the computer
needs to do something are. As I said before, computers understand a somewhat
small number of instructions, and, as a matter of fact, they only understand
binary code. A computer stores in its memory (what is commonly known
as RAM memory) the instructions that it must execute. That memory only stores
bits, digits in a numeric system that contains only two figures: zero and one.

If we apply the definition of the last chapter, to program, we must write
programs in zeroes and ones. To understand the magnitude of this, the program
Firefox, the web browser, occupies around 500~KB, or, what is the same, half a
million of bytes. A byte is eight bits. This means that the programmer that,
supposedly, wrote Firefox would have had to write a continous file of four
millions of zeroes and ones. It is only logical to think this is not the case.

Since the earliest times of computer science and software development
people have come up with \textbf{formal languages} that explain in a
comprehensible way to the human being how a program must be, but that allow us
to make a program composed of those zeroes and ones. This is where the different
languages you may have heard of come in: C, C++, C\#, Java, Rust...
All those languages differ in that they're different ways (each one with its
pros and cons) to compose a program that, after a process, the computer is able
to understand. This process is \textbf{compilation}. To compile a program is
turning it from that language humans can understand (and that you are going to
learn to write, I hope with my help) into a pure computers' language. The code
writen in those languages is called \textbf{source code} because it is the
source from which we will obtain (compile) our programs. In general, I am not
going to make a distinction between the program (compiled program) and the
source code. We will tell them apart by the conext.

So, if we add this information to what we had before, we could say that
programming is: ``to write a file in a programming language that can be
compiled into a program the computer can execute directly''.

\section{Environment set up}
Maybe you're already impatient, or perhaps you stopped reading a long time
ago, But I think that introduction was needed, at least for those that do not
know what programming is at the most basic level. Now we are going to talk about
how to prepare an \textbf{environment} to program. The environment is the set of
tools we are going to use to write and compile our programs.
The problem of C is that it's a language very ``close to the computer'', what
does this mean? That it is more difficult to understand and write for people,
therefore the preparation you will need to do to program in C is a little bit
more complex that if you used other languages. So let's go little by little.

\subsection{Operating system}
If you're reading this manual, or this part, I understand you didn't explore
programming before. Let's start by the beginning. Since C is a language
computers understand more easily, we must know which operating system we have.
If you have not altered your computer in any way, the most probable thing is
that you have a computer with Windows. Ideally you should install Linux, or
create a virtual machine with it, or use the Windows subsystem for
Linux.

Since explaining all the alternatives would make this manual very long and also
would force me to make distinctions in each one of the following sections, I am
going to suppose you are using the Windows subsystem for Linux, or WSL. The
first step is to install the Windows characteristic that allows us to
do that. Hit the Windows key and the letter R. Write in the little window that
pops up \verb!optionalfeatures! and hit enter. A window will pop up
where you should look for the element ``Windows subsystem for Linux'', check the
box in the left of the option and push accept. Restart when it is asked for it.
After it, you will go to the Microsoft Store app and will look for ``Ubuntu''.
Go to the first result and install it. After that, go to the start menu and
open the app (Ubuntu). It will take a moment to install. After it completes,
it will ask you to input an username and a password. Just a note: when you start
writting the password you will not see anything, don't worry, it's supposed to
be like that, just write the password, it will ask you to input it twice, if
you did it differently, it will tell you to do it again. Be sure to remember
the username and password. When you are done, you will looking at a black screen
with a text that will read \verb!{user}@{machine_name}:~$!. Congratulations,
you have installed a Linux you can use in Windows.

This black window that only contains letters is called a terminal, and it is
a way to interact with the computer that has been in use since decades ago.
Instead of clicking icons, you will write commands in the terminal and you
will hit enter. I am going to give you a series of basic commands and
concepts so you can use it. In a terminal, at any given moment you are in a
\textbf{work directory}, for example, if you write \verb!pwd! and you hit enter,
it will tell you in which directory you are in. Directory is just a fancy word
computer people use to say what we call folder when using computers, a place
where other files and folders may be put.
I will show you an example of how it would look.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=terminalStyle]
john@DESKTOP-U8OA808:~\$ pwd
/home/john
\end{lstlisting}
\end{minipage}

With the command \verb!cd! you move your work directory. Every directory has two
special directories inside, the dot directory (\verb!.!) and dot-dot
(\verb!..!). The first one is the same directory, that is: if you perform
\verb!cd .! you will stay in the same directory. The second is the parent
directory, for example:

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=terminalStyle]
john@DESKTOP-U8OA808:~\$ pwd
/home/john
john@DESKTOP-U8OA808:~\$ cd ..
john@DESKTOP-U8OA808:/home\$ pwd
/home
john@DESKTOP-U8OA808:/home\$
\end{lstlisting}
\end{minipage}

In order to give you a better idea of what a filesystem is, I am going to
explain it to you more thoroughly. In Windows, all your files and directories
are in drives, which have letters assigned and end with a colon (\verb!:!).
For example, the most common path for the desktop is
\verb!C:\users\userName\Desktop! (userName being the name of the user whose
dekstop we're talking about, let's say John). On the contrary, in Linux this is
not this way, all directories come from the root directory (\verb!/!). Note: if
you haven't noticed yet, in Windows directory paths are written with backslashes
(\verb!\!) and in Linux with forward slashes (\verb!/!). Each drive in Windows
tends to be a physical drive: a memory stick, a hard disk, an SSD... In Linux,
when you insert a drive or disk, it will simply \textbf{mount} in a directory
like any other. That is: the files and directories of the new disk will be put
in one point of the directory tree we already had.

These directories work like a series of dots joined by connections. Each
directory or file is a dot, connected to the directory it hangs from, and
having all the directories it has inside hanging from it. This may be drawn
like I'm going to show you now:

\begin{figure}[H]
    \includegraphics[width=\linewidth]{filesystems}
    \caption{Example of a filesystem}
    \label{img:extensions}
\end{figure}

In this figure, each directory has linked to it those inside it, and all of them
show where the directory \verb!..! which is inside them goes. As you can see, to
reach a path like \verb!/usr/games! we only have to ``hop'' from a directory to
the next. If we wanted to come back, we can use the fictional directories that
point to the father of the directory we're in (\verb!..!).

The case of the root
directory is special, because its parent directory is the same directory. In
Windows the system is the same, but there is not only one root, there are
several. Those being the different storage drives we have. Also, we do not need
to be all the time hoping in one level jumps, we can use complete paths to
navigate from a place to the other. If you haven't figured it out yet by the
context, a path is simply the succession of directories that go from one to
another. There are two types of paths:
\begin{enumerate}
    \item Absolute paths: Those are the ones that start by slash, and they
    indicate a path from the root directory to a concrete directory or file.
    For example: \verb!/home/john/music/Beethoven_symphony.mp4! would be and
    absolute path.
    \item Relative paths: they are those that do not start from the root
    directory, but from the work directory. For example:
    \verb!music/Beethoven_symphony.mp4! is relative path that will point to
    an existing file only if inside the current work directory there is a
    directory called \verb!music! and, inside it, a file named
    \verb!Beethoven_symphony.mp4!.
\end{enumerate}

The text it shows up everytime you hit enter is called a prompt and, in general,
it shows you your username, the machine where you are and after that, your
working directory, if it fits in the screen. I am going to substitute the prompt
just for a dollar sign in the examples I show you, so it fits better the page.
When you first started your terminal it showed a tilde (\verb!~!) because that's
an alias of your home directory, which is a route in Linux systems where the
user stores his personal files. Generally speaking, that route is in
\verb!/home/<username>! for example \verb!/home/john!.

Now we are going to learn to see what is inside a directory, the command that
allows us to do so is \verb!ls!, if you type it and hit enter you'd see...
nothing. That's because we have not created any file in our home directory,
the command to create files is called \verb"touch". Write \verb!touch test.txt!
and hit enter, if you now perform \verb!ls!, you would see it will show up.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=terminalStyle]
\$ touch test.txt
\$ ls
test.txt
\$
\end{lstlisting}
\end{minipage}

\verb!ls! has a lot of options, options of Linux commands are set with a dash
infront of them, so, if you're told ``\verb!ls! with the options a and l'' you
must write \verb!ls -l -a! or, joining all them in the same dash: \verb!ls -la!
Something like this should appear on the screen.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=terminalStyle]
\$ ls -la
total 8
drwxr-xr-x 1 john john  512 Jul  8 19:05 .
drwxr-xr-x 1 root root  512 Jul  7 22:37 ..
-rw-r--r-- 1 john john  220 Jul  7 22:37 .bash_logout
-rw-r--r-- 1 john john 3771 Jul  7 22:37 .bashrc
drwxr-xr-x 1 john john  512 Jul  7 22:37 .landscape
-rw-rw-rw- 1 john john    0 Jul  8 18:25 .motd_shown
-rw-r--r-- 1 john john  807 Jul  7 22:37 .profile
-rw-rw-rw- 1 john john    0 Jul  8 19:05 test.txt
\end{lstlisting}
\end{minipage}

As you can see, there are many files you have not created. This is because the
\verb!a! option makes \verb!ls! to show us \textbf{all the files}, including the
hidden ones, which are hidden because their name starts with a dot. The option
\verb!l! makes the command to show the files in a list, with more information
about them. If this is a bit intimidating to you, it is normal, and I have good
news. WSL sees the directories you have in you Windows system, so you can create
a folder in your desktop and work with the Windows explorer, to create or delete
files.

\subsection{Installing the compiler}
Now we already have a Linux installed in the computer, let's install the
compiler. To do that, we are going to execute the commands the are shown next.
If while executing any of them you are asked if you want to go ahead, answer
yes.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=terminalStyle]
$ sudo apt update
#Lots of text will be shown here, don't mind it.
$ sudo apt install build-essential
........
After this operation, 189 MB of additional disk space will be used.
Do you want to continue? [Y/n] y
........
\end{lstlisting}
\end{minipage}

Now you should have the compiler installed, it is called GCC, it is an achronym
meaning GNU Compiler Collection. To see if that is the case, type the following
command. And check the output is similar to the one shown here.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=terminalStyle]
\$ gcc -v
Using built-in specs.
COLLECT_GCC=gcc
COLLECT_LTO_WRAPPER=/usr/lib/gcc/x86_64-linux-gnu/9/lto-wrapper
OFFLOAD_TARGET_NAMES=nvptx-none:hsa
OFFLOAD_TARGET_DEFAULT=1
Target: x86_64-linux-gnu
Configured with: ../src/configure -v --with-pkgversion='Ubuntu 9.3.0-17ubuntu1~20.04' --with-bugurl=file:///usr/share/doc/gcc-9/README.Bugs --enable-languages=c,ada,c++,go,brig,d,fortran,objc,obj-c++,gm2 --prefix=/usr --with-gcc-major-version-only --program-suffix=-9 --program-prefix=x86_64-linux-gnu- --enable-shared --enable-linker-build-id --libexecdir=/usr/lib --without-included-gettext --enable-threads=posix --libdir=/usr/lib --enable-nls --enable-clocale=gnu --enable-libstdcxx-debug --enable-libstdcxx-time=yes --with-default-libstdcxx-abi=new --enable-gnu-unique-object --disable-vtable-verify --enable-plugin --enable-default-pie --with-system-zlib --with-target-system-zlib=auto --enable-objc-gc=auto --enable-multiarch --disable-werror --with-arch-32=i686 --with-abi=m64 --with-multilib-list=m32,m64,mx32 --enable-multilib --with-tune=generic --enable-offload-targets=nvptx-none=/build/gcc-9-HskZEa/gcc-9-9.3.0/debian/tmp-nvptx/usr,hsa --without-cuda-driver --enable-checking=release --build=x86_64-linux-gnu --host=x86_64-linux-gnu --target=x86_64-linux-gnu
Thread model: posix
gcc version 9.3.0 (Ubuntu 9.3.0-17ubuntu1~20.04)
\end{lstlisting}
\end{minipage}

If you get a similar text, congratulations, you have installed the C compiler.
Now we are going to, finally, start learning the concepts of the language.

\section{Your first program; say hello to the world!}

Let's navigate into that folder you have in the desktop. Units of your Windows
computer (the drives C, D, E...) are presented in the WSL as directories inside
the path \verb!/mnt!. So, \verb!C:! will be under \verb!/mnt/c!. I leave next an
example on how to navigate to a folder called \verb!hello_world! in your Windows
desktop. You can create it as you're used to now.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=terminalStyle]
\$ cd /mnt/c/Users/John/Desktop/
\$ cd hello_word
\$ pwd
/mnt/c/Users/John/Desktop/hello_world
\$
\end{lstlisting}
\end{minipage}

Now you are already in the folder, open it in the files explorer, because we
have the last configuration left. In the Windows file explorer, in the top of
the window, click on the View tab and check the box next to ``show extensions
of knows file types''. Next there is a picture of how it looks.

\begin{figure}[H]
    \includegraphics[width=\linewidth]{extensions_en}
    \caption{Configure how to see the extensions of known file types}
    \label{img:extensions}
\end{figure}

Now, in the way you like the most (the terminal or the mouse), create a file
in that folder called \verb!hello_world.c!. Open it with the Windows Notepad,
and I mean the Notepad, I do not mean WordPad, or Word. In that document we are
going to write the following.

\begin{figure}[H]
\begin{verbatim}
#include <stdio.h>

int main(void)
{
    printf("Hello, world!\n");
}
\end{verbatim}
\end{figure}

I want to clarify that the line that is displaced to the right is so because it
has spaces in the left side. You can write two, four or eight, I recommend four
as a general rule. Save the file, and go back to the terminal. You should have
the file in the directory. Make \verb!ls! to check it is in. Also, remember you
need to navigate to the folder if you closed the terminal or changed work
directory. Now we are going to compile our first program. To do that, we will
invoke GCC. I will list the commands and their expected output next.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=terminalStyle]
\$ ls
hello_world.c
\$ gcc -o hello_world.elf hello_world.c
\end{lstlisting}
\end{minipage}

When doing this, a new file will appear in the directory, called
\verb!hello_world.elf!. Congratulations! that is your first program in C. What
does it do? It prints ``Hello, world!''. If you make double click on it, you
will see that Windows does not know how to open it. That is because it is a
Linux executable. Because of that, in the terminal, write
\verb!./hello_world.elf!. If you remember what I told you before, a path that
does not start with the root directory is a relative path, and the directory
dot \verb!.! is a relative path. When the terminal gets a command from the user,
it looks for a program with that name in a series of directories that are
configured in your operating system. If you want to execute any other program
(or other things you can execute, but I won't get tangled on them now) you must
indicate a path, relative or absolute. To make the terminal understand we are
introducing a path and not a command, we start it by dot, that is, this very
directory. When you hit enter, you should see something like this:

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=terminalStyle]
\$ ./hello_world.elf
Hello, world!
\end{lstlisting}
\end{minipage}

You you have compiled your first program, may be you are a bit disappointed,
since you do not understand what it does, or how it does it. Hence it is the
moment we adquire a compromise with each other. That is, if you do not
understand something that appears in the programs we are going to see together,
you will trust I will clarify eventually when the moment arrives, from my side,
my compromise is that I will do it the earliest I can, so you have to put the
least amount of effort in ignoring things you don't know.

For now, I will explain what the command we have issued before is, gcc is, as
I said before, the C compiler, the option \verb!o! (remember that I explain
what options were when I explained you how to use \verb!ls!) indicates that the
next thing we are going to write is the name of the program we want to create
and, finally, the name of our source code file. If you put \verb!main.elf! the
resulting file would be called that, or anything you wanted, I'll be compiling
my programs as to files called \verb!main.exe! mainly.

\subsection{Text editor}
You edited your first program with the notepad, but editing code in that way
if a bit unbearable. Partially this is so because it is usual to use specialized
editors that colorize the words that are important in the concrete programming
language you are using and help you with things like knowing where the braces
that close the one your looking at now. I am going to leave here a list of
some common editors used with C code. I will not assume you are using any
concrete one, so choose the one you like. I use the first one, but may be for
your first steps you may stick to Notepad++, which is simpler, and jump
to another one when you feel more comfortable writting more complex programs.
\begin{enumerate}
    \item Visual Studio Code.
    \item Atom.
    \item Sublime text
    \item Notepad++
\end{enumerate}

\section{First steps}

Now you already know what a source code file is I am going to show you how we
are going to include code fragments in the manual. Let's revisit the program
\verb!hello_world.c!.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C, caption={Hello World in C},
label={lst:helloWorld}]
#include <stdio.h>
int main(void)
{
    printf("Hello, world!\n");
}
\end{lstlisting}
\end{minipage}

As you can see, the lines are numbered, and there are words in blue, and others
in red. The blue word are the ones called key words, for now, remember that
all your programs must contain the lines 1, 2, 3 and 5 and that, between the
lines 3 and and 5 you will write the instructions that will make up your source
code files.

\subsection{Variables}

We are getting into business, at last! One of the first things that are needed
in a program are \textbf{variables}, a variable is an abstraction to designate a
space in the memory of the computer in which we store things. When we create a
variable we say to the computer: ``save this space in your memory to store
data''. C is a language of the kind we call typed, that is, each variable has a
type and cannot change that type after it is created. In C there is a set of
basic types that I will show you in a handy table.

\begin{table}[H]
    \centering
    \begin{tabularx}{\linewidth}{|c|c|c|Y|}
        \hline
        \textbf{Name} &\textbf{Size} (in bytes)&\textbf{Range}&\textbf{Ussage} \\\hline
        \texttt{char} & 1 & $[-128, 127]\vphantom{\matrix{1\cr1\cr1\cr}}$ & One text character or a byte\\\hline
        \texttt{short}& 2 & $[-32\,768, 32\,767]\vphantom{\matrix{1\cr1\cr1\cr}}$& Number in that range (generally network ports)\\\hline
        \texttt{int}&   4  & $[-2\,147\,483\,648, 2\,147\,483\,647]\vphantom{\matrix{1\cr1\cr1\cr}}$&General type for integer numbers\\\hline
        \texttt{float}& 4 & $[\pm3.4\cdot{}10^{-38}, \pm3.4\cdot{}10^{38}]\vphantom{\matrix{1\cr1\cr1\cr}}$ & Simple precision decimal numbers\\\hline
        \texttt{double}&8 &$[\pm1.79\cdot{}10^{-308}, \pm1.79\cdot{}10^{308}] \vphantom{\matrix{1\cr1\cr1\cr}}$ & Double precision decimal numbers\\\hline
    \end{tabularx}
    \caption{Basic types of C}
    \label{tab:basicTypes}
\end{table}

A table like that may be intimidating at first, but it is simple. When we
declare (create) a variable, we must say what type it has. I like to say that
variables are like boxes and that, according to their type, inside that box
some things fit and some others do not. To declare a variable, you write its
type and a name, and do not forget to end the line with a semicolon (;)! Apart
from declaring them, we must learn to give them a value. That is called ``assign
a value'', and it is done with the equal sign (\verb!=!). To give it a value you
write the name of the variable, the equal sign and the value, let's see some
examples and I'll get into some caveats.

Regarding the name: the name of a variable is made out of letters, numbers and
underscores. The name of a variable must not be writen all in uppercase, but
it can contain some. It cannot start by a number, and \textbf{you should not start
it with an underscore}. In general, you can use two notations to write variable
names in C (and in any programming language):
\begin{enumerate}
    \item \textbf{Camel case}: if a name contains several words, they must be
    writen together, with the first letter of each word in uppercase,
    excluding the first. For example: \verb!betterValue! or \verb!targetNumber!.
    It is called like this
    because the uppercase letters remind of the humps of a camel.
    \item \textbf{Snake Case}: The words are separated by underscores, all in
    lowercase, for example:  \texttt{better\_value} or \texttt{target\_number}. It is
    called like that because the shape of the names writen in this fashion
    remind of a snake that has eaten animals and has bulges in its body.
\end{enumerate}


\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C, caption={Declaration and assignment of variables},
label={lst:variableAsignation}]
#include <stdio.h>
int main(void)
{
    char letter = 'a';
    char byte = 120;
    short shorty = 5520;
    int money_i_want;
    float money_i_have = 3.22F;
    double money_you_have = 52.55;

    money_i_want = 450000;
    shorty = 11111;
}
\end{lstlisting}
\end{minipage}

Computers do not understand about letters, only numbers, therefore, when you
tell the computer that \verb!letter! is equal to \verb!'a'!, you tell it it's
equal to the number that letter has assigned. Mind that to assign the value
of a \verb!char! you must use simple straight quotes. The correspondency between
letters and numbers is writen in the ASCII table, is you want to read it, I
leave this \href{https://www.ascii-code.com/}{link} to a site where u can
check it up. If you look there, you will see that the letter a has the value
97. After that, we assign to other char a numeric value, in line 7 you can see
we declare a variable without assigning a value to it. That is totally okay, but
beware!, \textbf{a variable to which you have not assigned a value has a random
value}. This is why many techaers would advice you that everytime you declare a
variable you should give it a value immediately. This process (giving value to
a variable for the first time) is called ``initialize'' a variable.

In lines 11 and 12 we give value to variables that we have declared before,
and I want to take some time talking about line 12. At first, it could seem
that when writing \verb!shorty = 5520;! we are enunciating a mathematical
equality, that that is always going to be the same, but in C we do not work with
``laws'', but with instructions, so you shall not read that line as ``the value
of shorty is 5520'' but ``I have assigned the value the value 5520''. That is:
you have put into the ``box'' a 5520, but nothing avoids you to pull that
value out and put another one in as we do in line 12.

The values a programmer writes in the source code are called ``literals''. I
think that the name is pretty much self explanatory. Each literal has a type,
in the same way variables have. Later we will see why that's important. For now,
remember that literal is the name of values of variables the programmer writes
explicitly in the code. Apart from literals, we can assign to a variable the
value of an \textbf{expression}, a expression is any text writen in the C
language that has a value. For now, we are going to limit ourselves to assign
one variable to other variables.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C, caption={Assigning variables to other variables},
label={lst:variableAsignationBetween}]
#include <stdio.h>
int main(void)
{
    int a = 3;
    int b = 2;

    a = b;
}
\end{lstlisting}
\end{minipage}

In line 7 we can see how I assign to the variable \verb"a" the value of the
variable \verb!b!, therefore, it will have a value of 2, now. Since seeing this
is difficult, I am going to include in the next example a series of lines with
the word \verb!printf! in them, you may remember it from our first program.
Later on, I will teach you to use it, but, at the moment, simply copy this
program in your file of source code and compile it as we did before. (Copying
things from a PDF tends to be cumbersome, therefore type it yourself, also, it
will serve as typing practice.)

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C, caption={Final example of variable using},
label={lst:variableFinalExample}]
#include <stdio.h>
int main(void)
{
    int a = 3;
    int b = 10;
    printf("a is equal to: %d\n", a);
    a = b;
    printf("b is equal to: %d and a is the same, that is: %d\n", b, a);
    b = 22;
    printf("b is equal to: %d, a still is %d\n", b, a);
}
\end{lstlisting}
\end{minipage}

If you type this program, compile it and execute it, you should see something
like this:

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=terminalStyle]
\$ ./main.exe
a is equal to: 3
b is equal to: 10 and a is the same, that is: 10
b is equal to: 22, a still is 10
\end{lstlisting}
\end{minipage}

As you can see, when \verb!a = b! is writen, \textbf{the values of a and b are
not linked together}. Nevertheless, when assigning any value to a variable, you
must be careful. Going back to the methaphor of the boxes, in a box you can fit
things of a certain set of shapes and sizes. If a data is, for instance, a
decimal number (wether it is a float or a double) if it is assigned to an
integer variable it will lose its decimal part. But there is more, if you apply
this logic, what would happen if you assign a number such as 1203 to a
\verb!char!? If you go to the table \ref{tab:basicTypes}:
\nameref{tab:basicTypes}, you will see that 1203 is outside the range of
\verb!char!. What happens is... you do not know what happens. The elegant way of
saying this is: ``undefined behaviour''. The next program is an example of that.


\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C, caption={Erroneous assignments},
label={lst:invalidAssignations}]
#include <stdio.h>
int main(void)
{
    char c = 1500;
    short s = 5555555;
    float f = 3.8e105;

    printf("c: %d\n", c);
    printf("s: %hd\n", s);
    printf("f: %f\n", f);
}
\end{lstlisting}
\end{minipage}

If you compile it, the compiler will throw a series of messages called warnings.
Those warnings warn you that, while something is correct, it seems it contains
some error. For example, if you wrote ``I did not know your Belgian'' the
sentence would be technically correct, it would mean you didn't know a Belgian
person related in some way to the person you're talking to, regardless, more
probably, you wanted to say  ``I did not know you're Belgian ''. If we compile
and execute, something like the following should appear in the terminal.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=terminalStyle]
\$ gcc -o main.exe main.c
main.c: In function 'main':
main.c:86:14: warning: overflow in conversion from 'int' to 'char' changes value from '1500' to '-36' [-Woverflow]
   86 |     char c = 1500;
      |              ^~~~
main.c:87:15: warning: overflow in conversion from 'int' to 'short int' changes value from '5555555' to '-15005' [-Woverflow]
   87 |     short s = 5555555;
      |               ^~~~~~~
\$ ./main.exe
c: -36
s: -15005
f: inf
\end{lstlisting}
\end{minipage}

As you can see, neither the \texttt{char} is equal to 1,500 nor the
\texttt{short} is 5,555,555, because they cannot be. The compiler does not say
anything about the \texttt{float} or the \texttt{double}, the reason is that both
data types have a special value called infinity, which symbolizes infinity.
This is because, as we will see later on, they do not represent numbers in a
totally correct way, and that's why they can be positive and negative infinity.

Let's take some time for the problem of decimal numbers. If you know how binary
code works, you would know that a binary number of $n$ bits you can represent
$2^n$ numbers. In the case of decimal numbers, we use one complex system called
IEEE  754. I am not going to go into detail here, but the main problem of this
way of representing numbers is that it is not only not exact (for example,
the number 0.1 cannot be represented exactly), but its precission is not
constant. What does this mean? That if near the zero the float may distinguish
between 1.10 and 1.11, it is possible they cannot distinguish 10000000.10 from
10000000.11. Be careful about that when you use decimal numbers.

As you have seen here, there are allowed assignments and forbidden ones. The
allowed ones (those the compiler does not see as something bad), are called
implicit conversions, their names comes from the fact you do not need to do
anything to make them happen, for example, assigning a char value to an integer
variable. Later on I will teach you to perform conversions between data types
explicitly.

\subsection{Printing things}
Programmers call ``print'' to write things into files and, specially, to the
screen, like your first program that wrote ``Hello, world!''. I do not want to
get ahead of myself, because there are several concepts behind what we use to
print things on the screen, nevertheless, I need you to be able to show things
on the screen to be able to test your own programs.

To print things on the screen you must use the word \texttt{printf}. With a
syntax (syntax just means the way things are suppossed to be writen) a little
bit difficult. You must write \texttt{printf}, an opening parenthesis and a thing
called ``format'' which is the text that is going to be printed, surrounded by
double straight quotes (\texttt{"}). To include variables in that printing, you
must put ``specifiers'', which are special texts that signal \textbf{the type}
of the variables you want to print. After the format, we will write the
variables we are going to print, separated by commas, in the order we wrote
their specifiers. Also, there are some special characters you must write in a
special manner: the new lines and the tabulators. This is a bit confusing, so
I will show you two tables where you can see the specifiers and the special
characters.

\begin{table}[H]
\centering
\begin{tabularx}{\linewidth}{|c|Y|}
\hline
\textbf{Specifier} & \textbf{Type it prints}                                              \\ \hline
\texttt{\%d}& Integers (\texttt{int})                                                           \\ \hline
\texttt{\%f}& Decimals (\texttt{float} and \texttt{double})                                     \\ \hline
\texttt{\%hd}& \texttt{short}                                                                   \\ \hline
\texttt{\%c}& \texttt{char} as characters (no numbers)                                          \\ \hline
\texttt{\%s}& Text, writen as \texttt{\textquotedbl A text\textquotedbl}, quotes included.      \\ \hline
\texttt{\%p}& Pointers, they are an advanced feature of the language, I will explain them later \\ \hline
\end{tabularx}
\caption{Format specifiers}
\label{tab:formatSpecifierC}
\end{table}

On the other hand, the special characters are these, and are written with a
backwards slashes (\textbackslash{}) in front of them. In the table I already
include the backward slash. Also, since the specifiers are written starting with
percentage symbol (\verb!%!), if you want to print it, you need to put it twice.

\begin{table}[H]
\centering
\begin{tabularx}{\linewidth}{|c|Y|}
\hline
\textbf{Sequence} & \textbf{Printed character}                       \\\hline
\texttt{\textbackslash{}\textbackslash{}} & Backwards slash          \\\hline
\texttt{\textbackslash{}n}& New line                                 \\\hline
\texttt{\textbackslash{}t}& Tabulator (prints spaces until the next character is aligned with four character column in the terminal) \\\hline
\texttt{\%\%}& Will print just one percentage symbol.                \\\hline
\end{tabularx}
\caption{Sequences to print special characters}
\label{tab:specialCharsC}
\end{table}

This is a bit dry, let's see an example.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C, caption={Ejemplo de impresión.},
label={lst:decimalvsintergerDivision}]
#include <stdio.h>
int main(void)
{
    int integer = 654654;
    short shorty = 25254;
    char charty = 'a';
    double decimal = 2.3;
    printf("The integer is:\t%d\nThe short is:\t%hd\nThe char is the letter:\t%c\nThe decimal number is:\t%f\n", integer, shorty, charty, decimal);
}
\end{lstlisting}
\end{minipage}

The line is very long and in this page is it written as many, but you should
write it as a single line. If you look closely, there is only one line number,
that indicates that it's the same line but it is broken so it fits in the page.
The program, once compiled and executed, should print something like this.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=terminalStyle]
\$ ./main.exe
The integer is: 654654
The short is:   25254
The char is the letter: a
The decimal number is:  2.300000
\end{lstlisting}
\end{minipage}

As a bottom line: \texttt{printf} does not add anything you do not put in it,
like new lines, so if you want to print the next thing in a new line, remember
to write \verb!\n! at the end of the format. Also, it is good that your program
prints a new line character as the last thing, if not, it could leave things
unprinted. That's because the terminal forces itself to print everything you
have ordered it to print when it finds a new line.

\subsection{Operators}
Playing a shell game with the values of the variables you declare in a program
is boring, I know, therefore we are going to learn to perform operations with
them. In C (and in any other programming language) there are the so called
\textbf{operators}. They are symbols that allow us to perform calculations.
Operators are a mathematical concept, and are applied to a set of arguments, or
better put, operands. In math, the symbols $+$, $-$, $\times$ and $\div$ are
mathemetical operators for addition, substraction, multiplication and division,
respectively. In the same way we have done with the basic types, I will present
the operators in a table and later on we will see examples on how to use them.

\begin{table}[H]
\centering
\begin{tabularx}{\linewidth}{|c|Y|}
\hline
\bf Operator & \bf Description \\ \hline
\tt + & Addition. Adds integers and decimals together and between them. \\\hline
\tt - & Substraction. Substracts from the left operand the value of the right operand. \\\hline
\tt / & Division. Return the result of the division of the left operand by the right one. Note that, \textbf{if both operands are integers}, the operator performs integer operation, that is, \textbf{without decimals}. \\\hline
\tt * & Multiply. Asterisk has many functions in C, but this is the first of them you will discover. The type of the multiplication of two integer is always a \textbf{double}.\\\hline
\tt ++ & Increment. Makes a number (either integer or decimal) go up one unit, it can be prefix (before the operand) or postfix (after the operand).\\\hline
\tt -{}- & Decrement. Works as the increment, but it makes the number to go down one unit. \\\hline
\tt \% & Module. Is an operator that return the residue of the division of the left operand by the right operand. \\\hline
\end{tabularx}
\caption{Basic math operators in C}
\label{tab:mathOperators}
\end{table}

In the last section I told you that we could assign a value to a variable.
I also told you that an expression is a fragment of C code with a value, and
that the name of a variable alone is an expression. Now we have operators, we
can write more complex expressions, for example \verb!a+b! would be an
expression whose value would be the addition of a and b.
We can make calculations now!

You must be careful, though, because, as I said before, all expression in C has
a \textbf{type} and, as we saw in the last section, assigning a value of
incorrect type to a variable is error prone. For example, the operator division
behaves differently if the operands (the numbers we're dividing) are integer or
decimal. Let's see and example.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C, caption={Integer division vs decimal division},
label={lst:decimalvsintergerDivision}]
#include <stdio.h>
int main(void)
{
    double d1 = 1/3;
    printf("d1: %f\n", d1);

    double d2 = 1.0/3;
    printf("d2: %f\n", d2);
}
\end{lstlisting}
\end{minipage}

If you compile and execute the problem you will see this result:

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=terminalStyle]
\$ ./main.exe
d1: 0.000000
d2: 0.333333
\end{lstlisting}
\end{minipage}

What would look like the same operation give totally different results, and this
is because the \textbf{type} of the operands was different. In C, a literal
integer number value is an \texttt{int}, and the division operator when it
is operating on two integers, has an integer type. Nevertheless, when
\textbf{any of the two} operands is decimal, the operator performs the decimal
division, and its type is \texttt{double}.

Operators \verb!++! and \verb!--! are special, because they are unary operators.
An unary operator is an operator that is applied only to one operand. For
example, in mathematic you have the operator square root, whose symbol is
$\sqrt{\phantom{2}}$ which, applied to just one number, gives us the number
(or numbers) that squared give us the operand. The operators increment and
decrement are unary and, also, can be writen infront of behind the operand.
These are special operantors that do not only give us a value, but also
\textbf{affect the value of the operand they act on}. Simply: if \verb!a! is
equal to three and we make \verb!a++!, \verb!a! will be four, but if we assign
the value of the operation to other variable, that other variable will have
a different value depending on if we write it in the poastfix or prefix way,
let's see it in the code.


\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C, caption={Increment and decrement operators},
label={lst:prefixAndPostfixOperators}]
#include <stdio.h>
int main(void)
{
    int a = 3;
    int b = ++a;
    printf("a: %d; b: %d\n", a, b);
    a = 3;
    int c = a++;
    printf("a: %d; c: %d\n", a, c);
}
\end{lstlisting}
\end{minipage}

If you execute it, you'll see the following.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=terminalStyle]
\$ ./main.exe
a: 4; b: 4
a: 4; c: 3
\end{lstlisting}
\end{minipage}

I want you to understand precisely what is happening here: everytime we apply
the operand increment to a variable, that variable will increment
its value in one unit. Nevertheless; depending on if we write it as prefix
(infront the variable) or postfix (after it) the expression itself will have one
value or another. If we do it prefix, the value
of the expression of the operation
would be the value of \verb!a! \textbf{after} it increments its value, if we
do it as a postfix operator, the value will be \textbf{without the increment}.

Following the line of increment and decrement operators, there are also
operators that put together the assignment with other mathematical operations,
that is, substituting for example \lstinline[style=C]!a = a * 3;! by
\lstinline[style=C]!a *= 3;!. The same style of operators exists for
substraction, addition, division and module.

Finally, we simply must tell that the \textbf{priority} of the operations
is the same than in mathematics: the first expressions to be evaluated are those
inside parenthesis, after them division and multiplication, both have
the same priority, so in case you have several mixed, you will execute them
from left to right. After that, addition and substraction that are, again,
executed from left to right.

\subsubsection{Casting: explicit conversions}
It is usual that one needs to convert one type into another, for example, in the
case we saw before with the division, if you wanted to decimal division, you
would need to make one of them decimal to get the result you want. It is also
common than a variable that is an \texttt{int} gets assigned to a \texttt{char}
because you know its result is inside the range of values a \texttt{char} can
hold. Casting is a word that means the process of putting molten metals inside
a shaped container what will make the metal to retain that shape when it
solidifies. Nevertheless, it has its limits, laws of logic still apply, and you
cannot make a \texttt{char} to hold more than 127, for example, regardless of
casting.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C, caption={Casting example},
label={lst:castingExample}]
#include <stdio.h>
int main(void)
{
    int a = 3;
    int b = 2;
    double result = (double)a / b;
}
\end{lstlisting}
\end{minipage}

In line 6 we need one of the operands to be decimal (either \texttt{float} or
\texttt{double}). We perform cast to that type on the first operand. The syntax
is easy, but I am going to explain it in detail. You must write the name
of the type you want to convert the value to between parenthesis and next to it
the expression you want to cast. I'll leave you a couple examples:
\begin{enumerate}
\item \lstinline[style=C]!(int) (decimal_number / other_decimal)!: here we are
casting to an integer type the result of a division, as you can see, we need
to enclose the whole division in parenthesis so the casting is not applied only
to the first element.
\item \lstinline[style=C]!(char) (number % 128)!: Here you can see one of the
instances in which casting some integer type to another smaller one is ok. If
\texttt{number} is an integer, by casting it to \verb!char! there could be
problems but since we have performed module on 128, the result of the expression
is going to be between 0 and 127, therefore we know it is going to be in range
of the \texttt{char}.
\end{enumerate}
Next there is a table that will tell you which conversions are allowed and which
are not possible.

\begin{table}[H]
\begin{tabularx}{\linewidth}{|c|c|Y|Y|Y|Y|Y|}
\cline{3-7}
\multicolumn{2}{c|}{}&\multicolumn{5}{c|}{\textbf{Destiny type}}\\\cline{3-7}
\multicolumn{2}{c|}{}& \texttt{char}&\texttt{short}&\texttt{int}&\texttt{float}&\texttt{double} \\\cline{1-7}
\multirow{5}{*}[-5em]{\begin{sideways}\textbf{Source type}\end{sideways}}&\texttt{char} &OK&OK &OK &OK &OK \\\cline{2-7}
&\texttt{short} &Casting (overflow)&OK&OK&OK&OK \\\cline{2-7}
&\texttt{int} &Casting (overflow) &Casting (overflow)& OK&OK (precission) & OK (precission)\\\cline{2-7}
&\texttt{float} &Casting (rounding, overflow)& Casting (rounding, overflow)& Casting (rounding, overflow)& OK& OK \\\cline{2-7}
&\texttt{double} &Casting (rounding, overflow)& Casting (rounding, overflow)& Casting (rounding, overflow)& Casting (rounding, overflow)&OK \\\cline{1-7}
\end{tabularx}
\caption{Type conversions in C}
\label{tab:conversions}
\end{table}

Where I write ``ok'' I mean that there is an implicit conversion, but you must
be careful, the range of the integer is big and you may find that the precission
of a \texttt{float} is not good enough in the bigger values to have
problems distinguishing one unit from the next. I am going to be sincere with
you, this does not happen, the \texttt{float} is precise enough in the limits
of the integer to tell whole units apart, but I write it in the table to remind
you that you may look at the precission of the integers. Where I write casting
and I precise there can be an overflow I mean you're performing cast from
a bigger type to a smaller one, so that is not generally acceptable unless you
check urself that the value of the casted expression fits into the new type.

\subsubsection{Final example of a program with operators}
At this point, we can make our first program that makes ``something'', I am
going to give you an example that calculates the solution to a system of
linear equations, that is:

$$
\left\{\matrix{ax+by = c \cr
               dx+ey = f}
\right.
$$

With a system like that, we can apply substitution:
$$
(1)\; ax+by=c \to x= \frac{c-by}{a}
$$
$$
(2)\; dx+ey=f \to x=\frac{f-ey}{d}
$$
$$
(1) \;\mathrm{and} \; (2) \to \frac{c-by}{a} = \frac{f-ey}{d} \to
y=\frac{af-dc}{ae-db} \to x=\frac{f-e\cdot\frac{af-dc}{ae-db}}{d}
$$

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C, caption={Linear equation system solving},
label={lst:linealEquation}]
#include <stdio.h>
int main(void)
{
    int a = 1;
    int b = 3;
    int c = 8;
    int d = 2;
    int e = 7;
    int f = 12;

    double y = (a * f - d * c) / (a * e - d * b);
    double x = (f - e * y) / (d);

    printf("%dx+%dy=%d\n", a, b, c);
    printf("%dx+%dy=%d\n", d, e, f);
    printf("x = %f; y = %f\n", x, y);
}
\end{lstlisting}
\end{minipage}

If you copy this program, compile and execute it, you would see that I have
explained about variables and expressions. Nevertheless, the program has a
problem: it only solves one system of equations, to change the system, we need
to change the source code and recompile. This is not practical, and the real
programs do not work in this way. For now most of our programs would be like
this one, because I want to explain more fundamental things first. Up until
now our programs have been very boring, they are limited to execute a series of
instructions one after the other. In real life, though, programs execute
one set of instructions or other depending on conditions, or they repeat
certain instructions several times, etc.

Other problem of this program is that we cannot change the behaviour of it
in certain conditions. If you change the value of the numbers in the
program in a way you make the system irresolvable the program will fail.
Test it, change the values of \texttt{a}, \texttt{b} and \texttt{c} to 1 and
\texttt{d}, \texttt{e} and \texttt{f} to 2. This system has infinite solutions
and will make the program to fail. Is you compile and execute with they new
values, you should get something like the following:

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=terminalStyle]
\$ ./main.exe
1x+1y=1
2x+2y=2
x = -nan; y = -nan
\end{lstlisting}
\end{minipage}

What in tarnation is a nan? It is one of the special values that decimal numbers
in C can hold (remember IEEE 754). It means ``Not and Number''.
So, the result of that operation is not a number. How is that
possible? Because we have divided by zero. If you know a little about calculus
you'd know that a number divided by zero is an indetermination, that is, we do
not know what it is. That's how C deals with that. And we are lucky, if instead
of a decimal division it were an integer division, the program would simply
close abruptly. It would be interesting to check if the system has a solution,
and, if it had, then calculate it. This is done with control structures, which
will be explained in the next chapter.

\section{Changing the normal flow of the program}
As I introduced in the last section, it is convenient to be able to make the
program do one thing or the other according to a condition. Also, it is possible
(as a matter of fact it's essential) to repeat instructions according to
conditions. This is called altering the flow of the program, because instead
of execute one line after he next, the computer can jump to a place to another,
either forwards or backwards.

\subsection{Conditional sentences}
Conditional sentences are the ones that allow us to make the program flow
to \textbf{diverge}. You are going to understand it easily with the next
diagram.

\begin{figure}[H]
\centering
% generated by Plantuml 1.2022.7
\definecolor{plantucolor0000}{RGB}{34,34,34}
\definecolor{plantucolor0001}{RGB}{241,241,241}
\definecolor{plantucolor0002}{RGB}{24,24,24}
\definecolor{plantucolor0003}{RGB}{0,0,0}
\definecolor{plantucolor0004}{RGB}{17,17,17}
\begin{tikzpicture}[yscale=-1
,pstyle1/.style={color=plantucolor0002,fill=plantucolor0001,line width=0.5pt}
,pstyle4/.style={color=plantucolor0002,line width=1.0pt}
,pstyle5/.style={color=plantucolor0002,fill=plantucolor0002,line width=1.0pt}
]
\draw[color=plantucolor0000,fill=plantucolor0000,line width=1.0pt] (191.176pt,20pt) ellipse (10pt and 10pt);
\draw[pstyle1] (143.9784pt,50pt) -- (238.3736pt,50pt) -- (250.3736pt,62pt) -- (238.3736pt,74pt) -- (143.9784pt,74pt) -- (131.9784pt,62pt) -- (143.9784pt,50pt) -- cycle;
\node at (143.9784pt,55.0283pt)[below right,color=black]{(a * e - d * b) is 0};
\node at (113.0451pt,48.0566pt)[below right,color=black]{true};
\node at (250.3736pt,48.0566pt)[below right,color=black]{false};
\draw[pstyle1] (11pt,101.6055pt) arc (180:270:17.6055pt) -- (28.6055pt,84pt) -- (147.5078pt,84pt) arc (270:360:17.6055pt) -- (165.1133pt,101.6055pt) -- (165.1133pt,101.6055pt) arc (0:90:17.6055pt) -- (147.5078pt,119.2109pt) -- (28.6055pt,119.2109pt) arc (90:180:17.6055pt) -- (11pt,101.6055pt) -- cycle;
\node at (21pt,94pt)[below right,color=black]{Print: it has no solution};
\draw[pstyle1] (185.1133pt,101.6055pt) arc (180:270:17.6055pt) -- (202.7187pt,84pt) -- (385.8719pt,84pt) arc (270:360:17.6055pt) -- (403.4773pt,101.6055pt) -- (403.4773pt,101.6055pt) arc (0:90:17.6055pt) -- (385.8719pt,119.2109pt) -- (202.7187pt,119.2109pt) arc (90:180:17.6055pt) -- (185.1133pt,101.6055pt) -- cycle;
\node at (195.1133pt,94pt)[below right,color=black]{y = ( a * f - d * c ) / ( a * e - d * b )};
\draw[pstyle1] (225.1377pt,156.8164pt) arc (180:270:17.6055pt) -- (242.7432pt,139.2109pt) -- (345.8474pt,139.2109pt) arc (270:360:17.6055pt) -- (363.4529pt,156.8164pt) -- (363.4529pt,156.8164pt) arc (0:90:17.6055pt) -- (345.8474pt,174.4219pt) -- (242.7432pt,174.4219pt) arc (90:180:17.6055pt) -- (225.1377pt,156.8164pt) -- cycle;
\node at (235.1377pt,149.2109pt)[below right,color=black]{x = ( f - e * y ) / ( d )};
\draw[pstyle1] (191.176pt,180.4219pt) -- (203.176pt,192.4219pt) -- (191.176pt,204.4219pt) -- (179.176pt,192.4219pt) -- (191.176pt,180.4219pt) -- cycle;
\draw[color=plantucolor0000,line width=1.0pt] (191.176pt,235.4219pt) ellipse (11pt and 11pt);
\draw[color=plantucolor0004,fill=plantucolor0000,line width=1.0pt] (191.176pt,235.4219pt) ellipse (6pt and 6pt);
\draw[pstyle4] (294.2953pt,119.2109pt) -- (294.2953pt,139.2109pt);
\draw[pstyle5] (290.2953pt,129.2109pt) -- (294.2953pt,139.2109pt) -- (298.2953pt,129.2109pt) -- (294.2953pt,133.2109pt) -- cycle;
\draw[pstyle4] (131.9784pt,62pt) -- (88.0566pt,62pt);
\draw[pstyle4] (88.0566pt,62pt) -- (88.0566pt,84pt);
\draw[pstyle5] (84.0566pt,74pt) -- (88.0566pt,84pt) -- (92.0566pt,74pt) -- (88.0566pt,78pt) -- cycle;
\draw[pstyle4] (250.3736pt,62pt) -- (294.2953pt,62pt);
\draw[pstyle4] (294.2953pt,62pt) -- (294.2953pt,84pt);
\draw[pstyle5] (290.2953pt,74pt) -- (294.2953pt,84pt) -- (298.2953pt,74pt) -- (294.2953pt,78pt) -- cycle;
\draw[pstyle4] (88.0566pt,119.2109pt) -- (88.0566pt,192.4219pt);
\draw[pstyle4] (88.0566pt,192.4219pt) -- (179.176pt,192.4219pt);
\draw[pstyle5] (169.176pt,188.4219pt) -- (179.176pt,192.4219pt) -- (169.176pt,196.4219pt) -- (173.176pt,192.4219pt) -- cycle;
\draw[pstyle4] (294.2953pt,174.4219pt) -- (294.2953pt,192.4219pt);
\draw[pstyle4] (294.2953pt,192.4219pt) -- (203.176pt,192.4219pt);
\draw[pstyle5] (213.176pt,188.4219pt) -- (203.176pt,192.4219pt) -- (213.176pt,196.4219pt) -- (209.176pt,192.4219pt) -- cycle;
\draw[pstyle4] (191.176pt,30pt) -- (191.176pt,50pt);
\draw[pstyle5] (187.176pt,40pt) -- (191.176pt,50pt) -- (195.176pt,40pt) -- (191.176pt,44pt) -- cycle;
\draw[pstyle4] (191.176pt,204.4219pt) -- (191.176pt,224.4219pt);
\draw[pstyle5] (187.176pt,214.4219pt) -- (191.176pt,224.4219pt) -- (195.176pt,214.4219pt) -- (191.176pt,218.4219pt) -- cycle;
\end{tikzpicture}

\caption{Flow diagram: solving a equation system with a conditional}
\label{img:fluxIgEq}
\end{figure}

What you're seeing is called a flow diagram, despise the fancy name, it is very
easy to read. You start in the black dot in the top of the diagram,
and you follow the arrow, a diamond means a \textbf{decision}, according to what
is inside the decision (a condition), one branch or the other will be taken.
If you read the text of the condition inside the diamond, I have writen there
what makes our system \textbf{irresolvable}. If you read the text next to the
arrows that come out from the diamond, you will see that if $ae-db=0$, we will
print that the system is not solvable and exit normally. If it is not zero,
we will continue doing what we were doing before.

\subsubsection{Logic operations}

This drawing is nice, but let's see how we do that in C. Now I have to present
to you another set of operators, called boolean operators or logic operators.
In the section \ref{section:queEsLaProgramacion} I mentioned logic as a science.
Concretely we are going to apply propositional logic, or first order logic.
In this logic we have \textbf{facts} that can be only \textbf{true} or
\textbf{false}, and they relate with each other with three operators. Let's see
and example, and then we will hop to the theory.

Imagine a fire extinguishing system that works in this manner: ``If the
temperature is greater than 50\centigrade, the fire sprinklers will start
working, if the temperature is lower, but the is smoke detected, the sprinklers
will start working anyway''. Since this is a science, let's write it in a formal
manner. Each sentence that is conceptually different is a \textbf{proposition},
and they're generally named by letters of the alphabet from p onwards. Let's
see which propositions we have:

\begin{enumerate}
    \item Temperature is greater than 50 \centigrade, let's call it $p$.
    \item Smoke is detected, let's call it $q$.
    \item The sprinklers go off, let's call it $r$.
\end{enumerate}


\begin{table}[H]
\begin{tabularx}{\linewidth}{|c|c|Y|}
\hline
$T>50\;{}^{\circ}\mathrm{C}(\mathbf{p})$&Smoke$(\mathbf{q})$&Sprinklers go off$(\mathbf{r})$\\\hline
True  & True  & True  \\\hline
True  & False & True  \\\hline
False & True  & True  \\\hline
False & False & False \\\hline
\end{tabularx}
\caption{Example of logic operations}
\label{tab:logicOperationExample}%
\end{table}

In logic, there are thee basic operators:
\begin{enumerate}
\item Conjunction, commonly known as ``and''. It is writen with the symbol $\land$.
\item Disjunction, common knows as ``or''. It is writen with the symbol $\lor$.
\item Negation, commonly knows as ``not''. It is writen with several symbols,
for example $\sim$ and $\lnot$, but it is writen also putting a bar over the
negated expression, for example $\overline{p}$.
\end{enumerate}

\begin{table}[H]
    \centering
    \begin{subfigure}{0.33333\linewidth}
        \centering
        \begin{tabular}{|c|c|c|}
        \hline
        $\mathbf{p}$&$\mathbf{q}$&$\mathbf{p\land q}$\\\hline
        False & False  & False \\\hline
        False & True & False \\\hline
        True& False  & False \\\hline
        True& True & True\\\hline
        \end{tabular}
    \end{subfigure}%
    \begin{subfigure}{0.33333\linewidth}
        \centering
        \begin{tabular}{|c|c|c|}
        \hline
        $\mathbf{p}$&$\mathbf{q}$&$\mathbf{p \lor q}$\\\hline
        False & False  & False \\\hline
        False & True & True\\\hline
        True& False  & True\\\hline
        True& True & True\\\hline
        \end{tabular}
    \end{subfigure}%
    \begin{subfigure}{0.33333\linewidth}
        \centering
        \begin{tabular}{|c|c|}
        \hline
        $\mathbf{p}$&$\mathbf{\sim\!p}, \mathbf{\lnot p}, \mathbf{\overline{p}}$\\\hline
        True & False  \\\hline
        False & True \\\hline
        \multicolumn{2}{c}{\color{white}CIERTOFALSO\normalcolor}\\\arrayrulecolor{white}\hline
        \multicolumn{2}{c}{\color{white}CIERTOFALSO\normalcolor}\\\arrayrulecolor{white}\hline
        \end{tabular}
    \end{subfigure}
\caption{Tables of truth of the basic logic operations}
\label{tab:andTruthTable}
\end{table}

The conceptual meaning of the operation is intuitive, but I will explain it
here to tell some details. The conjunctios is true only when \textbf{both}
of the operand are true, and is like joining two propositions with ``and'' in
English. ``It is raining and it's cold'' is true only if at the same time it's
raining and it's cold. On the other hand, disjunction is when you join to
propositions with ``or''. ``I have twisted my anckle or I have broken it'', but
there is a caveat here, if you look at the truth table you will se than when
\textbf{both members}  are true, the disjunction is true also. It is something
that is not aligned with the spoken language, and you need to keep it in mind.
Finally, negation is when you put ``not'' bedore the expression o preposition,
``it is not raining'' is true only if ``it is raining'' is false.

And, after this logical detour that would Aristotle proud, what? We're almost
there, in C the logic operators are writen in this way:
\begin{enumerate}
    \item Conjunction is writen: \verb!&&!.
    \item Disjunction is writen: \verb!||!. (This symbols is called a pipe
    symbol, in the American keyboard you get pushing the key over the enter and
    shift.)
    \item Negation is written: \verb"!".
\end{enumerate}

If we go back to the example of the fire sprinklers, let's make a program that
``simulates'' the system, I will write it now.
Up until now I have talked about true and false values, in C that is represented
with an integer type (any of those available). Zero is the false value, and
\textbf{all the other values} are true. Generally the result of a logic
operation will be one if it's true, but you cannot assume that when using
an integer type to store logic values.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Primer programa con operacioneslógicas},
label={lst:firstLogicProgram}]
#include <stdio.h>
int main(void)
{
    int temperature:greater_than_50 = 1;
    int smoke = 0;
    int aspersores = temperatura_mayor_50 || smoke;
}
\end{lstlisting}
\end{minipage}


% Sí, se parece a los programas aburridos que hacíamos antes, pero no te
% preocupes, la cuestión es que si vas a la tabla
% \ref{tab:logicOperationExample}: \nameref{tab:logicOperationExample} verás
% que se corresponde con la una disyunción, si hay humo, la temperatura es alta,
% o las dos a la vez, saltarán los aspersores. Sin embargo; esto sigue siendo
% algo inútil,
% no podemos comprobar si la temperatura es mayor o menor que 50, hemos tenido que
% inventárnoslo. Y esto me lleva a prensentarte otro conjunto de operadores, los
% operadores de comparación. Esto es fácil, en C podemos comprobar si una
% variable es igual, distinta, mayor o menor que otra. Escribo la tabla y
% mejoramos el programa que teníamos antes.
% \begin{table}[H]
% \centering
% \begin{tabularx}{\linewidth}{|c|Y|}
% \hline
% \bf Operador & \bf Descripción \\ \hline
% \tt < &   Cierto si el operando izquierdo es menor que el derecho, falso en otro caso.\\\hline
% \tt > &   Cierto si el operando izquierdo es mayor que el derecho, falso en otro caso.\\\hline
% \tt <= &  Cierto si el operando izquierdo es menor o igual que el derecho, falso en otro caso. \\\hline
% \tt >= &  Cierto si el operando izquierdo es mayor o igual que el derecho, falso en otro caso. \\\hline
% \tt == &  Cierto si los valores son iguales, falso en otro caso.\\\hline
% \tt != &  Cierto si los valores son distintos, falso en otro caso. \\\hline
% \end{tabularx}
% \caption{Operadores de comparación de C}
% \label{tab:logicOperators}
% \end{table}

Yes, it looks like the boring programs we were doing up until now, do not worry,
the matter is: if you go back to \ref{tab:logicOperationExample}:
\nameref{tab:logicOperationExample} you're going to see that the program is just
a disjunction, if there is smoke, or the temperature is high, or both, the
sprinklers will go off. Nevertheless, this program is still a bit useless. We
cannot check is the temperature is greater or lower than 50 \centigrade, we have
had to make it up. This leads me to present another set of operators to you,
the comparison operators. This is easy, in C we can check is one variable
(or expression) is equals, greater or less than than another. I will write the
table and let's improve the program we had before.
\begin{table}[H]
\centering
\begin{tabularx}{\linewidth}{|c|Y|}
\hline
\bf Operator & \bf Description \\ \hline
\tt < &   True is the left operand is less than the right one, false otherwise.\\\hline
\tt > &   True is the left operand is greater than the right one, false otherwise.\\\hline
\tt <= &  True is the left operand is less than or equal to the right one, false otherwise. \\\hline
\tt >= &  True is the left operand is greater than or equal to the right one, false otherwise. \\\hline
\tt == &  True is both operands are equal, false otherwise. \\\hline
\tt != &   True is both operands are different, false otherwise. \\\hline
\end{tabularx}
\caption{Comparison operators}
\label{tab:logicOperators}
\end{table}

% Ahora que ya conoces los operadores de comparación y los lógicos, vamos a hacer
% un programa que compruebe si un número está en el intervalo $\left(a, b\right]$,
% es decir: entre $a$ y $b$, incluyendo $b$, pero sin incluir $a$.

Now you know comparison operators, let's make a program that checks is a given
value is in the interval $\left(a, b\right]$, that is, between $a$ and $b$,
including $b$, without including $a$.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Primer programa con operaciones de comparación},
label={lst:firstComparingProgram}]
#include <stdio.h>
int main(void)
{
    int number = 5;
    int a = 0;
    int b = 10;

    int is_in_interval = number > a && number <= b;

    printf("%d is in (%d, %d] is equal to: %d\n",
               number, a, b, is_in_interval);
}
\end{lstlisting}
\end{minipage}

As you can see, there is no need for parenthesis, comparations are executed
before logic operations. I'll take advantage of the fact that I have already
presented three set of operands (mathematical, logical and comparison) to tell
you that there is nothing wrong with declaring variables along the program
to hold partial values of what you want to calculate, specially if a given
expression becomes too big. I would even advise you to do that when you feel
like it and then remove the intermediate variables as an exercise, at least in
your first programs.

\subsubsection{Diverging the flow: the \texttt{if}}
% Ahora que ya sabemos cómo crear condiciones lógicas (proposiciones) que sean
% ciertas o falsas, podemos crear nuestra primera sentencia condicional. En C,
% una sentencia condicional se crea con la palabra clave \lstinline!if!. A
% continuación te presento la estructura básica de un \texttt{if}, pero esto
% \textbf{no} es un programa correcto en C.

Now we know how to create logic conditions (propositions) that can be either
true or false, we can create our first conditional sentence. In C, a conditional
sentence is made with the key word \lstinline[style=C]!if!. A will present to
you now the basic structure of an \texttt{if}, but this is \textbf{not}  a
valid C program.


\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Basic structure of \texttt{if} sentence},
label={lst:ifStructure}]
if(/*condition*/)
{
    //Executes only if condition is true.
}
else
{
    //Executes only if condition is false.
}
\end{lstlisting}
\end{minipage}

Now we can improve our first program that simulates the sprinkler system!
Let's add the comparison and logical operators.


\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Fire sprinkler program with logic and comparison operators},
label={lst:sprinklerLogicComp}]
#include <stdio.h>
int main(void)
{
    int temperature = 25;
    int smoke = 0;

    if (temperature > 50 || smoke)
    {
        printf("Aspersores activados.\n");
    }
    else
    {
        printf("Aspersores apagados.\n");
    }
}
\end{lstlisting}
\end{minipage}


% Como nos ha venido pasando, cada vez que cambies algún valor deberás recompilar
% y ejecutar. Cambia los valores de las variables \texttt{humo} y
% \texttt{temperature} para que cambie el resultado del condicional. Finalmente,
% podemos mejorar nuestro programa de resolución de ecuaciones
% lineales, antes de hacer cualquiera de las operaciones, debemos comprobar que
% el divisor no es cero. Para ello simplemente declararemos más variables y
% después dividiremos por ellas.

As we have been suffering before, each time you change any value you will have
to recompile and execute. Change the values of the variable \texttt{smoke} and
\texttt{temperature} to make the result of the conditional change. Finally,
we can improgram of resolution of linear equations, before performing any of the
calculations we will check if the system has a solution. To do that, we need to
check that the divider is not zero. To do that we simply declare more
variables and then divide by them.


\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Linear equation resolution program with conditional},
label={lst:linealSystemConditional}]
#include <stdio.h>
int main(void)
{
    int a = 1;
    int b = 1;
    int c = 1;
    int d = 2;
    int e = 2;
    int f = 2;

    double divider = (a * e - d * b);

    if (divider == 0 || d == 0)
    {
        printf("The system is irresolvable.\n");
    }
    else
    {
        double y = (a * f - d * c) / divider;
        double x = (f - e * y) / (d);
        printf(" %dx+ %dy= %d\n", a, b, c);
        printf(" %dx+ %dy= %d\n", d, e, f);
        printf("x = %f; y = %f\n", x, y);
    }
}
\end{lstlisting}
\end{minipage}

% Esto ya se parece algo más a un programa <<de verdad>>, podríamos decir que ya
% estamos metidos en harina. Pero el condicional aún tiene más desarrollo: se
% puede encadenar. A veces queremos comprobar una cadena de condiciones una
% detrás de otra y ejecutar sólo las instrucciones correspondientes a la primera
% que se cumpla. Imagina un programa que recibe la temperatura ambiente y, en
% función de ella, da un mensaje sobre el tiempo, por ejemplo:
% \begin{enumerate}
% \item Si hay  40\centigrade{} o más, imprimir <<Hace mucho calor.>>
% \item Si hay  35\centigrade{} o más, imprimir <<Hace calor.>>
% \item Si hay  25\centigrade{} o más, imprimir <<Hace un buen día.>>
% \item Si hay  10\centigrade{} o más, imprimir <<Hace fresquito.>>
% \item Si hay menos de 10\centigrade{} imprimir <<Hace mucho frío.>>
% \end{enumerate}

This is more alike to a ``real'' program, we could say that we are already
hands down on the matter. But the conditional has more things to it. You can
chain them. Sometimes we want to check a chain of conditions one after the
other and execute the instructions related to the first true condition. Imagine
a program that receives the temperature and, depending on what it is, throws a
message about the weather.
\begin{enumerate}
\item If it's 40\centigrade{} or more, print ``It's hot.''
\item If it's 35\centigrade{} or more, print ``It's warm.''
\item If it's 25\centigrade{} or more, print ``It's a nice day.''
\item If it's 10\centigrade{} or more, print ``It's a little bit chilly here.''
\item If it's less than 10\centigrade{}, print ``It's very cold.''
\end{enumerate}

I have writen the sentences in that way purposely so you realize that, even when
forty degrees is more than ten, we don't want to print that it's hot, it's a
nice day and it's a little bit chilly here, only the condition that arrives
first. To do so C gives us the \texttt{if-else} sentence, in which we ``chain''
an \texttt{if} statement to the \texttt{else} of the other conditional. In
that way, only if the condition before was false, the next one will be checked
and, if it is true, the instructions inside that \texttt{if-else} will be
executed, let's see it with an example.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Example program for \texttt{if-else}},
label={lst:ifelse}]
#include <stdio.h>
int main(void)
{
    int temp = 10;
    if (temp >= 40) {
        printf("It's hot.\n");
    }
    else if (temp >= 35) {
        printf("It's warm.\n");
    }
    else if (temp >= 25) {
        printf("It's a nice day.\n");
    }
    else if (temp >= 10) {
        printf("It's a little bit chilly here.\n");
    }
    else {
        printf("It's very cold.\n");
    }
}
\end{lstlisting}
\end{minipage}

As you can see, we have finished the chain of \texttt{if-else} with an
\texttt{else}, this means that in case no condition is true in the chain,
the instructions inside the else will be executed. In this case, print
``It's very cold''.

Now we have seen conditionals, we can revisit our program that solves linear
equation systems. If you remember, in the last revision
(\nameref{lst:linealSystemConditional}) we deemed the problem as insolvable if
$d=0$. Nevertheless, if you remember a little of algebra from high school and
you come back to the equation, you will see that $d$ being equal to zero does
not mean the problem has no solution, but that we should solve for $y$ in both
equations and not $x$. That is:

\begin{figure}[H]
$$
(1)\; ax+by=c \to y = \frac{c-ax}{b}
$$
$$
(2)\; dx+ey=f \to y = \frac{f-dx}{e}
$$
$$
(1) \;\mathrm{and} \; (2) \to \frac{c-ax}{b}=\frac{f-dx}{e}\to
ec - eax = bf-bdx \to x = \frac{bf-ec}{bd-ea}\to y=\frac{c-a\cdot{}\frac{bf-ec}{bd-ea}}{b}
$$
\end{figure}

In case this is not possible, it means that nor $x$ or $y$ are in both
equations, that is, we have one equations that solves for $x$ and other for $y$.
Either we have$\left\{\matrix{ax=c\cr ey=f}\right.$ or we have
$\left\{\matrix{by=c\cr dx=f}\right.$. Simply checking if $a=0$ we will know in
which case we are. Finally, we could be in the case that we had just one
equation, if the terms that multiply $x$ or $y$ in any of them were zero, but
in this case this is not a system and it is not possible to give values to
$x$ and $y$. If we write the code, let's see how it would look.

\newpage
\begin{lstlisting}[style=C,
caption={Program solving a linear equations system with conditionals},
label={lst:linealSystemFinal}]
#include <stdio.h>
int main(void)
{
    int a = 12, b = 2, c = 10, d = 50, e = 11, f = 17;
    int irresolvable = 0;
    double divider, x, y;
    if (a != 0 && d != 0) {
        divider = (a * e - d * b);
        if (divider == 0)
        {
            printf("The system is irresolvable.\n");
            irresolvable = 1;
        }
        else
        {
            y = (a * f - d * c) / divider;
            x = (f - e * y) / (d);
        }
    }
    else if (b != 0 && e != 0) {
        divider = (b * d - e * a);
        if (divider == 0) {
            printf("The system is irresolvable.\n");
            irresolvable = 1;
        }
        else {
            x = (b * f - e * c) / divider;
            y = (c - a * x) / b;
        }
    }
    else if (a == 0 && b == 0 || d == 0 && e == 0) {
        printf("This is not a system.\n");
        irresolvable = 1;
    }
    else {
        if (a != 0) {
            x = (double)c / a;
            y = (double)f / e;
        }
        else {
            x = (double)f / d;
            y = (double)c / b;
        }
    }
    if (!irresolvable) {
        printf(" %dx+ %dy= %d\n", a, b, c);
        printf(" %dx+ %dy= %d\n", d, e, f);
        printf("x = %f; y = %f\n", x, y);
    }
}
\end{lstlisting}

This program is a little long, but I am going to go conditional by conditional.
First of all, let's circle back and rethink which possibilities we have
according to the system. We can be in one of these four cases:
\begin{itemize}
\item $x$ is present in both equations, therefore, we can solve for it in both
equations as we did the first time we solved the problem. In this case, if
the divider we calculated is zero, the problem is not solvable.
\item $y$ is present in both equations, we can solve for it as we did just
before showing this version program.
\item In one of the equations, both $x$ and $y$ are multiplied by zero,
therefore this is not a system, and we cannot solve it.
\item We can be in the case we can't solve both equations for one unknown,
because one of them is present in the first equation, and the other in the
second one.
\end{itemize}

In the first lines of the problem I am declaring a bunch of variables, I am
sorry because I didn't teach you to do it in this abbreviated way, but I wanted
the program to fit in one page. We will explain it later. I just declare
the same values as before, and a logic variable called irresolvable, that will
allow me to know if I have solved the problem at the end of it to
print the solutions.
The cases listed before are  present in my program, in the first \texttt{if}
we check if the coefficients that multiply $x$ in both equations are different
from zero. In this case, we try the first solving method: calculate the value
of the divider and applying it. Inside this condition, if the divider is zero,
the system is not solvable, else, we simply solve the system with it.
As you can see, you can put conditionals inside conditionals.

In the next \texttt{if-else} we are checking if the can solve for $y$ in both
equations. This case is basically the same than the other, but applying the
other set of formulas. We calculate the divider of the value of $x$ in this
case, if it is zero, we cannot solve it.
The next conditional checks if in any of the equations the coefficients of
both unknowns are zero. In this case, as we said, this is not a system and we
cannot solve it.
Finally, if we are not in any of the aforementioned cases, that means we're in
the last one: $x$ is in one equation and $y$ in the other. We check if $a$ is
zero, if it is not, we know the first equation gives us the value of $x$ and
the second the value of $y$.

At the end, we simply check the variable irresolvable, that tells us if we have
marked the program as so. If we haven't it means we have solutions, so we just
print them.

\subsection{Code blocks and scopes}
Now you know the first control structure, I must talk to you about \textbf{code
blocks}, a code block is the piece of code that is between two braces (\{...\}).
The main implication of enclosing code between braces in a block is that the
variables declared inside it are not visible outside, but those declared outside
are visible inside the block.
If you remember the basic structure of the conditional, you will see it includes
braces, also, in the first program that I presented to you I told you will
always have to write a series of lines, those include a single code block.
Inside that block we have put all the instructions in all our programs. Now
we have conditionals, we hace nested blocks (blocks inside blocks).

All variable declared in C has a \textbf{scope}, that is the portion of the code
in which the variable can be seen, the scope of a variable is the block in qhich
it's been declared and all those block inside that one.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Example of scope of declared variables},
label={lst:scopeVar}]
#include <stdio.h>
int main(void)
{
    int exterior = 0;
    if (exterior == 0) {
        double inner = 1.3;
        exterior = 120; // OK: variable from an outter block
    }
    inner = 10.3; // Error: variable not defined
}
\end{lstlisting}
\end{minipage}

If you try to compile the code I just shown, you will se the compile says the
variable \texttt{inner} is not declared, even when you declared it ``before''.
Another of the side effects of blocks is that you can define variables that
already existen in outter blocks. Let's see an example.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Example of redefinition of variable},
label={lst:varRedefinition}]
#include <stdio.h>
int main(void)
{
    int number = 0;
    int exterior = 3;
    if (number == 0) {
        int exterior = 10;
        printf("%d\n", exterior);
    }
    printf("%d\n", exterior);
}
\end{lstlisting}
\end{minipage}

If you compile an execute this program, you'll see it prints firstly 10 and
later 3. This is because there two variables with the same name. How is this
possible? How does C to which variable are you referencing? Simply those
variables that are local (those declared in the block you're in) have priority
over those declared in more external blocks. This means you cannot access
external variables if you have declared any with the same name in an inner
block.

Now that you know that the scope is, let's explain some things of those I
couldn't explain before. Firstly I want to tell you that outside the braces of
our first program we can write things. Concretely, we can declare variables,
which are called \textbf{global variables}. They are called like that because
they have a ``global'' scope. That is: any other instruction in your program
have access to them (unless they declared a variable with the same name). I am
not going to take much time in them, at the moment, they're not useful to us,
but I am going to show you an example of how a program with them would look.


\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Example of a program with a global variable},
label={lst:globalVar}]
#include <stdio.h>

int globalVariable = 20;

int main(void)
{
    printf("%d\n", globalVariable);
}
\end{lstlisting}
\end{minipage}

The rule is that variables must be declared at the start of the block. This is
not mandatory, but it is a good practice. I leave it to your election but I
would encourage it.
Also, you must declare them in the most inner block in which you can, for
example in the program \ref{lst:linealSystemConditional} we have declared
the variables \texttt{x} and \texttt{y} in the only block we needed them, we
could have declared them at the start of the program, or as global variables,
but, since it was not necessary, we didn't do it.


\subsection{Other jump onstructions: \texttt{switch} and \texttt{goto}}

You know the most important way to make the flow of the program diverge, but
there are other two that still have some utility, I have already named them in
the title: \texttt{switch} and \texttt{goto}. The first one behaves like a
distributor of the flow of the program, given a variable it examines the value
and compares it with a series of cases, according to the case, it jump that
line. We could imagine the \texttt{switch} like a factory worker that classifies
products that go out an assembly line, according to the state of the product it
does a thing or another.


\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Example of a program with a \texttt{switch}},
label={lst:switchExample}]
#include <stdio.h>

int main(void)
{
    int day = 3;

    switch (day) {
        case 0:
        printf("Todays is: Monday\n");
        break;
        case 1:
        printf("Todays is: Tuesday\n");
        break;
        case 2:
        printf("Todays is: Wednesday\n");
        break;
        case 3:
        printf("Todays is: Thursday\n");
        break;
        case 4:
        printf("Todays is: Friday\n");
        break;
        case 5:
        printf("Todays is: Saturday\n");
        break;
        case 6:
        printf("Todays is: Sunday\n");
        break;
        default:
        printf("That number is not any day!\n");
        break;
    }
}
\end{lstlisting}
\end{minipage}

If you look the example program, a \texttt{switch} starts in a similar way to
a \verb!if!, but inside the parenthesis there is not a condition, but always a
variable. That variables must be an integer type. After that, in the body
of the \texttt{switch} there is a set of lines that start with \verb!case!,
after that you must write a literal value (it cannot be a variable) and then
the lines you want to execute in case the the variable in the switch has the
value of this case. That set of instructions can end or not with an special
instruction called \lstinline[style=C]!break;!. This instructions makes the
flow of the program to exit the switch. We need this because if we didn't put
it, the instructions in the following cases would execute also. If you execute
the problem as it is writen, it will print only the message of the Thursday, but
if you remove the breaks and recompile, it will print all days from Thursday on.

You would see there is a line that is not a \texttt{case}, but has been created
with the instruction \texttt{default}. This is because this keyword allows us
to tell what would happen if the value does not match any other case. In this
example we will print the number is not assigned to any day. You may have
noticed, or not, that a \texttt{switch} with \texttt{break} in all the cases
is basically a chain of \texttt{if-else}. This is true, a \texttt{switch} can be
always replaced with a chain of \texttt{if-else} (if it has break in every
line). In this case, the code associated with the default would be the code
in the \texttt{else} at the end of the chain.

The \texttt{switch} is an example of jumping to a label. A label is something
special because it stablishes a point in the to which you can jump with or
without a condition. The instruction to jump to a label is \texttt{goto}, let's
see a simple example and, later, I will explain its most common use case.
The code example for that code will be introduced in a later section, because
it will be difficult to understand without advancing more in the contents of
the language.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Example of a program with \texttt{goto}},
label={lst:gotoExample}]
#include <stdio.h>

int main(void)
{
    printf("Hello, this is the start of the program.\n");

    goto final;

    printf("I am a line that should not be printed.\n");

    final:
    printf("We have ended the program.\n");

}
\end{lstlisting}
\end{minipage}

% Si compilas y ejecutas esto, verás que imprimer la primera y la última línea,
% pero no la segunda. Esto es así porque hemos usado la instrucción \verb!goto!
% para saltar a un punto posterior del programa. El \verb!goto! es una instrucción
% muy peligrosa, en el sentido de que si en tu programa hay un número ligeramente
% elevado de ellos, es señal de que o no has pensado bien tu proceso, o te faltan
% herramientas para programarlo de una manera más apropiada. Así que, hasta que no
% veamos otras secciones del este manual, te recomiendo que reserves los
% \verb!goto! como una curiosidad más que como algo que debas usar.

If you compile the program and execute it, you would see that it prints the
first and last line, but not the second. This is so because we have used the
\texttt{goto} instruction to jump to a later point in the program. The use
of \texttt{goto} is very dangerous, in the sense that it shows you haven't
thought properly your program or you lack tools to make it in a better way.
Therefore, until we haven't gone through other sections of this manual, I
would discourage its ussage. I advise you to save gotos as a novelty more
than a common-use tool.

\subsection{Repeat instructions: loops}
% Al inicio de esta sección te expliqué que hacer que el ordenador repita
% operaciones es algo imprescindible para los programas funcionen, y aquí vamos
% a aprender cómo: con los bucles, o en inglés: \textit{loops}. Hay dos tipos
% principales de bucles en C: el \lstinline[style=C]!while! y el
% \lstinline[style=C]!for!.
% Del mismo modo que
% hicimos con el condicional, vamos a ver primero la estructura del flujo del
% programa, después cómo se escribe en C y finalmente veremos ejemplos de cómo
% se utilizaría en algunos programas.

At the start of this section I expalined to you that making the computer to
repeat instructions is necessary to make programs work, and here we're going
to learn how: with \textbf{loops}. There two main kinds of loops:
\lstinline[style=C]!while! and \lstinline[style=C]!for!.
In the same fashion we did with the conditional, we will see firstly the flow
structure of the program, later how it is writen in C and finally example on
how to use the loops in some programs.

\subsubsection{The \texttt{while} loop}
% Este es el tipo de bucle más sencillo y por eso lo vamos a explicar primero,
% básicamente declara una serie de instrucciones que se repetirán mientras se
% cumpla una condición. Imagínate que quisieras imprimir todos los números de 1
% al cien. Podrías escribir 100 líneas que imprimiesen cada número o podrías
% decirle al ordenador que imprima una variable, le sume uno, y vuelva a
% imprimirla durante cien veces.

This is the most basic kind of loop, and that's why we're going to explain it
firtly, simply sets a series of instructions that will be executed as long
(while) a condition is true. Imagine you wanted to print all numbers from
one to 100. You could write 100 lines that print every number or you could
tell the computer to print a variable, add one to it, and then print it again
while it is less than 100.

\begin{figure}[H]
\centering
% generated by Plantuml 1.2022.7
\definecolor{plantucolor0000}{RGB}{34,34,34}
\definecolor{plantucolor0001}{RGB}{241,241,241}
\definecolor{plantucolor0002}{RGB}{24,24,24}
\definecolor{plantucolor0003}{RGB}{0,0,0}
\definecolor{plantucolor0004}{RGB}{17,17,17}
\begin{tikzpicture}[yscale=-1
,pstyle1/.style={color=plantucolor0002,fill=plantucolor0001,line width=0.5pt}
,pstyle4/.style={color=plantucolor0002,line width=1.0pt}
,pstyle5/.style={color=plantucolor0002,fill=plantucolor0002,line width=1.0pt}
]
\draw[color=plantucolor0000,fill=plantucolor0000,line width=1.0pt] (99.7556pt,20pt) ellipse (10pt and 10pt);
\draw[pstyle1] (56.6556pt,67.6055pt) arc (180:270:17.6055pt) -- (74.261pt,50pt) -- (125.2501pt,50pt) arc (270:360:17.6055pt) -- (142.8556pt,67.6055pt) -- (142.8556pt,67.6055pt) arc (0:90:17.6055pt) -- (125.2501pt,85.2109pt) -- (74.261pt,85.2109pt) arc (90:180:17.6055pt) -- (56.6556pt,67.6055pt) -- cycle;
\node at (66.6556pt,60pt)[below right,color=black]{variable = 0};
\draw[pstyle1] (60.0967pt,184.7598pt) arc (180:270:17.6055pt) -- (77.7022pt,167.1543pt) -- (121.8089pt,167.1543pt) arc (270:360:17.6055pt) -- (139.4144pt,184.7598pt) -- (139.4144pt,184.7598pt) arc (0:90:17.6055pt) -- (121.8089pt,202.3652pt) -- (77.7022pt,202.3652pt) arc (90:180:17.6055pt) -- (60.0967pt,184.7598pt) -- cycle;
\node at (70.0967pt,177.1543pt)[below right,color=black]{variable++};
\draw[pstyle1] (47pt,248.499pt) arc (180:270:17.6055pt) -- (64.6055pt,230.8936pt) -- (134.9056pt,230.8936pt) arc (270:360:17.6055pt) -- (152.5111pt,248.499pt) -- (152.5111pt,248.499pt) arc (0:90:17.6055pt) -- (134.9056pt,266.1045pt) -- (64.6055pt,266.1045pt) arc (90:180:17.6055pt) -- (47pt,248.499pt) -- cycle;
\node at (57pt,240.8936pt)[below right,color=black]{print (variable)};
\draw[pstyle1] (62.5798pt,105.2109pt) -- (136.9313pt,105.2109pt) -- (148.9313pt,117.2109pt) -- (136.9313pt,129.2109pt) -- (62.5798pt,129.2109pt) -- (50.5798pt,117.2109pt) -- (62.5798pt,105.2109pt) -- cycle;
\node at (103.7556pt,129.2109pt)[below right,color=black]{true};
\node at (62.5798pt,110.2393pt)[below right,color=black]{variable \textless  100};
\node at (29.1893pt,103.2676pt)[below right,color=black]{false};
\draw[color=plantucolor0000,line width=1.0pt] (24pt,164.2109pt) ellipse (11pt and 11pt);
\draw[color=plantucolor0004,fill=plantucolor0000,line width=1.0pt] (24pt,164.2109pt) ellipse (6pt and 6pt);
\draw[pstyle4] (99.7556pt,30pt) -- (99.7556pt,50pt);
\draw[pstyle5] (95.7556pt,40pt) -- (99.7556pt,50pt) -- (103.7556pt,40pt) -- (99.7556pt,44pt) -- cycle;
\draw[pstyle4] (99.7556pt,202.3652pt) -- (99.7556pt,230.8936pt);
\draw[pstyle5] (95.7556pt,220.8936pt) -- (99.7556pt,230.8936pt) -- (103.7556pt,220.8936pt) -- (99.7556pt,224.8936pt) -- cycle;
\draw[pstyle4] (99.7556pt,129.2109pt) -- (99.7556pt,167.1543pt);
\draw[pstyle5] (95.7556pt,157.1543pt) -- (99.7556pt,167.1543pt) -- (103.7556pt,157.1543pt) -- (99.7556pt,161.1543pt) -- cycle;
\draw[pstyle4] (99.7556pt,266.1045pt) -- (99.7556pt,276.1045pt);
\draw[pstyle4] (99.7556pt,276.1045pt) -- (164.5111pt,276.1045pt);
\draw[pstyle5] (160.5111pt,210.8936pt) -- (164.5111pt,200.8936pt) -- (168.5111pt,210.8936pt) -- (164.5111pt,206.8936pt) -- cycle;
\draw[pstyle4] (164.5111pt,117.2109pt) -- (164.5111pt,276.1045pt);
\draw[pstyle4] (164.5111pt,117.2109pt) -- (148.9313pt,117.2109pt);
\draw[pstyle5] (158.9313pt,113.2109pt) -- (148.9313pt,117.2109pt) -- (158.9313pt,121.2109pt) -- (154.9313pt,117.2109pt) -- cycle;
\draw[pstyle4] (50.5798pt,117.2109pt) -- (24pt,117.2109pt);
\draw[pstyle4] (24pt,117.2109pt) -- (24pt,153.2109pt);
\draw[pstyle5] (20pt,143.2109pt) -- (24pt,153.2109pt) -- (28pt,143.2109pt) -- (24pt,147.2109pt) -- cycle;
\draw[pstyle4] (99.7556pt,85.2109pt) -- (99.7556pt,105.2109pt);
\draw[pstyle5] (95.7556pt,95.2109pt) -- (99.7556pt,105.2109pt) -- (103.7556pt,95.2109pt) -- (99.7556pt,99.2109pt) -- cycle;
\end{tikzpicture}
\caption{Flow diagram: program that prints the numbers from 1 to 100}
\label{img:whileFlux}
\end{figure}

As always, I leave you the code that would produce this result.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Example with a \texttt{while} loop},
label={lst:whilePrint}]
#include <stdio.h>
int main(void)
{
    int variable = 0;

    while (variable < 100) {
        variable++;
        printf("%d\n", variable);
    }
}
\end{lstlisting}
\end{minipage}

The \texttt{while} loop is the simplest of them, as you can see. The
instructions that are in the code are executed only in the condition is true.
This has two implications: is the condition is \textbf{not} true when you arrive
to the \texttt{while} instruction, the loop will never be executed, not even
once. The other is that if there is nothing that changes the value of the
condition of the loop inside it, the loop will execute forever. For example in
this loop we change the value of variable so it reaches 100 and the loop ends.

% Hay un tipo especial de bucle \texttt{while} que ejecutará las instrucciones
% siempre \textbf{al menos una vez}, porque la primera ejecución la hace antes de
% evaluar la condición. Veamos un ejemplo:

There is a special kind of loop \texttt{while} that will execute the
instructions always \texttt{at least once}, because the first execution will be
done before evaluating the condition. Let's see an example.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Ejemplo de programa con un bucle \texttt{do-while}},
label={lst:doWhile}]
#include <stdio.h>
int main(void)
{
    int variable;

    do{
        variable = rand();
        printf("Variable aleatoria = %d\n", variable);
    }while(variable != 10);
}
\end{lstlisting}
\end{minipage}

This program generales a random number (you must believe it until I explain more
concepts) and prints it, then, if the numbers is not 10, prints it again and
changes the varuable value to another random value. Why would we need to use
\texttt{do-while}? because with it we do not need to initialize the variable
outside the loop, and all the ocurrences of the use a \texttt{rand} will be
inside. This lopp is much less used than \texttt{while} and shares with the
switch that is it something that doesn't get used much, but when it does, it's
due to be used, it makes things to be easier.

\subsubsection{The \texttt{for} loop}

The \texttt{for} loop is a loop that works as while, but that does two things
more: it executes an instruction \textbf{before executing anything inside the
loop} and other \textbf{at the end of each repetition}. Let's see the flow
diagram and how it's writen.
\begin{figure}[H]
\centering
% generated by Plantuml 1.2022.7
\definecolor{plantucolor0000}{RGB}{34,34,34}
\definecolor{plantucolor0001}{RGB}{241,241,241}
\definecolor{plantucolor0002}{RGB}{24,24,24}
\definecolor{plantucolor0003}{RGB}{0,0,0}
\definecolor{plantucolor0004}{RGB}{17,17,17}
\begin{tikzpicture}[yscale=-1
,pstyle1/.style={color=plantucolor0002,fill=plantucolor0001,line width=0.5pt}
,pstyle4/.style={color=plantucolor0002,line width=1.0pt}
,pstyle5/.style={color=plantucolor0002,fill=plantucolor0002,line width=1.0pt}
]
\draw[color=plantucolor0000,fill=plantucolor0000,line width=1.0pt] (133.4242pt,20pt) ellipse (10pt and 10pt);
\draw[pstyle1] (92.379pt,67.6055pt) arc (180:270:17.6055pt) -- (109.9844pt,50pt) -- (156.8641pt,50pt) arc (270:360:17.6055pt) -- (174.4695pt,67.6055pt) -- (174.4695pt,67.6055pt) arc (0:90:17.6055pt) -- (156.8641pt,85.2109pt) -- (109.9844pt,85.2109pt) arc (90:180:17.6055pt) -- (92.379pt,67.6055pt) -- cycle;
\node at (102.379pt,60pt)[below right,color=black]{assignment};
\draw[pstyle1] (90.2769pt,166.8164pt) arc (180:270:17.6055pt) -- (107.8823pt,149.2109pt) -- (158.9661pt,149.2109pt) arc (270:360:17.6055pt) -- (176.5716pt,166.8164pt) -- (176.5716pt,166.8164pt) arc (0:90:17.6055pt) -- (158.9661pt,184.4219pt) -- (107.8823pt,184.4219pt) arc (90:180:17.6055pt) -- (90.2769pt,166.8164pt) -- cycle;
\node at (100.2769pt,159.2109pt)[below right,color=black]{instructions};
\draw[pstyle1] (69.066pt,237.0273pt) arc (180:270:17.6055pt) -- (86.6715pt,219.4219pt) -- (180.177pt,219.4219pt) arc (270:360:17.6055pt) -- (197.7825pt,237.0273pt) -- (197.7825pt,237.0273pt) arc (0:90:17.6055pt) -- (180.177pt,254.6328pt) -- (86.6715pt,254.6328pt) arc (90:180:17.6055pt) -- (69.066pt,237.0273pt) -- cycle;
\node at (79.066pt,229.4219pt)[below right,color=black]{end of the iteration};
\draw[pstyle1] (108.9333pt,105.2109pt) -- (157.9152pt,105.2109pt) -- (169.9152pt,117.2109pt) -- (157.9152pt,129.2109pt) -- (108.9333pt,129.2109pt) -- (96.9333pt,117.2109pt) -- (108.9333pt,105.2109pt) -- cycle;
\node at (108.9333pt,110.2393pt)[below right,color=black]{condition};
\node at (10pt,103.2676pt)[below right,color=black]{condition is false};
\draw[color=plantucolor0000,line width=1.0pt] (46.066pt,160.2109pt) ellipse (11pt and 11pt);
\draw[color=plantucolor0004,fill=plantucolor0000,line width=1.0pt] (46.066pt,160.2109pt) ellipse (6pt and 6pt);
\draw[pstyle4] (133.4242pt,30pt) -- (133.4242pt,50pt);
\draw[pstyle5] (129.4242pt,40pt) -- (133.4242pt,50pt) -- (137.4242pt,40pt) -- (133.4242pt,44pt) -- cycle;
\draw[pstyle4] (133.4242pt,184.4219pt) -- (133.4242pt,219.4219pt);
\draw[pstyle5] (129.4242pt,209.4219pt) -- (133.4242pt,219.4219pt) -- (137.4242pt,209.4219pt) -- (133.4242pt,213.4219pt) -- cycle;
\draw[pstyle4] (133.4242pt,129.2109pt) -- (133.4242pt,149.2109pt);
\draw[pstyle5] (129.4242pt,139.2109pt) -- (133.4242pt,149.2109pt) -- (137.4242pt,139.2109pt) -- (133.4242pt,143.2109pt) -- cycle;
\draw[pstyle4] (133.4242pt,254.6328pt) -- (133.4242pt,264.6328pt);
\draw[pstyle4] (133.4242pt,264.6328pt) -- (209.7825pt,264.6328pt);
\draw[pstyle5] (205.7825pt,199.9219pt) -- (209.7825pt,189.9219pt) -- (213.7825pt,199.9219pt) -- (209.7825pt,195.9219pt) -- cycle;
\draw[pstyle4] (209.7825pt,117.2109pt) -- (209.7825pt,264.6328pt);
\draw[pstyle4] (209.7825pt,117.2109pt) -- (169.9152pt,117.2109pt);
\draw[pstyle5] (179.9152pt,113.2109pt) -- (169.9152pt,117.2109pt) -- (179.9152pt,121.2109pt) -- (175.9152pt,117.2109pt) -- cycle;
\draw[pstyle4] (96.9333pt,117.2109pt) -- (46.066pt,117.2109pt);
\draw[pstyle4] (46.066pt,117.2109pt) -- (46.066pt,149.2109pt);
\draw[pstyle5] (42.066pt,139.2109pt) -- (46.066pt,149.2109pt) -- (50.066pt,139.2109pt) -- (46.066pt,143.2109pt) -- cycle;
\draw[pstyle4] (133.4242pt,85.2109pt) -- (133.4242pt,105.2109pt);
\draw[pstyle5] (129.4242pt,95.2109pt) -- (133.4242pt,105.2109pt) -- (137.4242pt,95.2109pt) -- (133.4242pt,99.2109pt) -- cycle;
\end{tikzpicture}
\caption{Flow diagram of a \texttt{for} loop}
\label{img:forLoop}
\end{figure}

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Structure of a \texttt{for} loop},
label={lst:doWhile}]
#include <stdio.h>
int main(void)
{
    for (/*Assignment*/;/*Condition*/;/*End of iteration*/) {
        /*Instructions*/
    }
}
\end{lstlisting}
\end{minipage}

Where I write assignment is because in that part of the loop you must write
an assignment to a variable, or an assignment and declaration in the same
place. Where I write condition you must write the condition that will control
when the loop will stop executing (or if it executes at all). At the end of
every repetition of the loop (formally we call iterations to the repetitions of
the loop) the instruction you wrote where I wrote end of iteration will be
executed. It's much clearer in the example.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Example of a program with a \texttt{for} loop},
label={lst:forStructure}]
#include <stdio.h>
int main(void)
{
    for (int ii = 1; ii <= 100; ++ii) {
        printf("%d\n", ii);
    }
}
\end{lstlisting}
\end{minipage}

This program performs the same task that we did with the \texttt{while} loop.
As you can see, we declare and initialize a variable called \texttt{ii}, with
value one, execute the body of the loop (the body is the block of code that
will repeat itself) and, at the end to every iteration the varuable will be
incremented in one. This kind of loop tend to be very used along something
called arrays, which we will see later.

\subsection{Loop interruption}
Sometimes we want to end an execution of a loop in the middle of an iteration,
in this case we are going to write a program that calculates the power of two
that id greater or equal than a target.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Example of interruption of a loop with an auxiliary variable},
label={lst:loopInterruption}]
#include <stdio.h>
int main(void) {
    int steps     = 0;
    int max_steps = 20;
    int number    = 1;
    int target    = 1024;

    while (steps < max_steps && number < target) {
        steps++;
        number *= 2;
    }
    printf("2 to the %d is greater or equal than %d\n", steps, target);
}
\end{lstlisting}
\end{minipage}

This program calculates the lowest power of 2 that is equal or greater than a
target. We also make sure not to calculate any longer than the max number of
steps that we want.
The variables we need are: the counter of the steps we have done
(\texttt{steps}) (the power we
are testing), the maximun number of steps we are allowed to test
(\texttt{max\_steps}), then a
variable called \texttt{number} that allows us to keep multiplying it by two
and, finally, the \texttt{target} we want to check.
So, basically we have a \texttt{while} with this condition:
as long as the steps we have done are less than the max, and number is less than
our target, we multiply number by two and increase the counter of steps.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Interrupción de un bucle con la instrucción \texttt{break}},
label={lst:breakExample}]
#include <stdio.h>
int main(void) {
    int steps     = 0;
    int max_steps = 20;
    int number    = 1;
    int target    = 1025;

    while (steps < max_steps) {
        steps++;
        number *= 2;
        if (number >= target) {
            break;
        }
    }
    printf("2 to the %d is greater or equal than %d\n", steps, target);
}
\end{lstlisting}
\end{minipage}

In this case we have moved half of our condition to a conditional inside the
loop, that checks if the number is greater or equal than the target.
Note that we have had to \textbf{invert} the condition. Before, we checked if
number was strictly less than target, because it was the condition to
\textbf{keep computing}, here we are checking the opposite, if number is greater
or equal than the target, because this new condition \textbf{ends} the
computation.
If the breaking condition is true,
we execute a \texttt{break}, exiting from the loop, printing the result
and ending the program.

This way of writting loops is discouraged, ideally all
the conditions that affect a loop termination should be in the loop, or in a
variable that gets cheked in the loop itself. Hence this is not a good practice
in programming, but this is not a manual about that, but to learn the language,
I put this example to allow you to understand this if you see code where it
appears.

Also: \texttt{break} has its counterpart, which is \texttt{continue}. This
instruction omits \textbf{what is left of this iteration} and jumps directly to
the next. Imagine, for example, we want to print if the years from 1 to 2021 are
leap years or not. A year is a leap year given these conditions.
\begin{enumerate}
    \item It is divisible by four.
    \item It is not divisible by one hundred.
    \item It is, in any case, if it is divisible by four hundred.
\end{enumerate}

% Si una de las condiciones no se cumple, no tiene sentido que comprobemos
% las siguientes, veamos cómo se implementaría sin \verb!continue!.

If one of those conditions is not true, there is no reason to check any other
one, let's see how it will be writen without \texttt{continue}.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Example of algorithm of leap year},
label={lst:lapExample}]
#include <stdio.h>
int main(void)
{
    for(int ii = 0; ii < 2021; ++ii){
        int bisiesto = ii % 400 == 0 ||
                          (ii % 4 == 0 && !(ii % 100 == 0));
        if(bisiesto){
            printf("El año %d es bisiesto.\n", ii);
        }
    }
}
\end{lstlisting}
\end{minipage}

A somewhat complex condition pops up, but if we write it with \texttt{continue}:

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Example of algorithm with continue},
label={lst:continueExample}]
#include <stdio.h>

int main(void)
{
    for(int ii = 0; ii < 2021; ++ii){
        if(ii % 4 != 0){
            continue;
        }
        if(ii % 100 == 0 && ii % 400 != 0){
            continue;
        }
        printf("El año %d es bisiesto\n", ii);
    }


}
\end{lstlisting}
\end{minipage}

It uses more lines, but some people may argue it is easier to read, you could
read it as ``if it is not divisible by four, go to the next number, if it is
divisible by one hundred but not by four hundred, go to the next too''.
Also, te printing order is not in a conditional, because if we reach the line,
we already know the number is a leap year.

As it happened with \texttt{break}, this is not a better way to write a program,
but I needed to invent some example with the limited content I have shown
now. Again, take \texttt{continue} as a novelty more than something that will
be used most often than not.
\section{Data structures}
Data structures are one of the most important things in programming and
in computer science, until now the only structure you know were variables, each
one of a type and with a different name. This is the structure más simple, but
very often we need more complex structures, in this section we will see two
simple data structures that C provides to the programmer: the array and
the struct, or structure. Structure has a generic meaning as the one I used in
the title, and the sepecific one of being the artifact of the C language I am
going to show you.

\subsection{The array}
Sometimes we want to pack data of the same type together, those packets are
called arrays. An array is an structure in which we declare space for several
variables, which we will reference by the name of the array and its position
inside it. That is: we reference data in the array by ``the fifth element in
array a''. Let's see how they're declared and used.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Example of declaration of array},
label={lst:arrayDeclaration}]
#include <stdio.h>
int main(void)
{
    int list_of_numbers[10];
}
\end{lstlisting}
\end{minipage}

In the example we have declared and array with ten position of type
\texttt{int}. And here there is the first important thing: the elements in an
array do not start from one, but from zero. That means that an array like this
one with ten positions hasn't got a position number ten, but positions from
zero to nine.
To access any element in an array we must write the name of it and, between
square braces (\verb![]!), the position we want to access. Inside the braces
there may be any expresion with an integer value, variables included, which
is the most common.


\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Example of ussage of an array},
label={lst:arrayUse}]
#include <stdio.h>
int main(void)
{
    int list_of_numbers[10];
    list_of_numbers[0] = 30;
    int a = list_of_numbers[0];

}
\end{lstlisting}
\end{minipage}

In this program we are declaring the array, assigning a value to the first
possition and then using that value to assignt hat possition to another
variable, the values of the first position of the array and the variable
are not linked. If you remember what I said in the last section, we will
use a lot of \texttt{for} loops alongside arrays.


\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Example of how to use an array},
label={lst:arrayIteration}]
#include <stdio.h>
int main(void)
{
    int list_of_numbers[10];
    for (int ii = 0; ii < 10; ++ii) {
        list_of_numbers[ii] = ii;
    }
}
\end{lstlisting}
\end{minipage}

We must make several considerations, the variable you have declared in a
\texttt{for} loop when you access an array tend to be called \texttt{i}.
It is just a personal habit of mine to call it \texttt{ii}, you can do it as
you wish, but if you want other programmers to read your code easily, I would
encourage you to use any of those two alternatives; secondly: look carefully
the loop, \texttt{ii} takes values from 0 to 9, which are the positions of
the array, and it assigns to them the values of the variable we are using
to access the array, so we wad number in it values 0, 1... to 9.

% Pero los arrays pueden tener más de una dimensión, es decir, si ahora tenemos
% arrays de datos, podemos tener matrices, o cubos, o incluso
% estructuras de dimensiones ilimitadas. En general, el ser humano tiene
% dificultad manejando más de dos o tres dimensiones, así que te pondré el ejemplo
% de cómo usar un array de dos dimensiones.

But arrays can have more than one dimension, that is, if we now have arrays of
data. we can have matrixes, or cubes, or even structures of unlimited
dimensions. In general, human beings have problems managing more than two or
three dimensions, so I will show you an example on how to use a bi-dimensional
array.


\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Ejemplo de uso de array bidimensional},
label={lst:bidimensionalArray}]
#include <stdio.h>
int main(void)
{
    int matrix[5][10];
    for (int i = 0; i < 5; ++i) {
        for (int j = 0; j < 10; ++j) {
            matrix[i][j] = 1 + (i * 5 + j);
        }
    }
    for (int i = 0; i < 5; ++i) {
        for (int j = 0; j < 10; ++j) {
            printf("%2d ", matrix[i][j]);
        }
        printf("\n");
    }
}
\end{lstlisting}
\end{minipage}

The first dimension of the array, in this case 5, says to you how many rows
it will have, the second, the columns. You can think of array with two
dimensions as an ``array of arrays''. This is expandable to all the dimensions,
as we said before. You must be careful, if you try to access to an position of
the array that does not exist it is very probable that your program ends
abruptly. If you use nested loops with arrays of several dimensions, the
custom is that the variables that go in the inner loops after \texttt{i} are
called with the next letters (j, k...). This is a mathematical reminiscence,
where big operator like summations or products of series use indexes with
these letters.

\subsection{The struct}
In C a struct is a ``pack'' of data from different type that has a name. It
would be like groupping a series of variables and refer to them as a set.
Which advantage has this got? We can create new types sticking together the
basic ones. If you think about that, it's something very natural, a struct
allows us to use the basic construction blocks of the language, basic types,
and create new concepts with them. In general, we want all the parts of our code
to be able to see these new types, so we will declare them outside all code
blocks, in tye same way I told you a global variable is declared.

% Cuando creamos una variable de este tipo, estamos \textbf{instanciando} un
% \textit{struct}. En informática instanciar es crear una variable de un tipo
% determinado. Por ejemplo, podríamos haber dicho <<instancias un entero>>, pero
% se suele aplicar a tipos compuestos, no básicos. Así que primero debemos crear
% el tipo y después variables de ese tipo.

When we create a variable of this new type, we are \textbf{instantiating} a
struct. In computer science instantiate is creating a variable of a given type.
We could say ``instantiating an integer'' but it is only applied to composed
types, not basic ones. So, firstly we must create our new type and then
variables of said type.

Now I present you the syntax to declare a struct, to create a variable
of that type and use it.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Declaration, instantiation and use of a \textit{struct}},
label={lst:structUse}]
#include <stdio.h>
struct my_struct {
    int field1;
    char field2;
    double field3;
};

int main(void)
{
    struct my_struct my_variable;

    my_variable.field1 = 100;
    my_variable.field2 = 'b';
    my_variable.field3 = 3.3;
}
\end{lstlisting}
\end{minipage}

The data that are inside a struct are called \textbf{fields}, and they are
accessed with a dot. If you're thinking that makes the point an operator,
you're right, dot is an operator that accesses to the fields in an struct.
Notice that to declare a variables of the new struct type you need to
put the keyword \lstinline[style=C]"struct" before, not only the name you gave
to it.

Let's see an example of an use case of this. Imagine we want to make a program
that calculates the distance between two points, we could do it this way:

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Example of calculation of distance between points in a plane},
label={lst:pointNoStruct}]
#include <stdio.h>
#include <math.h>
int main(void)
{
    double point1_x = 1.1;
    double point1_y = 3.2;
    double point2_x = 2.3;
    double point2_y = 5.4;

    double diff_x = point1_x - point2_x;
    double diff_y = point1_y - point2_y;
    double distance = sqrt(diff_x*diff_x + diff_y*diff_y);

    printf("P1 : [%f, %f]\n", point1_x, point1_y);
    printf("P2 : [%f, %f]\n", point2_x, point2_y);
    printf("Distance: %f\n", distance);
}
\end{lstlisting}
\end{minipage}

As you can see, the program works and does what it is suppossed to do... but
it is quite confusing, the only thing that ``joins'' together the coordinates
of any point is the name of the variable, also, you need to declare many
variables . I think you can see that the very moment we start managing many
points in a program, this could be something very difficult to understand.
Let's see what would come out of using our new knowledge of the structures.


\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Calculating the distance between two points using structures},
label={lst:pointStruct}]
#include <stdio.h>
#include <math.h>

struct point_s {
    double x;
    double y;
};

int main(void)
{
    struct point_s A;
    struct point_s B;

    A.x = 1.1;
    A.y = 3.2;
    B.x = 2.3;
    B.y = 5.4;

    double diff_x = A.x - B.x;
    double diff_y = A.y - B.y;
    double distance = sqrt(diff_x * diff_x + diff_y * diff_y);

    printf("P1 : [%f, %f]\n", A.x, A.y);
    printf("P1 : [%f, %f]\n", B.x, B.y);
    printf("Distance: %f\n", distance);
}
\end{lstlisting}
\end{minipage}

As you can see, the program is much more cleaner. Also, I do not have to rely in
the name of the varuables to signify that something is a point, but I can
rely in the tools the language offers me.

Note: These two programs use a library (we will speak about them later on)
and need to be compile with an special option, simply add \texttt{-lm} to the
line you have been using to compile until now, it would end like:
``\texttt{gcc -o main.elf main.c -lm}'' (without the quotes).


\subsection{Initialization lists}
Both array an structures have a way to initialize them in a concise way. If you
remember the chaper about variables, initializing a variables is give it
value for the first time. This way of doing so to arrays an structs is the
initialization list. Let's see an example.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Initializing with braces},
label={lst:initializationLists}]
#include <stdio.h>
struct point_s {
    double x;
    double y;
};
int main(void)
{
    struct point_s punto1 = {1.1, 2.3};
    int my_array[10] = {1,2,3,4,5,6,7,8,9,10};
}
\end{lstlisting}
\end{minipage}

In the case of the struct, the members are initialized in the order we declared
when creating the new struct type. So in the example the x coordinate will be
1.1 and the second 2.3. In the case of the array we have filled all the
positions, if we put only some, they will be initialized to zero. Be careful,
because the initializers with braces are good only to initialize, if we added to
the program a line such as: \lstinline[style=C]!punto1 = {2.2, 4.6}! the
compiler wouldn't let you compile. The same would happen with the array. With
the struct we can do something, initialize only the fields we want, omitting
some, etc. This is done with a little confusing syntax. Let's use an example
with an struct that stores a date. One of its variables is logic, tells if it
is a leap year. It's something we can calculate, but it is not unusual to
store data calculated of an struct on itself so you don't have to do it
all the time.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Initializing a struct with braces and field selection},
label={lst:dateStruct}]
#include <stdio.h>
struct date_s {
    int isLapYear;
    char day;
    char month;
    short year;
};
int main(void)
{
    struct date_s moonLanding = {.month=7, .year=1969, .day = 20};
    moonLanding.isLapYear = moonLanding.year % 4 == 0;
}
\end{lstlisting}
\end{minipage}

% Como puedes ver, primero hemos inicializado los campos que queríamos y después
% hemos calculado lo que nos interesaba con ellos. Nota, además, que como hemos
% indicado en el inicializador el campo al que corresponde cada valor, ni siquiera
% hemos de preocuparnos del orden.
% (La regla para saber si un año
% es bisiesto es más compleja, pero esto es sólo un ejemplo).

As you can see, firstly we hace initialized the fields we wanted and later we
calculated what we wanted. Since we have said whose fields we wanted to assign
values to in the initialization list, we didn't even have to worry about the
order. As we saw before the rule to know if a year is a leap year is more
complex but this is just an example.


% Quiero añadir como colorario final que es posible (y común) declarar arrays de
% \textit{structs} y estructuras con arrays como miembros. Ejemplo:

I want to add as a conclusion that it is posible (and common) to declare arrays
of struct and have struct that have arrays as fields. For example.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Combinación \textit{struct} con array},
label={lst:exampleArrayStruct}]
#include <stdio.h>
struct point_s {
    double x;
    double y;
};
struct triangle_s{
    struct point_s points[3];
};
int main(void)
{
    struct point_s points[2] = {{1.1, 2.3}, {4.5, 6.6}};
    struct triangle_s triangly = {{{1.1, 2.2},{3.3, 4.4}, {5.5, 6.6}}};
    triangly.points[0].x = 1.6;
    triangly.points[0].y = 3.4;
}
\end{lstlisting}
\end{minipage}

Pay attention to the initialization list in line 12, in it the most external
braces indicate that we are initializing the struct \texttt{triangly}, after it,
there is another level of braces because we're initializing the member points,
which is an array and, finally, for each element of that array we use an
initialization list for each point. A clearer but longer would be:

\noindent
\begin{minipage}[H]{\linewidth}
\begin{lstlisting}[style=C]
struct triangle_s triangly = { .points = {{.x = 1.1, .y = 2.2},
                                          {.x = 3.3, .y = 4.4},
                                          {.x = 5.5, .y = 6.6}} };
\end{lstlisting}
\end{minipage}

I have to warn you about one thing, when you initialize an array with an
initialization list you cannot define its size with a variable, that is:
you must do it with a literal value. This has a very clear reason: if you
initialize an array with a variable as dimension, for example:
\verb!int array[var] = {1,2};!, the list will indicate that the array is, at
least two positions long, but the compiler does not know how much var will be.
If it's two or more, it is ok, but if it's less, what would the compiler do?
Make an array of that length indicated by \verb"var" and drop values from the
list or ignore \verb!var! and use the elements on the list? Mind you that
the compiler cannot predict the value of a variable until the program is
executed. You may think that in simple programs it may do it, and yes, it could,
but even then, it would be very chaotic to have a rule about how to create
arrays that applies only in certain conditions that are not clear. So, keep this
in mind, if you want an array with a concrete size, determined by a variable,
do not initialize it with an initialization list. In any case, the compiler
would tell you that it's wrong.


\subsection{Exercises of the section}
Now you already have significant knowledge I will propose some exercises to you
to check you understood the concepts presented so far.
\begin{exercises}
\item Write a program that declared a struct that defined a circle in two
dimensions (center and radious). Make a program that declares a variable of
that type and calculates its area.
\item Write a program that, using the struct point presented in the example,
declares an initializes an array of them and prints the directions you must
follow from a point to the next, for example, if the points were:
$(1, 2), (3, 4), (2,5), (2, 1)$ this will be printed:
\begin{verbatim}
Right, Up
Left, Up
Still, Down
\end{verbatim}

\item Make a program that declares a bidimensional array and prints the
sum of its rows and columns in this way:

\begin{verbatim}
1 2 3 = 6
1 4 2 = 7
5 3 4 = 12
-----
7 9 9

\end{verbatim}

If you put numbers with a different length the columns will be
misaligned, you haven't got to worry about this.

\item Write a program that does the following for the number from one to 100,
both included: if the number is divisible between two, you must print ``fizz'',
if it is divisible by five, ``buzz'', and if its divisible between the two:
``fizzbuzz'', it shall not print anything otherwise.
I leave here an example with the first ten numbers.
\begin{verbatim}
fizz
fizz
buzz
fizz
fizz
fizzbuzz
\end{verbatim}
\end{exercises}

\section{Functions}
\label{funciones}
We are arriving to one of the most important parts of the manual. As you have
have read in the title of the section, we are going to talk about functions.
In programming, a function is almost a direct translation of what a function
is in mathematics. Let's start there, in mathematics a function is an object
that receives a series of arguments from certian domains and gives a result
that is in some codomain. In other words, it receives a set of mathematical
objects each from a type (numbers, vectors, matrixes...) and gives you a result
of some type of mathematical things.
$$
f(x) : \mathbb{R} \longrightarrow \mathbb{R}_{\ge 0}
$$
$$
x \to x^2
$$

That thing up there is basically a very formal way of writting $f(x) = x^2$
and $x$ is a real number. We have defined the domain (the real numbers) and the
codomain (the \textbf{possitive} real numbers) and the transformation you need
to make to the arguments to get the result. A function in C is the same, it is
a piece of code that receives a series of arguments and ``returns'' a result.
I am going to explain it in yet another way: a function is like a ``black box''
that receives ingredients and gives us a result, without the need to know what
is inside.

% Después de esta introducción, veamos cómo se declara, define y usa una función
% en C. La declaración de una función es como sigue:
% \begin{enumerate}
% \item Tipo de retorno de la función, es decir, el codominio, el tipo de dato
% que la función nos va a devolver. Por ejemplo, \lstinline[style=C]{double}.
% \item Nombre de la función, al igual que las variables, las funciones han de
% tener nombre. Por ejemplo, \verb!power!.
% \item Paréntesis de apertura.
% \item Lista de argumentos con su tipo separados por comas. Por ejemplo: dos
% enteros llamados \verb!base! y \verb!power!.
% \item Cierre de paréntesis.
% \item Como siempre, final de la línea punto y coma.
% \end{enumerate}

After that introduction, let's see how they are declared, defined and used.
The declaration is writen as it follows:
\begin{enumerate}
\item Data type of return of the function, that is, the codomain, el data type
the function is going to give us. For example, \lstinline[style=C]{double}.
\item Name of the function, in the same fashion than variables, functions have
to have a name. For example: \verb!power!
\item Opening parenthesis (\texttt{(})
\item List of parameters (arguments) of the function, with their type, separated
by a comma each one. In this case as example, two integers: \verb!base! and
\verb!exponent!.
\item Closing parenthesis (\texttt{(})
\item As always, end the line with semicolon.
\end{enumerate}

Following the examples we set before, it would be like:

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C, label={lst:functionDeclaration},
caption={Function declaration in C}]
double power(int base, int power);
\end{lstlisting}
\end{minipage}

But this function cannot be used, because we haven't defined it. Define a
function is in a way like initializing a variable. And it is saying
\textbf{what the functions actually does}. To do that, we copy the definition of
the function (without the semicolon) and we write a block of code. Which would
look like this:

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C, label={lst:functionDefinition},
caption={Definition of a function in C}]
double power(int base, int exponent)
{
    //Here you would put instructions
}
\end{lstlisting}
\end{minipage}

If you have been attentive, you may have seen a similarity between that last
fragment of code and the first program we wrote. This is not by chance, when
you wrote \verb!int main(void)!... what you were doing was \textbf{declare and
define} a function called \verb!main!. What you may be wondering now is why.
This is because in the Linux operating system and in most operating systems
the way programs start is by the operating system calling their \texttt!main!
function. That is why I had to make you write all those lines without telling
you what they were. Finally, the ``shape'' of a function (return type and
type of arguments) is called signature of a function.

Let's come back to the function \verb!power!, now we have ready to be written,
we can define its behaviour. In a function, the block of code that goes after
the argument list is called \textbf{body}. Inside the body the arguments can
be used as local variables. With this you can calculate the value you want the
function to \textbf{return} and make C do so with the
\lstinline[style=C]{return} (makes sense, doesn't it?). When you use this word,
the function ends executing (you go out of it). Let's see how we can implement
the function of the example that, if you didn't guess it by the name, calculates
the power \verb!base! to \verb!exponent!. It would end up like this:


\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C, label={lst:functionExample},
caption={Example of a function in C}]
double power(int base, int exponent)
{
    double res = 1;
    int ii = 0;
    while (ii != exponent) {
        if (exponent < 0) {
            res /= base;
            ii--;
        }
        else {
            res *= base;
            ii++;
        }
    }
    return res;
}
\end{lstlisting}
\end{minipage}

The function does this: declares a variable called \verb!res! which will be were
we will save the power we calculate. After that, we will use a \verb!while!
loop to multiply of divide (according to if the exponent is possitive or
negative) as many times as it's needed. At the end, we will return the result.

All right, now we have defined the function let's see how you use it. To use
a function you will ``invoke'' it. To do so we will simply write its name and the
arguments it needs. Let's see an example, if before in our program we we have
defined the function, this fragment of code will print several powers. If you
think about this, using a function in a programming language is like writting
the concrete value of a function in mathematics, if $f(x) = x^2$ then you
know writting $f(3)$ is the name as writting a nine.


\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C, label={lst:functionInvocation},
caption={Invocación de función en C}]
#include <stdio.h>
// Paste here definition of power
int main(void)
{
    double powers[3];
    powers[0] = power(2, 10);
    powers[1] = power(2, 0);
    powers[2] = power(10, -3);
    for(int ii = 0; ii < 3; ++ii){
        printf("%f\n", powers[ii]);
    }
}
\end{lstlisting}
\end{minipage}

As you can see, the values returned by functions are used as those returned by
operators, you can save them in arrays or assign them to variables. And, now
we're here, let's expalin another thing, as you may have already guessed,
\verb!printf! is a function. What is particular about it is that it's an special
function, its first argument (the format) is a pointer, which a new type I
haven't explained to you before. At this level, all the functions we write will
have a fixed number of arguments, which is the more common thing.

And, lastly, the keyword \lstinline[style=C]{void}. Void means and empty space.
This is the word we use when we want to indicate that a function doesn't need
any argument, for example, \verb!main!, or that it does not return any value.
One second, what is a function that doesn't return anything good for? Well,
while functions in C are very much like mathematical functions, they're not
exactly the same, because functions in C can manipulate other thing the are not
their arguments, the global variables. The most common example is \verb!printf!,
that does a thing which is not returning anything, but manipulate the terminal,
which is symbolized as a global variable of a concrete type. I told you when I
mentioned them that they weren't useful for us ``yet''. When you have several
functions, sometimes you need to use global variables because they will be
available in all the functions, but, as I told you, it is not the best thing to
do.

Finally, one precission: I have said to you that inside the body of the function
the arguments behave like local variables, and that may have led you to this
question: if you change the value of any argument, is that variable changed
outside the function? No, the arguments of a function are \textbf{copies} of
those that were given to them when invoking it. Let's see it with an example:

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C, label={lst:functionByValue},
caption={Demostración de que una función recibe copias de sus argumentos}]
#include <stdio.h>

void doble(int a){
    a = a * 2;
}
int main(void)
{
    int number = 3;
    printf("%d\n", number);
    doble(number);
    printf("%d\n", number);
}
\end{lstlisting}
\end{minipage}

If you compile and execute this you'd see that both times the program prints
a three. This is because, as I said, the arguments are copies of the ones
you passed them.

\subsection{Separation between declaration and definition}
% Te he explicado cómo declarar y cómo definir una función por separado, pero
% en los ejemplos siempre he incluido únicamente la definición. Esto es porque en
% la definición incluimos la declaración. Hay dos motivos por los que puedes
% separar ambas cosas, el primero es que quieras separar tu código en varios
% archivos, cosa que te explicaré más adelante, pero el segundo es que necesites
% definir todas las funciones porque se usan unas a otras, veamos un ejemplo
% de dos funciones, cuyo objetivo es imprimir siempre <<Temporada de patos>> y
% <<Temporada de conejos>>, dependiendo de a cuál llames primero, el orden será
% uno u otro. El código sería el siguiente:

I have already explained to you how to declare and define a function
separatedly, but in all the example I have always included only the definition.
This is because in the definition we include the declaration. There are to
reasons to do both things separatedly, the first one is that you want to
separate your code in several files, thing we will do later on, but the second
is that you need to define all the functions because they use each other, let's
see and example of two functions, whose target is to print always
``Duck season'', and ``Rabbit season'', depending on which was called first,
the order will be one or the other. The code would be something like this:


\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C, label={lst:cyclicFunctions},
caption={Declaration not separated from definition}]
#include <stdio.h>

void ducks(void){
    printf("Duck season!\n");
    rabbits();
}

void rabbits(void){
    printf("Rabbit season!\n");
    ducks();
}

int main(void)
{
    ducks();
}
\end{lstlisting}
\end{minipage}

But if you try to compile this, the compiler will say that the function
\verb!rabbits! is not declared when you use it inside the function \verb!ducks!,
and, as you can see, it is not, because it is defined below that point. The
program, nevertheless, works, but it is not, again, sensible, using functions
without defining them before.
How could we solve this? Putting the declaration of both functions
\textbf{before} of their definitions. That is:


\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C, label={lst:cyclicFunctions},
caption={Declaration separated of definition}]
#include <stdio.h>

void ducks(void);
void rabbits(void);

void ducks(void){
    printf("Duck season!\n");
    rabbits();
}

void rabbits(void){
    printf("Rabbit season!\n");
    ducks();
}

int main(void)
{
    ducks();
}
\end{lstlisting}
\end{minipage}

If you execute this, your program will be executing forever, so hit control key
and C at the same time to end it.

\subsection{The functions and the arrays}
The arrays are a special question when they're mixed with functions for two
reasons: when you pass an array as an argument to a function, \textbf{you can
modify the contents of it}. This is because arrays that are passed to a function
turn into \textbf{pointers}. As you can see, I have mentioned them several
times. They're one of the most central elements of the language and where its
power is, hence I will explain them later on, but its presence is felt
in an invisible way all we are learning up until now, as you will see when we
reach that point. At the moment, just remember that when an array is an argument
of a function, you can modify its elements. Let's see an example of two
functions, one modifies the elements of an array passed ar argument and the
other does not.


\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C, label={lst:arraysAndFunctions},
caption={Array use with functions}]
#include <stdio.h>

void print_array(int array[], int array_size) {
    for(int ii = 0; ii < array_size; ++ii){
        printf("%d ", array[ii]);
    }
    printf("\n");
}

void add_one_to_each(int array[], int array_size){
    for(int ii = 0; ii < array_size; ++ii){
        array[ii]++;
    }
}

int main(void)
{
    int my_array[] = {1,2,3,4,5,6,7,8};
    print_array(my_array, 8);
    add_one_to_each(my_array, 8);
    print_array(my_array, 8);
}
\end{lstlisting}
\end{minipage}

As you can see, if you execute this, you would print first the original array
and later the array with its elements incremented in one. This shows you that
elements in an array can be modified by functions. May be you wonder if you can
modify structures. \textbf{No}, you cannot modify struct fields when you pass
them as arguments. I also want you to see that when you pass an array to a
function in the list of arguments you must write: \verb!type name[]!, for
example in both functions shown before: \verb!int array[]!. Also, a function
\textbf{cannot return an array}, this is for reasons I will explain when we go
deeply into topics of pointers. Finally, functions cannot receive bisimensional
pointer, for similar reasons.


\subsection{Exercises of the section}
% En esta sección te pediré que escribas varias funciones, cabe mencionar que
% aunque no se pide, es recomendable, para comprobar que lo has hecho bien, que
% \textbf{pruebes} estas funciones llamándolas en tu función \verb!main! con
% valores  imprimiendo los resultados si fuera necesario.
In this section I will ask you to write several functions, needed to say that,
even when it is not asked for in every exercise, you should check
you have done it right, \textbf{testing} the functions calling them in your
function \verb!main! with values printing the results.

\begin{exercises}[resume*]
\item Write a functions that tells if a number is prime or composed. Note: a
number is prime only if it is divisible only by itself and the unit (1). One
itself is not composed nor prime.

\item Write a function that calculates the distance between two point structures
in the last section. To calculate the square root of a number you must use
the function \verb!sqrt!, to be able to use it you should include at the
begining of your program (just right under the line that says:
\verb!#include zstdio.h>!) the line \verb!#include <math.h>! and all \verb!-lm!
to the command to compile the programs, that would be:
\verb!gcc -o main.elf main.c -lm!
\item Write a function that receives an array of integers and a separator char
that will print the elements in the array separated by that char, for example,
to the array \verb!{1,2,3,4}! and the char \verb!'\n'!, it will print:

\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{verbatim}
1
2
3
4
\end{verbatim}
\end{minipage}

\item Write a function that encapsulates the program
\ref{lst:linealSystemFinal}: \nameref{lst:linealSystemFinal}. The function must
receive the coefficients if the equations ($a$, $b$, $c$, $d$, $e$ y $f$). It
can receive them separatedly of in an array. To return the result you can create
a struct that has two \verb"doubles".
\item Write a function that normalizes the elements of an array of
\verb!double!. Normalize is express all the elements in terms of the unit,
so to normalize it you must divide all elements by the biggest element
\end{exercises}

\section{The Memory}
This is one of the most important sections of the manual. Even when this is a
manual about C programming, it is very difficult, if not impossible, to program
in C in a sophisticated way without understanding, at least partially, the
memory of a computer. Up until now I have said that the variables that you
declare, both of basic types and arrays or structs are stores in ``memory'',
but, what is exactly a computers memory? Well, let's start from the most
evident thing, how does it look?
\begin{figure}[H]
    \includegraphics[width=\linewidth]{ram}
    \caption{RAM memory module}
    \label{img:ram}
\end{figure}

Here you can see a module of memory of a computer. This module is a circuit
board soldered to it. The chips are the black rentangles. In them it is stored
the information in binaty code. A memory is a system from which you ask fro a
portion of information and it deposits the value in a set of ``cables'' that
are in the computer, from which the values travel to the CPU, the processor,
the memory is \textbf{addressed}. This means that each portion of the memory
is referenced by a number.

% Utilizando una analogía, imagina que la memoria
% fuera un cuaderno con una cuadrícula, en cada cuadrado digamos que cabe una
% cifra o una letra, para poder rellenar o leer el cuaderno, lo que haremos
% es numerar las cuadrículas. Empezaremos con la cuadrícula cero, después la uno,
% y así sucesivamente.

Using an analogy, imagine that the memory is a notebook with a grid, in each
cell you can store a figure or a letter, to be able to fill or read the
cell, what we will do is assign a number to each one a number. We will start
with the number zero and after that the one, two...


\begin{table}[H]
    \centering
    \begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|}
        \hline
f&a&3&7&J&n&c&C&H&r&y&D&s&b&z\\\hline
a&y&y&4&c&B&W&D&x&S&2&2&J&j&z\\\hline
h&M&a&i&R&r&V&4&1&m&t&z&x&l&Y\\\hline
v&K&W&r&O&7&2&t&K&0&L&K&0&e&1\\\hline
z&L&O&Z&2&n&O&X&p&P&I&h&M&F&S\\\hline
v&8&k&P&0&7&U&2&0&o&0&J&9&0&x\\\hline
A&0&G&W&X&I&I&w&o&7&J&4&o&g&H\\\hline
F&Z&Q&x&w&Q&2&R&Q&0&D&R&J&K&R\\\hline
E&T&P&V&z&x&l&F&r&X&L&8&b&7&m\\\hline
t&K&L&H&I&G&h&I&h&5&J&u&W&c&F\\\hline
    \end{tabular}
    \caption{Example of a grid with values}
    \label{tab:notebookSimulation}
\end{table}

In the table you can see an emulation of this notebook, imagine that I tell
you ``tell me what is in the cell number 24''. Keeping in mind that it is
a table of 15 columns and that \textbf{we start counting from zero}, you'd have
to say ``S'', because the \textbf{address} 24 is the nineth position of the
second row. In general, computer memories are \textbf{addressed by bytes}, this
means that for each byte there is a number (an address). You may have noted that
it is absurd to draw this in a table if we are assigning simply numbers, this
should be a continous list, a table of a single columns. If you have thought
that, you're right, because that's how memory is usually represented.

% En resumen: la memoria de los ordenadores es una sucesión continua de bytes
% numerados desde el 0 en adelante, a los que podemos referenciar por ese número
% tanto para leer como para escribir en ellos.

To sum it up: the memory in computers is a continous succession of bytes
numerated from zero and on, to which we can reference by that number
both to read and write.

\subsection{Positional numerical systems: decimal, binary, hexadecimal}
\label{numericSystems}
% Como ya dijimos en la introducción, el ordenador sólo entiende código binario,
% y esto es aplicable tanto a las direcciones de la memoria como a su contenido.
% Debido a esto, me veo compelido, pues, a
% darte una pequeña clase sobre cómo funciona el código binario. El código binario
% es un sistema numérico posicional. Un sistema posicional es aquél en que los
% números se componen de cifras, cada una de las cuales tiene un valor dependiendo
% de su \textbf{posición} dentro del número. Cuanto más a la izquierda están las
% cifras en un número, más valen. Recuerda cuando aprendiste cómo funcionaban los
% números: había unidades, decenas, centenas, millares... y así sucesivamente,
% el sistema que usamos es posicional, y es decimal, porque tenemos 10 cifras para
% representar números, desde el 0 al 9. Pues en binario funciona igual, pero sólo
% disponemos de dos cifras.

As we said in the introduction, the computer only understands binary code,
and this is applicable both to the addresses of the memory and its contents.
Due to this, I am compelled to teach you how the binary code works. The binary
code is a positional numerical system. In a positional system numbers are
composed by figures, each one of those figures has a value depending on which
\textbf{position} they occupy in the number. The more to the left they are in
the number, the more they add to it. Remember when we learnt how numbers work,
you had units, tens, hundreds, thousands... and so on and so forth. The system
we use to write numebrs is, therefore, positional, and decimal, because we have
ten figures (from zero to nine). In binary it's the same, but with only two
figures.

% Un sistema numérico posicional
% funciona de este modo: si la base numérica es $n$, cada cifra de un número vale
% el valor de la misma cifra multiplicado por $n$ elevado al número de posiciones
% que queden a la derecha del número. Como siempre, veámoslo con un ejemplo: si
% escribimos el número 34.789, el cálculo que usamos para saber cuánto vale es
% el siguiente:
% (Recuerda que un número elevado a 0 es 1)
% $$
% 3\cdot10^4+4\cdot10^3+7\cdot10^2+8\cdot10^1+9\cdot10^0
% $$
% $$
% 3\cdot10000+4\cdot1000+7\cdot100+8\cdot10+9\cdot1
% $$

A positional numerical system works in this way: if the numeric base (number of
different figures available, in the case of our system, 10) is $n$, each figure
adds to the number the value of the figure multiplied by $n$ to the power of
how many figures are left to the right of this one. As always, let's see it with
and example: is we write the number 34,789, the calculation we perform to
know how much it adds up is this one (remember that any number that is not zero
powered to the zero power is one):
$$
3\cdot10^4+4\cdot10^3+7\cdot10^2+8\cdot10^1+9\cdot10^0
$$
$$
3\cdot10000+4\cdot1000+7\cdot100+8\cdot10+9\cdot1
$$

Again, we can express it like tens, hundreds, unit... which are the names
we have to those concrete powers of ten.

So, if you had a binary number, you'd make the same calculation, but instead of
unit, tens, hundreds and thousands, etc. you'd have to use units, couples,
quartets, octets and groups of 16 (there is no word for that). Given the binary
number 1110101, the calculation would be:
$$
1\cdot2^6+ 1\cdot2^5+1\cdot2^4+0\cdot2^3+1\cdot2^2+0\cdot2^1+1\cdot2^0
$$
$$
1\cdot64+ 1\cdot32+1\cdot16+0\cdot8+1\cdot4+0\cdot2+1\cdot1=117
$$

Now you already know how to read a binary numbers, you need to see how a decimal
numbers is converted to binary. To do so, you do the following:
\begin{enumerate}
\item Divide the number by two, calculating the residue.
\item If the division leaves no residue, you write a zero on the left side of
the resulting number, if it has residue (it can only be one), you write one.
\item Repeat until the \textbf{result} of the division is zero.
\end{enumerate}

Let's see an example of this, given the number 253, if you apply the procedure,
you should have something like the operations below. If you note the results of
the divisions in the direction of the arrow in the bottom of the diagram you
could compose finally the binary number: 11111101.


$$
\matrix{
253                   &\division{2}                 &&&&&& \cr
\padding5\padding     &126                          &\division{2}                 &                      &                      &                             &                             &                             &                 \cr
\padding\underline{13}&\padding0\padding            &\padding63                   &\division{2}          &                      &                             &                             &                             &                 \cr
\padding\padding1     &\padding\padding\underline{6}&\padding0\padding            &\padding31            &\division{2}          &                             &                             &                             &                 \cr
                      &\padding\padding0            &\padding\padding\underline{3}&\padding1\padding     &\padding\underline{15}&\division{2}                 &                             &                             &                 \cr
                      &                             &\padding\padding 1           &\padding\underline{11}&\padding\padding1     &\padding\padding\underline{7}&\division{2}                 &                             &                 \cr
                      &                             &                             &\padding\padding1     &                      &\padding\padding1            &\padding\padding\underline{3}&\division{2}                 &                 \cr
                      &                             &                             &                      &                      &                             & \padding\padding1           &\padding\padding\underline{1}&\division{2}     \cr
                      &                             &                             &                      &                      &                             &                             & \padding\padding1           &\padding\padding0\cr
\padding\padding1     &\padding\padding0            &\padding\padding 1           &\padding\padding1     &\padding\padding1     &\padding\padding1            & \padding\padding1           & \padding\padding1           &                 \cr
}
$$
$$
\overleftarrow{\hphantom{\matrix{
		253                   &\division{2}                 &&&&&& \cr
		\padding5\padding     &126                          &\division{2}                 &                      &                      &                             &                             &                             &                 \cr
		\padding\underline{13}&\padding0\padding            &\padding63                   &\division{2}          &                      &                             &                             &                             &                 \cr
		\padding\padding1     &\padding\padding\underline{6}&\padding0\padding            &\padding31            &\division{2}          &                             &                             &                             &                 \cr
		&\padding\padding0            &\padding\padding\underline{3}&\padding1\padding     &\padding\underline{15}&\division{2}                 &                             &                             &                 \cr
		&                             &\padding\padding 1           &\padding\underline{11}&\padding\padding1     &\padding\padding\underline{7}&\division{2}                 &                             &                 \cr
		&                             &                             &\padding\padding1     &                      &\padding\padding1            &\padding\padding\underline{3}&\division{2}                 &                 \cr
		&                             &                             &                      &                      &                             & \padding\padding1           &\padding\padding\underline{1}&\division{2}     \cr
		&                             &                             &                      &                      &                             &                             & \padding\padding1           &\padding\padding0\cr
}}}
$$

If you are an user of computers, you may have heard sentences like
``this computer has a 32 bit computer'' or ``this computer is compatible with
64 bit software''. That numbers of bits is the size of, between other things,
the memory addresses. A computer of 32 bits has 32 bit memory addresses, hence
it can address 2\textsuperscript{32} bytes. Newadays most computers are 64 bit,
so most of them can address 2\textsuperscript{64} bytes of information
theoretically. Of course, a computer will be always limited by the actual amount
of memory it has which in normal computers is usually of a handful of gigabytes.


% El problema es que 64 cifras binarias con muchas para leerse de manera
% sencilla, mira este número binario:
% 1101001001010101001010100101101010101010101110100100111010010101. Es muy
% largo. Por ello, cuando se expresan direcciones de memoria se utiliza otro
% sistema numérico (soy consciente de que esto es un gran rodeo). Este sistema
% numérico es el \textbf{hexadecimal}. Es un sistema de base 16, con cifras del 0
% a la F. Sí, a la F, has leído bien. Como los números que usamos son de base 10,
% no tenemos símbolos para representar una cifra que valga 10, 11, 12... y así
% hasta 15, así que utilizamos letras del alfabeto latino. Por lo demás, funciona
% igual que el binario o el decimal. Un número hexadecimal se suele representar
% con <<0x>> delante para indicar que es ese tipo de número. Veamos un ejemplo,
% sea el número hexadecimal 0xF2A:

The problem is that 64 binary digits are too many to be read easily, look at
this binary numbers:
1101001001010101001010100101101010101010101110100100111010010101. It's too long.
Because of that, when memory addresses are writen, they are writen in a
different numerical system. This numerical system is the \textbf{hexadecimal}.
If a system with base 16, with figures from zero to F. Yes, to F, you have read it
right. Since numbers in our normal system have base 10, we haven't got symbols
to represent a figure that has value 10, 11, 12... up to 15, so we use letter of
the latin alphabet. Otherwise, it works in the same way than binary or
decimal. A hexadecimal numbers is usually written with ``0x'' infront of it
to tell the reader that what follows is a number in that base. Let's see an
example, given the hexadecimal number 0xF2A.
$$
\mathrm{0xF2A} = 15\cdot16^2 + 2\cdot16^1 + 10\cdot16^0 = 3882
$$

To turn a decimal number into hexadecimal you must follow these steps:
\begin{enumerate}
\item Convert the number to binary
\item Divide the number in groups of four bytes \textbf{begining on the right
side}.
\item Turn each one of the groups to decimal and write the corresponding
hexadecimal digit.
\end{enumerate}

Let's go back to the example of the number we converted to binary before, 253,
in binary it is 11111101, if we wanted to convert it to hexadecimal we would
need to divide it in groups of four: 1111~1101. the number 1111 is 15, so it'd
be F, and the number 1101 is a 13, so it would be D, therefore 253 would be
equal to 0xDF. If the leftmost group is not a 4 byte group, you must put zeroes
on the left side. By the way, to convert to hexadecimal, to binary, simply take
every hexadecimal digit and convert it to binary again but, remember, each digit
is a four byte binary number, so 0x33 would be 0011~0011. no 1111, that would
be a different number entirely. You're prepared to start learning how the memory
of a computer works.

\subsection{The memory map}
One of the most common way to represent the memory of a computer is with a
\textbf{memory map}, that is a drawing in the shape of a column in which the
contents of the memory are explained, indicating on the side the relevant
addresses. Look at the following figure:

\begin{figure}[H]
    \center
    \includegraphics[width=0.5\linewidth]{emptyMemoryMap}
    \caption{Mapa de memoria vacío}
    \label{img:emptyMemoryMap}
\end{figure}
In that figure we hace drawn the whole computer memory in a column, with
the lower addresses (near zero) in the top and the higher ones (closes to
0xFF...) in the bottom. Generally I like more this representation, but in
many sources and literature you'd see the map drawn in the other direction.

If your programs were the only software that executed in the computer, you'd
have the whole map available for you and you wouldn't have to do anything to
write on memory, simply... do it. But this is not the case, because your
programs are executed thanks to the operating system. The operating system has
many functionalities: it coordinates the processes that are executed in the
machine, manages file systems, allows the CPU to understand devices such as
keyboards and controllers... but one of its most basic functions is \textbf{
memory management}. The OS gives processes memory blocks on which these can
write or not, and \textbf{ensures} that they do not go out of their assigned
memory.

In the section in which I talked about array I told you that if you accessed to
a position of an array that didn't exist, your program would end abruptly, test
it. Make a program that declares an array of, for example, 10 positions and
afterwards writes something in position 2,500. You'd see how the program writes
a message like this one when executed:


\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=terminalStyle]
\$ ./main.exe
Segmentation fault (core dumped)
\end{lstlisting}
\end{minipage}

It is possible that it does not throw the message, due to how the computer
manages the memory internally. Anyway, for a C programmer, memory management
(and specially check that he does not write to or reads from memory blocks it
shouldn't) is one of the most important tasks, if not the most. In this task,
the operating system decieves our programs. To our program, you have an
available memory that is the whole map (the 2\textsuperscript{64} bytes), even
when the computer may have, for example, 8 GB which is several thousand times
less. By the way, in general terms, each level in the prefixes of multiplication
of 1,000 is not 1,000, but 2\textsuperscript{10}, 1,024, if we were exhaustive,
we should write GiB, MiB and so on, which is the correct way to indicate those
prefixes that multiply by 1,024. What the operating system does is to alocate
what we ask from him in the \textbf{physical} memory and gives us addresses of
that map of memory we think we have, and translates it. This process is the
\textbf{memory virtualization}, and is one of the most important features of an
operating system. Thanks to it, the programmer doesn't need to manage where the
memory is physically allocated.


En este mapa de memoria virtualizado, que es efectivamente el que vamos a usar,
el sistema operativo crea una serie de \textbf{regiones de memoria}, las cuales
están destinadas a alojar distintos tipos de información de cada programa
ejecutándose en un ordenador. A continuación te presento un mapa de memoria
con las regiones más importantes, y seguidamente te explicaré qué son y por qué
nos importan.
\begin{figure}[H]
    \center
    \includegraphics[width=0.5\linewidth]{regionsMemoryMap}
    \caption{Regiones del mapa de memoria de un proceso}
    \label{img:regionsMemoryMap}
\end{figure}

La región de código o texto es sencilla, es donde se almacenan las
instrucciones que tu programa va a ejecutar. Cuando te expliqué lo que era la
compilación te dije que convertiríamos nuestras instrucciones en un binario que
el ordenador podría ejecutar. Pues es en esta sección donde se almacena. Al
generar tu programa, esas instrucciones binarias se almacenan en el disco en
el ejecutable. Cuando el programa se ejecuta, éstas se cargan en memoria en
esta sección. Esta sección no se puede cambiar ni leer dentro del programa.

La siguiente empieza a ser interesante. Cuando escribes un literal en el código
éste debe almacenarse en algún sitio. Esta es la sección donde todos esos
números que escribes en el código se almacenan y se usan cuando son necesarios.
Aquí además se guardan los valores de las estructuras y arrays que inicialices
con \textbf{listas de inicialización}. En la siguiente sección se guardan las
variables, arrays, estructuras, etc. \textbf{globales} que no hayas
inicializado. ¿Por qué sólo las globales? Porque la función \verb!main! es una
función, y las variables que se declaran en las funciones
(o en cualquier bloque de código) no se guardan aquí, sino en la siguiente
sección: la pila.

Mira el mapa, esta sección está abajo (en las direcciones más altas), pero
te la voy a explicar ahora porque es una de las más importantes. En la pila
se guardan las variables que se declaran en bloques de código: funciones,
bucles, condicionales, etc. ¿Por qué? Porque de esta sección de memoria los
datos pueden salir y entrar, o mejor dicho, se puede reutilizar la memoria
de datos antiguos para escribir datos nuevos. Para explicarte cómo ocurre esto,
primero he de explicarte cómo funciona una pila.

Una pila es una estructura de datos, como los arrays o las estructuras, que
funciona de este modo: cuando introduces algo en una pila, este elemento se
queda arriba, y cuando sacas algo de la pila, sólo podrás sacar lo que esté
en la parte superior. Te voy a poner un ejemplo físico: una lata de las famosas
patatas Pringles\textsuperscript{®}. La única patata que puedes sacar es la
superior, si quieres sacar más, puedes, pero siempre en el orden inverso al que
fueron metidas en la lata. Pues con cualquier pila pasa lo mismo.
El modo en que esta pila se aplica a la programación en C es que,
cuando se entra en cualquier
\textbf{bloque de código}, las variables declaradas en él son \textbf{añadidas}
a la pila. Esto incluye los arrays y estructuras. Cuando se sale de ese bloque
de código, esas variables son \textbf{extraídas} de la pila, es decir,
se pierden porque se entiende que ya fueron usadas. Éste es el motivo por el
que las funciones \textbf{no pueden devolver arrays}. Porque esos arrays
dejan de existir cuando la función deja de ejecutarse.

Quizás te estés
preguntando por qué puedes declarar
variables de tipos básicos o estructuras en tus funciones y
devolverlos. Esto es porque, del mismo modo que los argumentos, el valor
devuelto se \textbf{copia}. El valor devuelto por una función se deja
en la cima de la pila para que se recoja en el punto en que \textbf{la función
fue llamada}. Ahí es donde tú lo copias a una variable, con el operador
de asignación. Con los arrays \textbf{no podemos usar el operador de
asignación}, no es como se copian arrays. De hecho el compilador lanzaría un
error si intentaras asignar un array a otro.


Veamos un ejemplo de cómo se ve la pila de un programa en el caso de ejecutar
alguno de los programas de ejemplo que hemos escrito. Vamos a utilizar el
programa \ref{lst:arraysAndFunctions}: \nameref{lst:arraysAndFunctions}.
En este ejemplo vas a ver que en la pila hay dos nombres (\verb!my_array! y
\verb!array!), pero recuerda que \textbf{apuntan al mismo array}. Sólo copian
la dirección donde el array empieza, no sus elementos.
\begin{table}[H]
\centering
    \begin{subfigure}{0.33333\linewidth}
        \centering
        \begin{tabularx}{.9\linewidth}{|Y|}
        \hline
        \textbf{La pila empieza vacía}\\\hline
         \\\hline
        \multicolumn{1}{c}{\color{white}CIERTOFALSO\normalcolor}\\ \arrayrulecolor{white}\hline
        \multicolumn{1}{c}{\color{white}CIERTOFALSO\normalcolor}\\ \arrayrulecolor{white}\hline
        \multicolumn{1}{c}{\color{white}CIERTOFALSO\normalcolor}\\ \arrayrulecolor{white}\hline
        \end{tabularx}
    \end{subfigure}%
    \begin{subfigure}{0.33333\linewidth}
        \centering
        \begin{tabularx}{.9\linewidth}{|Y|}
        \hline
        \textbf{Entramos en \texttt{main}}\\\hline
        my\_array\\\hline
        \multicolumn{1}{c}{\color{white}CIERTOFALSO\normalcolor}\\ \arrayrulecolor{white}\hline
        \multicolumn{1}{c}{\color{white}CIERTOFALSO\normalcolor}\\ \arrayrulecolor{white}\hline
        \multicolumn{1}{c}{\color{white}CIERTOFALSO\normalcolor}\\ \arrayrulecolor{white}\hline
        \end{tabularx}
    \end{subfigure}%
    \begin{subfigure}{0.33333\linewidth}
        \centering
        \begin{tabularx}{.9\linewidth}{|Y|}
        \hline
        \textbf{Entr. en \texttt{print\_array}}\\\hline
        array\\\hline
        array\_size\\\hline
        my\_array\\\hline
        \multicolumn{1}{c}{\color{white}CIERTOFALSO\normalcolor}\\ \arrayrulecolor{white}\hline
        \end{tabularx}
    \end{subfigure}%


    \begin{subfigure}{0.33333\linewidth}
        \centering
        \begin{tabularx}{.9\linewidth}{|Y|}
        \hline
        \textbf{Entr. en el \texttt{for}}\\\hline
        ii \\\hline
        array\\\hline
        array\_size\\\hline
        my\_array\\\hline
        \multicolumn{1}{c}{\color{white}CIERTOFALSO\normalcolor}\\ \arrayrulecolor{white}\hline
        \end{tabularx}
    \end{subfigure}%
    \begin{subfigure}{0.33333\linewidth}
        \centering
        \begin{tabularx}{.9\linewidth}{|Y|}
        \hline
        \textbf{Salimos del \texttt{for}}\\\hline
        array\\\hline
        array\_size\\\hline
        my\_array\\\hline
        \multicolumn{1}{c}{\color{white}CIERTOFALSO\normalcolor}\\ \arrayrulecolor{white}\hline
        \multicolumn{1}{c}{\color{white}CIERTOFALSO\normalcolor}\\ \arrayrulecolor{white}\hline
        \end{tabularx}
    \end{subfigure}%
    \begin{subfigure}{0.33333\linewidth}
        \centering
        \begin{tabularx}{.9\linewidth}{|Y|}
        \hline
        \textbf{Sal. de \texttt{print\_array}} \\\hline
        my\_array\\\hline
        \multicolumn{1}{c}{\color{white}CIERTOFALSO\normalcolor}\\ \arrayrulecolor{white}\hline
        \multicolumn{1}{c}{\color{white}CIERTOFALSO\normalcolor}\\ \arrayrulecolor{white}\hline
        \multicolumn{1}{c}{\color{white}CIERTOFALSO\normalcolor}\\ \arrayrulecolor{white}\hline
        \multicolumn{1}{c}{\color{white}CIERTOFALSO\normalcolor}\\ \arrayrulecolor{white}\hline
        \end{tabularx}
    \end{subfigure}%

    \begin{subfigure}{0.4\linewidth}
        \centering
        \begin{tabularx}{.9\linewidth}{|Y|}
        \hline
        \textbf{Entr. en \texttt{add\_one\_to\_each}} \\\hline
        array\\\hline
        array\_size\\\hline
        my\_array\\\hline
        \multicolumn{1}{c}{\color{white}CIERTOFALSO\normalcolor}\\ \arrayrulecolor{white}\hline
        \multicolumn{1}{c}{\color{white}CIERTOFALSO\normalcolor}\\ \arrayrulecolor{white}\hline
        \end{tabularx}
    \end{subfigure}%
    \begin{subfigure}{0.2\linewidth}
        \centering
        \begin{tabularx}{\linewidth}{|Y|}
        \hline
        \textbf{Entr. en el \texttt{for}} \\\hline
        ii\\\hline
        array\\\hline
        array\_size\\\hline
        my\_array\\\hline
        \multicolumn{1}{c}{\color{white}CIERTOFALSO\normalcolor}\\ \arrayrulecolor{white}\hline
        \end{tabularx}
    \end{subfigure}%
    \begin{subfigure}{0.4\linewidth}
        \centering
        \begin{tabularx}{.9\linewidth}{|Y|}
        \hline
        \textbf{Sal. del \texttt{for}}\\\hline
        array\\\hline
        array\_size\\\hline
        my\_array\\\hline
        \multicolumn{1}{c}{\color{white}CIERTOFALSO\normalcolor}\\ \arrayrulecolor{white}\hline
        \multicolumn{1}{c}{\color{white}CIERTOFALSO\normalcolor}\\ \arrayrulecolor{white}\hline
        \end{tabularx}
    \end{subfigure}%


    \begin{subfigure}{0.33333\linewidth}
        \centering
        \begin{tabularx}{.9\linewidth}{|Y|}
        \hline
        \textbf{Sal. de \texttt{add\_one\_to\_each}} \\\hline
        my\_array\\\hline
        \multicolumn{1}{c}{\color{white}CIERTOFALSO\normalcolor}\\ \arrayrulecolor{white}\hline
        \multicolumn{1}{c}{\color{white}CIERTOFALSO\normalcolor}\\ \arrayrulecolor{white}\hline
        \multicolumn{1}{c}{\color{white}CIERTOFALSO\normalcolor}\\ \arrayrulecolor{white}\hline
        \multicolumn{1}{c}{\color{white}CIERTOFALSO\normalcolor}\\ \arrayrulecolor{white}\hline
        \end{tabularx}
    \end{subfigure}%
    \begin{subfigure}{0.33333\linewidth}
        \centering
        \begin{tabularx}{.9\linewidth}{|Y|}
        \hline
        \textbf{Entr. en \texttt{print\_array}}\\\hline
        array\\\hline
        array\_size\\\hline
        my\_array\\\hline
        \multicolumn{1}{c}{\color{white}CIERTOFALSO\normalcolor}\\ \arrayrulecolor{white}\hline
        \multicolumn{1}{c}{\color{white}CIERTOFALSO\normalcolor}\\ \arrayrulecolor{white}\hline
        \end{tabularx}
    \end{subfigure}%
    \begin{subfigure}{0.33333\linewidth}
        \centering
        \begin{tabularx}{.9\linewidth}{|Y|}
        \hline
        \textbf{Entr. en el \texttt{for}}\\\hline
        ii \\\hline
        array\\\hline
        array\_size\\\hline
        my\_array\\\hline
        \multicolumn{1}{c}{\color{white}CIERTOFALSO\normalcolor}\\ \arrayrulecolor{white}\hline
        \end{tabularx}
    \end{subfigure}%


    \begin{subfigure}{0.33333\linewidth}
        \centering
        \begin{tabularx}{.9\linewidth}{|Y|}
        \hline
        \textbf{Sal. del \texttt{for}}\\\hline
        array\\\hline
        array\_size\\\hline
        my\_array\\\hline
        \multicolumn{1}{c}{\color{white}CIERTOFALSO\normalcolor}\\ \arrayrulecolor{white}\hline
        \end{tabularx}
    \end{subfigure}%
    \begin{subfigure}{0.33333\linewidth}
        \centering
        \begin{tabularx}{.9\linewidth}{|Y|}
        \hline
        \textbf{Sal. de \texttt{print\_array}} \\\hline
        my\_array\\\hline
        \multicolumn{1}{c}{\color{white}CIERTOFALSO\normalcolor}\\ \arrayrulecolor{white}\hline
        \multicolumn{1}{c}{\color{white}CIERTOFALSO\normalcolor}\\ \arrayrulecolor{white}\hline
        \multicolumn{1}{c}{\color{white}CIERTOFALSO\normalcolor}\\ \arrayrulecolor{white}\hline
        \end{tabularx}
    \end{subfigure}%
    \begin{subfigure}{0.33333\linewidth}
        \centering
        \begin{tabularx}{.9\linewidth}{|Y|}
        \hline
        \textbf{Sal. de \texttt{main}} \\\hline
        \\\hline
        \multicolumn{1}{c}{\color{white}CIERTOFALSO\normalcolor}\\ \arrayrulecolor{white}\hline
        \multicolumn{1}{c}{\color{white}CIERTOFALSO\normalcolor}\\ \arrayrulecolor{white}\hline
        \multicolumn{1}{c}{\color{white}CIERTOFALSO\normalcolor}\\ \arrayrulecolor{white}\hline
        \end{tabularx}
    \end{subfigure}%
\caption{Ejemplo del estado de la pila en una ejecución}
\label{tab:stackExample}
\end{table}


Ahora que ya sabes cómo funciona la pila y las implicaciones que tiene que
los arrays se guarden en ella, podemos ver la última región y quizás la más
importante: el montículo (o \textit{heap}). En ésta región se guarda la memoria
que tú le pides el sistema operativo mediante una serie de funciones que vamos
a ver. Y pensarás, ¿para qué voy a hacer eso si puedo hacer un array? Sencillo:
esta memoria que pides está permanentemente a tu disposición \textbf{hasta que
la liberas}. Es decir, al contrario que los arrays, debes preocuparte tú de
saber cuándo liberar esa memoria. Es una de las tareas más importantes de
un programador en C, pero para poder hacer eso, tenemos que aprender primero
qué son los punteros.
\subsection{Punteros}
Ahora que ya sabes que la memoria está direccionada por bytes, debes saber cuál
es la manera en que usamos direcciones en el lenguaje C. Lo hacemos con un nuevo
(para nosotros) tipo de variable llamado puntero. Un puntero es
una variable que guarda una dirección de memoria, y nos permite comunicarle a
funciones u otras partes del programa \textbf{una región de memoria}.
Ya has usado punteros, pero no lo sabías porque he preferido explicar primero
el resto de cosas que has visto en secciones anteriores, aunque te he ido
avanzando su uso.

Te dije en su momento que cuando a una función se le pasa un array éste decae
a tipo puntero. Es decir, como no hacemos una copia de los arrays que le pasamos
a las funciones, lo que hacemos es decirle a la función dónde están los elementos
del array. Así, si es necesario que haga una copia, lo hará, y si no, los leerá
o manipulará directamente.

Si un puntero simboliza una dirección de memoria, puedes pensar que un único
tipo que simbolice una dirección sería suficiente, pero no. Cada tipo de dato
(tanto básico como estructura) que haya en tu código tiene asociado su tipo
puntero, es decir, no hay únicamente punteros, sino punteros a \verb!int!, a
\verb!double!, a \verb!char!, a tal o cual \textit{struct}... ¿Por qué es eso
así? Porque al usar punteros con tipos asociados, sabemos \textbf{qué hay} en la
dirección apuntada. Por ejemplo, si tenemos un puntero a \verb!int! que vale
0xFB455DE, sabemos que debemos coger ese byte y los tres siguientes
y decodificarlos como un entero. Ahora que ya sabes esto, veámoslo en código:

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C, label={lst:pointers1},
caption={Declaración de punteros}]
#include <stdio.h>

int main(void)
{
    int a = 2;
    int *ptr_to_a;
    ptr_to_a = &a;
    printf("a es un entero alojado en %p que vale %d\n", ptr_to_a, a);
}
\end{lstlisting}
\end{minipage}


En la línea 7 declaramos por primera vez una variable puntero, esto se hace
con ese asterisco que ves entre el tipo de la variable y su nombre. Es aquí
donde se establece que este puntero está asociado a un \verb!int!. En la
siguiente línea asignamos a este puntero el valor de la dirección donde está
alojada la variable \verb!a!. Para eso usamos el operador \verb!&!.
El nombre del operador que más se usa es \textit{ampersand}, en español se llama
et, pero este nombre es poco conocido.
Dicho operador, delante de
una expresión, nos da el puntero de su tipo a donde su valor esté alojado.
Ten en cuenta que, para que esto funcione, esa expresión debe estar alojada
en algún sitio. Es decir, los valores temporales otorgarían un error, por
ejemplo \verb!&(a*2)! lanzaría un error, porque \verb!a*2! no ha sido guardado
en ningún sitio aún.
Si ejecutas ese programa, la salida será parecida a esto:


\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=terminalStyle]
\$ ./main.exe
a es un entero alojado en 0x7ffff5c58e7c que vale 2
\end{lstlisting}
\end{minipage}


Entonces, veamos un caso práctico de para qué valen los punteros, por ejemplo:
ya hemos dicho muchas veces que una función que recibe un entero lo que hace
es recibir una copia. ¿Y si quisiéramos ahorrarnos eso? Si, por ejemplo, quieres
una función que multiplique un número por otro, quizás no quieres que se haga
una copia, que devuelva el resultado y copiar ese resultado en la variable,
simplemente \textbf{deja de que la función haga el trabajo}. Si le pasamos
el puntero a nuestra variable, será la función quien cambie el valor, vamos a
verlo:


\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C, label={lst:pointers1},
caption={Declaración de punteros}]
#include <stdio.h>
void multiply(int* ptr, int b) {
    (*ptr) *= b;
}
int main(void)
{
    int a = 2;
    int* pointer_to_a;
    pointer_to_a = &a;
    printf("a es un entero alojado en %p que vale %d\n", pointer_to_a, a);
    multiply(pointer_to_a, 4);
    printf("a es un entero alojado en %p que vale %d\n", pointer_to_a, a);
}
\end{lstlisting}
\end{minipage}


Aquí puedes ver cómo declaramos una función que recibe un puntero a entero (la
variable que queremos multiplicar) y un entero (el número por el que la
multiplicaremos). En esta función verás un uso nuevo del operador asterisco
(\verb!*!), que es el de \textbf{desreferenciar} un puntero. ¿Qué es eso?
Es acceder al valor que ese puntero referencia (de ahí el nombre). Recuerda
que, como puntero, \verb!ptr! contiene la dirección de memoria, necesitamos una
manera de decirle a C que meta en esa dirección el número multiplicado. Para eso
usamos el asterisco delante del puntero. Después, usamos el operador \verb!*=!
para multiplicar y asignar por el otro argumento.
En la línea 11 puedes ver como simplemente llamamos a la función, sin tener
que guardar lo que devuelve (porque de hecho la hemos definido como \verb!void!
así que no devuelve nada) y nos ahorramos la copia del entero que queríamos
multiplicar.

Además del operador asterisco, hay otro operador que se utiliza con punteros
que debes conocer, y éste es operador flecha \verb|->|. Sirve para acceder a los
campos de un puntero a una estructura. Esto puede parecer un poco confuso, pero
lo voy a explicar detenidamente. Imagina que tenemos la estructura punto que
escribimos en la sección sobre estructuras. Si, por el motivo que fuera,
estuviéramos
manejando un puntero a una estructura de este tipo y quisiéramos acceder a sus
campos,
tendríamos que utilizar el operador asterisco para desreferenciar el puntero
y después el punto para acceder al campo. Por ejemplo: sea \verb!point_ptr! un
puntero a \verb!struct point_s!, para acceder a su valor \verb!x!, tendríamos
que escribir \verb!(*point_ptr).x!. No parece un problema, pero te informo de
que es común tener estructuras con punteros a otras que apunten a su vez a
otras... puede ser bastante ilegible hacer esto al cabo de tres o cuatro
punteros. Por eso existe el operador flecha, para que esto se convierta
simplemente en \verb|point_ptr->x|. Quiero que quede claro que este operador
accede al campo, no otorga un puntero al mismo. Es decir, siguiendo con el
ejemplo, \verb!point_ptr->x! será un \verb!double!, no un \verb!double*!.
Algo más adelante veremos este operador en uso.

\subsubsection{Aritmética de punteros}
Los arrays son en ciertos aspectos (pero \textbf{no} todos) equivalentes a
punteros, debido a esto, los punteros pueden ser referenciados con el operador
corchete. Y de hecho, puedes convertir un array a puntero explícitamente en
tus programas. Veamos cómo:

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C, label={lst:pointers2},
caption={Arrays como punteros}]
#include <stdio.h>

int main(void)
{
    int my_array[10] = {0,1,2,3,4,5,6,7,8,9};
    int* pointer_like_array = my_array;
    for (int ii = 0; ii < 10; ++ii) {
        printf("array[%d] = %d\n",ii, my_array[ii]);
    }
    puts("========");
    for (int ii = 0; ii < 10; ++ii) {
        printf("array[%d] = %d\n",ii, pointer_like_array[ii]);
    }
}
\end{lstlisting}
\end{minipage}


Esto que ves en el programa \ref{lst:pointers2} es lo que pasa
sin que te des cuenta cuando una
función recibe un array, éste se convierte en un puntero y puedes manejarlo
con los mismos operadores de un array. Esto, sin embargo; sólo es válido para
arrays de una dimensión, por un motivo que veremos más tarde.
En puridad, el operador corchete es un \textit{atajo}. En realidad lo que hace
es sumar al puntero y utilizar el asterisco para desreferenciar. Cuando sumas
un entero a un puntero entra en juego la aritmética de punteros, veamos
un ejemplo y te explico lo que es exactamente.


\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C, label={lst:pointers3},
caption={Aritmética de punteros}]
#include <stdio.h>

int main(void)
{
    int my_array[10] = { 0,1,2,3,4,5,6,7,8,9 };
    int* pointer_like_array = my_array;
    for (int ii = 0; ii < 10; ++ii) {
        printf("En la dirección %p hay un %d\n",
            pointer_like_array + ii,
            *(pointer_like_array + ii));
    }

}
\end{lstlisting}
\end{minipage}


Si ejecutas el programa verás que las direcciones que imprimen están separadas
4 unidades. Esto es porque cuando a un puntero le sumas un entero, aunque dicho
puntero es una dirección de memoria de una memoria direccionada por bytes, al
ser un puntero a \textbf{entero}, esa expresión de sumarle un número se traduce
a sumarle ese número multiplicado por el tamaño de un \verb!int! (cuatro bytes).
Después de esto, utilizamos el
operador asterisco para que ese puntero al que hemos sumado un entero sea
desreferenciado. Utilizar la aritmética de punteros es útil cuando quieres
pasar a una función el puntero a una posición de un array. Veamos un ejemplo.


\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C, label={lst:pointers4},
caption={Ejemplo práctico de aritmética de punteros}]
#include <stdio.h>
void multiply(int* number, int other) {
    *number *= other;
}

void multiply_array(int* array, int array_length, int other) {
    for (int ii = 0; ii < array_length; ++ii) {
        multiply(array + ii, other);
    }
}

void print_array(int array[], int array_size) {
    for (int ii = 0; ii < array_size; ++ii) {
        printf(" %d ", array[ii]);
    }
    printf("\n");
}

int main(void)
{
    int array[] = { 1,2,3,4,5,6,7,8,9,10 };
    print_array(array, 10);
    multiply_array(array, 10, 10);
    print_array(array, 10);
}
\end{lstlisting}
\end{minipage}


Por ejemplo, si utilizamos la función que multiplica un entero sin tener que
devolverlo, podemos hacer la versión que haga lo propio con un array (aquí
puedes apreciar como las funciones sirven para no duplicar código). Y podemos
ver como, usando la aritmética de punteros, no necesitas tener en cuenta tú
mismo el tamaño de cada tipo de dato, el lenguaje lo hace por ti. Hay una
sintaxis alternativa para esto que a veces verás porque es más compacta, y es
utilizar el operador corchete para acceder al elemento y después usar el
operador \verb!&! para conseguir la dirección, haciendo eso, la línea 8 quedaría
como sigue \lstinline[style=C]{multiply(&array[ii], other);}. En estos casos
usar u otra alternativa queda a discreción del programador.

\subsubsection{El puntero a \texttt{char}}
Por fin voy a desvelar uno de los misterios que más tiempo he estado ocultándote
(muy a mi pesar, que conste en acta) sobre los programas que hemos escrito
hasta ahora. Este misterio es: qué son los textos que escribimos entre comillas
dobles, por ejemplo: \verb|"¡Hola, mundo!"|. Me he saboteado un poco a mí mismo
porque lo he puesto en este epígrafe, pero son una manera abreviada de escribir
\textbf{arrays de \texttt{char}}. Ya sabes que un \verb!char! es una letra, y que
un array es un es una sucesión de datos. La conclusión lógica es que, en C, los
textos son arrays a \verb!char!. Bueno, y si son arrays a \verb!char!, dónde
está su declaración y por qué van por ahí sueltos entre comillas. En resumen:
debido a que escribir textos en un programa es muy común, los creadores de C
decidieron añadir una \textbf{expresión constante} para poder declarar arrays de
\verb!char! temporales donde fuera necesario, esta expresión es, efectivamente,
poner el texto entre comillas. Hay expresiones para declarar arrays de otros
tipos de datos del mismo modo, pero no son tan importantes así que las veremos en
secciones posteriores.

Sin embargo; hay una diferencia entre un array de \verb!char! (o puntero cuando
pasa a una
función) y un array de otro tipo de dato. La función \verb!printf!, por ejemplo,
recibe un puntero a \verb!char!, pero en ningún sitio indicamos el tamaño de
éste. Alguna manera debe tener cualquier función que reciba un puntero a
\texttt{char}
que contenga texto de saber cuánto mide dicho array. Esa manera es que todas
las cadenas de texto (\textit{strings} en inglés) en C terminan con un char
con el valor 0. Es decir, al escribir \verb|"¡Hola, mundo!"| estamos creando
rápidamente un array de \verb!char! que contiene \textbf{catorce} \verb!char!,
las letras que ves y un char con valor 0 al final. Voy a demostrarte que
esto es así con un pequeño programa:

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C, label={lst:sizeofArraysPointers}, caption={Arrays de char}]
#include <stdio.h>

int main(void)
{
    char correct_string[] = "Me gusta el batido de chocolate.\n";
    char incorrect_string[] = { 'M','e',' ','g','u','s','t','a',' ',
                                'l','a',' ','p','i','z','z','a',' ',
                                'c','o','n',' ','b','a','c','o','n',
                                '.'};
    printf(correct_string);
    printf(incorrect_string);
}
\end{lstlisting}
\end{minipage}

La primera cadena se imprimirá correctamente, pero la segunda se imprimirá y,
con toda probabilidad, después de ella saldrán cosas, probablemente sin sentido.
Esto es porque como la segunda cadena no acaba en un \verb!char! con valor 0,
\verb!printf! no sabe cuándo dejar de imprimir. Aparte de esta manera de
trabajar con ellos, los arrays a \verb!char! funcionan como cualquier otro array
y, cuando se convierten en punteros, como cualquier puntero. En secciones
posteriores te explicaré cómo manipular cadenas de texto de maneras más
avanzadas.

\subsubsection{El puntero nulo}
Hay un valor especial para todos los tipos de puntero, que es el puntero nulo,
o, como se escribe en el lenguaje: \verb!NULL!. Es un puntero a \verb!void! que
vale 0. Si recuerdas el mapa de memoria, esa dirección correspondería al código,
nuestro programa no puede modificarse a sí mismo ni leerse, entre otras cosas
porque parte de esa sección no es nuestro código, sino código del sistema
operativo que incrusta en nuestro binario para permitirnos realizar ciertas
funciones. Así que los diseñadores del lenguaje utilizaron este valor para
simbolizar un puntero que está en un estado especial.

Uno de los usos más importante de este puntero es que sirve para explicar si
una operación ha ido bien o no. Por ejemplo, cuando abrimos un archivo con una
función llamada \verb!fopen!, éste devuelve un puntero a una estructura, si
el archivo no existe, o no tienes permisos para abrilo, ese puntero será
\verb!NULL!.
Muchas funciones que reciben un puntero
usan \verb!NULL! para indicar un comportamiento especial. Por ejemplo, vamos a
escribir una función que encapsule la funcionalidad del programa
\ref{lst:pointNoStruct}, esto ha sido un ejercicio, así que si no lo has hecho,
hazlo ahora; pero le vamos a dar un giro: en vez de recibir en la función las
estructuras, vamos a recibir punteros. Primero, porque como ya te dije,
ahorramos la copia de la estructura y además podemos usar \verb|NULL| para
indicar valores especiales.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C, label={lst:nullPointers}, caption={Uso de punteros a \texttt{NULL}}]
struct point_s {
    double x; double y;
};

double distance(struct point_s *a, struct point_s *b) {
    double res = 0.0;
    struct point_s origin = { .x = 0.0, .y = 0.0 };
    if(NULL == a){
        a = &origin;
    }
    if(NULL == b){
        b = &origin;
    }
    double diff_x = a->x - b->x;
    double diff_y = a->y - b->y;
    res = sqrt(diff_x * diff_x + diff_y * diff_y);
    return res;
}

int main(void)
{
    struct point_s a = {.x = 3, .y = 4};
    double d = distance(&a, NULL);
    printf("Distance: %f\n", d);
}
\end{lstlisting}
\end{minipage}

Si observas la función que hemos escrito, dentro de ella declaramos un punto
que simboliza el \textbf{origen de coordenadas}. Lo que hacemos es que si
uno de los punteros a estructuras es \verb|NULL|, entendemos que ese punto
es el origen de coordenadas. Lo que hacemos es que asignamos a nuestros
argumentos (que son punteros) la dirección a esta variable local que hemos
declarado. Recuerda: los argumentos que una función recibe son \textbf{copias}
de los valores. En este caso, nuestro argumento es un puntero a una estructura.
Al asignar a nuestro argumento otro valor \textbf{no estamos alterando la
estructura original}, porque no hemos cambiado el valor al que nuestro argumento
apunta, sino el mismo argumento. Una vez hecho esto, podemos calcular la
distancia del mismo modo que haríamos si no fueran punteros. ¿Qué utilidad tiene
escribir esta función así? Encontrar la distancia de un punto al origen de
coordenadas es una operación común, al hacer esto así, permitimos que quien
llame a la función lo haga sin declarar una estructura extra que simbolice
el origen.

\subsection{Alojar y liberar memoria}
Ahora que ya hemos aprendido lo que es un puntero, y a manejarlos, podemos
pedirle al sistema operativo memoria de esa que se almacena en el montículo y
podemos gestionar de manera más flexible que los arrays. Para eso utilizamos
dos funciones: \verb!malloc! y \verb!free!. Los nombres son bastante
descriptivos: la primera significa \textit{memory alloc} y la segunda liberar.
Cuando necesitas reservar memoria en el montículo, llamas a \verb!malloc!
y le pides una región contigua de memoria de $n$ bytes. La función \verb!malloc!
devuelve un puntero a \verb!void!. Ese mismo puntero deberá, en algún momento,
liberarse pasándoselo a \verb!free! más tarde.


Hablando de punteros a \verb!void!, te dije que \verb!void! significaba que
las funciones o no recibían nada o no devolvían nada, según donde lo pusieras.
El significado del puntero a \verb!void! está relacionado: es un puntero a algo
que no sabes qué es, \verb!malloc! no tiene modo de saber qué vas a hacer con
esa memoria, así que es el tipo de puntero que devuelve. Un puntero a
\verb!void! también es útil cuando queremos hacer funciones o estructuras que
valgan para distintos tipos de datos. Veamos primero un ejemplo sencillo de
cómo usar \verb!malloc! y \verb!free!.

Una de las utilidades principales de la reserva dinámica de memoria es cuando
otra parte del programa hace un cálculo que devuelve un resultado cuyo tamaño
no sabemos. Por ejemplo, imagínate una función que, dado un array de números,
devuelve un array con un ejemplar de cada número distinto, es decir, elimina
las repeticiones del array, llamémosla \verb!erase_reps!.
Las funciones no pueden devolver arrays,
eso ya lo sabemos, pero quien llame a \verb!erase_reps! podría declarar un array
y pasárselo a la función, pero en estos casos existe un problema: no sabemos
el tamaño que tendría ese array. Es cierto que en este caso tenemos un
\textbf{umbral superior}, si le damos a esta función un array de $n$ posiciones,
sólo puede devolverse, como máximo, un vector de $n$ posiciones. Así que podrías
declarar un array de $n$ posiciones y pasárselo a la función para que ésta
escribiera allí el resultado. No obstante, hay un problema, ¿cómo sabemos qué
parte de ese array es solución y cuánto es sobrante? Lo único que puedes hacer es
devolver desde \verb!erase_reps! el tamaño de la solución. En este caso tendrías
un array de $n$ posiciones de las cuales sólo usarías una indeterminada cantidad
menor. Estás desperdiciando memoria. Y si bien no parece un problema,
puede convertirse en uno.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C, label={lst:mallocAndFree}, caption={Ejemplo de reserva dinámica}]
#include <stdio.h>
#include <stdlib.h>

int *erase_reps(int* array, int array_length, int* final_length) {
    *final_length = 0;
    int preliminary_array[array_length];
    for (int ii = 0; ii < array_length; ++ii) {
        int unique = 1;
        for (int jj = 0; jj < ii; ++jj) {
            if (array[ii] == array[jj]) {
                unique = 0;
                break;
            }
        }
        if (unique) {
            preliminary_array[*final_length] = array[ii];
            ++(*final_length);
        }
    }

    int* result = malloc(*final_length * sizeof(int));

    for (int ii = 0; ii < *final_length; ++ii) {
        result[ii] = preliminary_array[ii];
    }
    return result;
}


int main(void)
{
    int array[] = { 20,1,2,3,4,5,8,7,8,9,6,6,5,4,1,2,3,8,5,4,4,5,6};
    int length;
    int* result = erase_reps(array, 23, &length);
    for (int ii = 0; ii < length; ++ii) {
        printf("%d\n", result[ii]);
    }
    free(result);
}
\end{lstlisting}
\end{minipage}

En la línea dos del código vemos como aparece la línea
\verb!#include <stdlib.h>!, es una línea necesaria para usar \verb!malloc! y
\verb!free!. Después llega la declaración de la función, hemos hecho que
devuelva el puntero al resultado y reciba tres argumentos: el array del que
vamos a eliminar repeticiones, la longitud del array y un puntero a entero que
servirá para \textbf{indicar la longitud del vector resultado}. Este patrón
de diseño es muy común en programas en C, cuando necesitas que la función
calcule muchas cosas, recibes punteros a sitios donde dejar la información,
esto es lo que hemos hecho con el tamaño del resultado. En el cuerpo
de la función asignamos el valor 0 a \verb!final_length! para empezar. Después
declaramos un array preliminar en que guardar los números únicos, ¿por qué un
array? Porque este no es el resultado, sino un array que usaremos para guardar
los números hasta que sepamos cuántos y cuáles son. No sabremos cuántos
números únicos hay hasta que los contemos, así que le asignamos el tamaño del
array de entrada para poder usar ese umbral superior que mencioné antes, si
el array de entrada mide $n$, nuestro resultado no puede tener más que $n$
posiciones.
Ese patrón también es muy común: utilizar una estructura de datos auxiliar que
luego copiaremos a una mejor dimensionada y definitiva.

El siguiente bucle
simplemente comprueba, para cada número del array, si ese número aparece antes.
Presta atención al bucle interno, para cada elemento $i$ del array, examinamos
los elementos desde el primero (el 0) al anterior al i-ésimo y comprobamos si
alguno es igual. Si lo es,
utilizamos la variable \verb!unique! para indicar si el número ha sido
encontrado antes y, por lo tanto, no es único, así que asignamos a esta variable
lógica el valor 0.
Después, una vez hemos comprobado todos los
elementos anteriores al actual, aumentamos la longitud final y copiamos este
número al array preliminar. Cuando ya tenemos calculada la longitud del array
final y todos los números en el array preliminar, podemos usar \verb!malloc!
para crear la solución final.

La función \verb!malloc! devuelve, como ya hemos dicho, un puntero que indica
el inicio de la zona de memoria que nos ha reservado. Para ello, recibe
\textbf{el tamaño en bytes} que queremos. Y aquí verás el operador
\lstinline[style=C]{sizeof}. Sí, he dicho operador, no función. De hecho,
verás que ninguna función sale en azul en los ejemplos, y \verb!sizeof! sí.
Esto es por es un operador \textbf{unario} que nos da el tamaño en bytes
de un tipo de dato que escribamos después, entre paréntesis. También sirve para
obtener el tamaño de expresiones en general, pero eso lo veremos más adelante.
De momento quédate con que \verb!sizeof(int)! es igual al
tamaño en bytes de un entero. Como puedes ver, simplemente multiplico el tamaño
del entero por el de posiciones que sé que son únicas. El siguiente bucle,
simplemente, copia de la solución parcial a la definitiva. Finalmente,
devolvemos el puntero reservado con \verb!malloc!.

En la función \verb!main! simplemente declaramos un array con varios números
aleatorios con repeticiones, llamamos a la función sobre ellos y mostramos el
resultado por pantalla. Verás que funciona como se espera. Nota el uso que
hacemos del operador \verb!&! para pasarle a la función \verb!erase_reps! el
puntero a una variable normal.

Como apunte, he estado usando y mezclando las palabras array y vector en esta
sección, y no lo he hecho casualmente: un vector es un conjunto de memoria
contigua que aloja datos, pero que es susceptible de crecer y encoger, y que,
en consecuencia, ha sido reservado dinámicamente. Un array es ese tipo de
expresión que te expliqué en su propia sección. Se parecen, y de hecho comparten
muchas características, pero no son exactamente lo mismo.

Y ya que hablamos de vectores y arrays, hay una diferencia fundamental entre
los vectores o punteros y los arrays. De un array \textbf{podemos conocer su
tamaño} y de los punteros que apuntan a vectores no. Y si de los arrays podemos
conocer su tamaño, ¿por qué hemos estado usando siempre un valor literal? Porque
no quería contarte eso hasta que pudiera comparar punteros y arrays. Antes te
dije que el operador \verb!sizeof! nos da el tamaño en bytes de un tipo de dato
o \textbf{de una expresión}. El tamaño en bytes de un array es lo que
esperaríamos, si contiene 10 enteros de 4 bytes, 40. Pero el tamaño de un
puntero \textbf{es siempre el mismo}. Es más, el tamaño de un puntero a
cualquier tipo de dato es siempre el mismo. Veamos cómo utilizar \verb!sizeof!
para calcular el tamaño de un array.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C, label={lst:sizeofArraysPointers}, caption={Diferencia entre \texttt{sizeof} con punteros y arrays}]
#include <stdio.h>
#include <stdlib.h>

int main(void)
{
    int array[] = { 12,42,53,85,45,54,11,26,21,13 };
    int array_size = sizeof array / sizeof array[0];

    for(int ii = 0; ii < array_size; ++ii){
        printf("%d\n", array[ii]);
    }

}
\end{lstlisting}
\end{minipage}

Aquí es donde entra en juego eso que te dije de que \verb!sizeof! es un operador
y no una función. Si ves la línea 7, utilizamos \verb!sizeof! para hallar el
tamaño del array y lo dividimos por el tamaño del primer elemento. De este
modo, podemos saber fácilmente el número de posiciones. Aquí lo he asignado
a una variable para que lo veas mejor, pero podríamos haber puesto esta
expresión directamente en el bucle \verb!for!. Bien, y sabiendo esto, quizás
te estés preguntando por qué siempre que le pasamos un array a una función
pasamos también un argumento que indica el tamaño del array, si podríamos usar
\verb!sizeof! para ello. Pues es que no podemos, porque cuando a una función se
le pasa un array, recuerda que éste se convierte en un puntero. Lo bueno de los
vectores, sin embargo, es que como los reservamos basándonos en su tamaño,
podemos asignar ese tamaño a una variable antes de llamar a \verb!malloc! y
así tenerlo accesible.

Y aún tengo otro truco que enseñarte sobre este operador, y es que nos permite
escribir las llamadas a \verb!malloc! en un modo que favorezca algunos cambios
en el código. Imagínate esta llamada a \verb!malloc!:
\lstinline[style=C]{int *vector = malloc(length * sizeof(int));} Es como la
que hemos hecho antes, pero presenta un pequeño problema: si cambiamos el tipo
del array, debemos estar muy atentos de cambiar también el tipo que hay dentro
de \verb!malloc!, porque si no estaríamos reservando menos espacio del que
pensamos. No obstante; recordemos que \verb!sizeof! permite calcular el tamaño de
expresiones, así que podemos cambiar la llamada a una como esta:
\lstinline[style=C]{int *vector = malloc(length * sizeof *vector);}. Fíjate,
si \verb!vector! es un puntero a \verb!int!, \verb!*vector! sería el primer
elemento, un entero, y \verb!sizeof! nos dará en consecuencia el tamaño de un
entero (4). La ventaja de este estilo de llamada es que así, si cambiamos de
opinión y queremos que \verb!vector! sea un \verb!double*!, no tenemos que
acordarnos de cambiar nada dentro del argumento de \verb!malloc!.

\subsection{Composición de punteros}
Ahora que ya conoces los mecanismos básicos de los punteros, podemos ver algunos
ejemplos de estructuras más complejas con ellos. Por ejemplo, uno de los casos
más interesantes con los que te encontrarás con relativa frecuencia es el
puntero a puntero de determinado tipo de dato. Esto es el equivalente a un
array de dos dimensiones, pero con reserva dinámica de memoria. Veamos un
programa en C que cree esta estructura, te invito a que lo compares con el
programa \ref{lst:bidimensionalArray}: \nameref{lst:bidimensionalArray}, en el
que veíamos la creación y uso de un array bidimensional.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Reserva, uso y liberación de un vector de vectores},
label={lst:bidimensionalVector}]
#include <stdio.h>
#include <stdlib.h>

int main(void)
{
    int rows = 10;
    int columns = 5;
    int** matrix = malloc(rows * sizeof(*matrix));

    for (int ii = 0; ii < rows; ++ii) {
        matrix[ii] = malloc(columns * sizeof(*matrix[ii]));
        for (int jj = 0; jj < columns; ++jj) {
            matrix[ii][jj] = ii * columns + jj + 1;
        }
    }

    for (int ii = 0; ii < rows; ++ii) {
        for (int jj = 0; jj < columns; ++jj) {
            printf("%2d\t", matrix[ii][jj]);
        }
        printf("\n");
    }

    for (int ii = 0; ii < rows; ++ii) {
        free(matrix[ii]);
    }
    free(matrix);
}
\end{lstlisting}
\end{minipage}

En la línea 8 del programa de ejemplo podrás ver que declaramos un puntero
con dos asteriscos, esto es porque es un puntero a puntero a entero. Los
punteros pueden encadenarse infinitamente, y, en el fondo, no tendría por qué no
ser así, si lo piensas detenidamente. Si un puntero es una dirección de memoria,
nada me impide hacer que ésta a punte a un lugar de la memoria donde hay otra
dirección, y así sucesivamente. Además, aquí puedes ver que reservamos
memoria para \verb!rows! punteros a entero. La regla para entender los punteros
es que el número de asteriscos en la declaración se anula con los asteriscos
usados para desreferencias, de este modo, si hemos declarado \verb!matrix! como
un \verb!int**!, al hacer \verb!*matrix! estamos obteniendo un \verb!int*!.
Observa la simetría, o, simplemente, cuenta los asteriscos, esta simple regla
es sencilla, pero potente a la hora de aclarar nuestras ideas sobre punteros.

En la línea 10 empezamos un \verb!for! que reserva memoria para cada fila de
\verb!matrix!, después, una vez reservada, rellenamos esos elementos con un
valor con el bucle de la línea 12. Aquí simplemente estamos haciendo que cada
casilla valga su posición desde el principio (empezando desde uno, que queda más
bonito). Como puedes ver, estamos usando corchetes para indizar este doble
puntero, con los corchetes pasa lo mismo que con los asteriscos, así que si
\verb!matrix! es, de nuevo, un \verb!int**!, al hacer \verb!matrix[ii][jj]!
estamos obteniendo un \verb!int!. Los siguientes dos bucles anidados simplemente
imprimen la matriz.

Finalmente, debemos liberar la matriz, observa también la simetría de este
proceso con el proceso de reservar la memoria, si primero hicimos un
\verb!malloc! para \verb!rows! punteros y después cada puntero lo reservamos
con un \verb!malloc! de de \verb!columns! enteros, aquí liberaremos los punteros
en orden inverso, primero liberaremos cada fila de la matriz y después la
matriz en sí misma.

Como esto puede ser confuso la primera vez que se ve, voy a dibujar el mapa
de memoria de esta situación, para que tengas una imagen visual de qué está
ocurriendo. Los punteros son un concepto muy abstracto, así que no te preocupes
si no acabas de entenderlos a la primera.


\begin{figure}[H]
    % Lo centramos
    \center
    \includegraphics[height=225mm]{double_pointer_map}
    \caption{Mapa de memoria de un vector de vectores (doble puntero)}
    \label{img:double_pointer_map}
\end{figure}

En la figura represento el mapa de memoria, a la izquierda están los nombres
que tienen esas ubicaciones de memoria en el programa, y en el rectángulo
expreso su contenido. Las flechas del lado derecho de la imagen representan las
referencias de los punteros a dichas direcciones de memoria. Los colores
simplemente sirven para que puedas seguirlas más fácilmente. Bien, si miras
donde pongo la etiqueta \verb!matrix!, verás que contiene una dirección de
memoria, esta dirección referencia a un \textbf{vector de punteros}, es decir,
\verb!rows! punteros juntos. Cada uno de estos punteros apunta, a su vez, a una
región
contigua de memoria, en la cual se guarda una fila entera de la matriz. Sólo
he representado las primeras tres filas, porque si no la figura sería excesivamente
grande.

Ahora voy a poner la figura de cómo sería el mapa de memoria en el caso de un
array doble, no incluyo el código porque su declaración sería simplemente
\lstinline[style=C]!int matrix[10][5]!.

\begin{figure}[H]
    % Lo centramos
    \center
    \includegraphics[width=.5\linewidth]{double_array_map}
    \caption{Mapa de memoria de un doble array}
    \label{img:double_array_map}
\end{figure}

Como puedes ver, aunque el array es de dos dimensiones, no hay una segunda
desreferenciación. Es decir, en ningún momento se sigue un segundo puntero.
¿Cómo es esto posible? Si miras el mapa, verás que el array se almacena en
una región de memoria continua. Esto quiere decir que C sólo tiene que
adquirir la dirección de inicio del array y, después, sumarle lo que indiquen
los operadores corchete. Es aquí donde se presenta un problema cuando intentamos
pasar un array bidimensional a una función. Llegados a la función, C no sabe
si ese puntero que tiene es un vector de vectores o un array de arrays, por
ello, si le pasaras este array doble a una función que recibe un puntero doble,
al hacer, por ejemplo, \verb!matrix[1][2]! lo que intentaría hacer es acceder
como si fuera un puntero, y haría: \verb!*((*(matrix + 1))+2)! Es decir, primero
sumaría (recuerda la aritmética de punteros) uno a la dirección base, después,
\textbf{interpretaría su contenido como un puntero} a otro vector, y a ese
intentaría sumarle 2 para desreferenciarlo. El problema es que
\verb!*(matrix+1)! \textbf{no es} un puntero, es directamente el número.

C puede hacer esto porque, del mismo modo que te indiqué cuando te expliqué
cómo funciona el operador \verb!sizeof!, podemos ver que C sabe el tamaño de un
array siempre que éste no decaiga a puntero, es decir, puedes saber el tamaño
de un array en cualquier alcance interior a aquél en que fue declarado.

La conclusión lógica de lo que acabamos de ver es que el número máximo de
dimensiones de array que puede recibir cualquier función es uno, porque es el que
se comporta como un puntero sin problemas. El hecho de que el array, por ser
declarado en una única orden, sea una estructura continua en memoria hace que
pueda ser interpretado como una estructura de una sola dimensión. Por ejemplo,
en el siguiente código declaramos y rellenamos un array de dos dimensiones y,
sin embargo, podemos acceder a él como si sólo tuviera una dimensión.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Uso de un array como una estructura unidimensional},
label={lst:bidimensionalArrayAsOneDimension}]
#include <stdio.h>
#include <stdlib.h>

int main(void)
{
    int rows = 10;
    int columns = 5;
    int matrix[10][5];

    printf("matrix = %p\n", matrix);

    for (int ii = 0; ii < rows; ++ii) {
        for (int jj = 0; jj < columns; ++jj) {
            matrix[ii][jj] = ii * columns + jj + 1;
        }
    }

    for (int ii = 0; ii < rows * columns; ++ii) {
        printf("%d\n", (*matrix)[ii]);
    }

}
\end{lstlisting}
\end{minipage}

Como puedes ver, una vez hemos llegado a la región contigua de memoria, es decir
\verb!(*matrix)!, sólo tenemos que recorrerla como si fuera un array
unidimensional.

\subsection{Ejercicios de la sección}
\begin{exercises}[resume*]
\item Completa esta tabla de números en diferentes bases numéricas:
\begin{table}[H]
\begin{tabularx}{\linewidth}{|R|R|R|}
\hline
\multicolumn{1}{|Y|}{\textbf{Decimal}}& \multicolumn{1}{Y|}{\textbf{Binario}} & \multicolumn{1}{Y|}{\textbf{Hexadecimal}} \\\hline
73&  &  \\\hline
   &00100110& \\\hline
&&0x12F       \\\hline
128&&         \\\hline
\end{tabularx}
\end{table}
\item Vuelve al ejercicio noveno y reproduce los contenidos de la pila en cada
bloque de código del programa. Utiliza de referencia la solución que propongo
yo.
\item Haz un programa que cree un puntero de tres niveles de tipo \verb!int!,
lo reserve correctamente, lo rellene con el valores correlativos
\textbf{empezando en uno} y después lo imprima de una manera comprensible.
Finalmente, libéralo también de tal modo que no quede memoria sin liberar al
final del programa.
\item Basándote en el programa anterior, crea dos funciones, una para crear
una matriz tridimensional con memoria dinámica dadas sus tres dimensiones y
otra para liberarla.
\end{exercises}
\section{Modificadores de tipos: constancia y signo}
\label{sec:typeModifications}

Hasta ahora sólo hemos manejado los tipos básicos, pero a esos tipos se les
pueden añadir \textbf{modificadores}, que son cualidades que crean un tipo
ligeramente distinto basado en el anterior. El primero y más importante es el
modificador \lstinline[style=C]!const!. Éste nos permite indicar que una
variable es \textbf{de sólo lectura}, es decir, que una vez le demos valor
cuando la declaramos, no podremos modificarla. Esto es muy útil para asegurarnos
de que no introducimos errores en el código cuando manejamos datos que no deben
ser cambiados.

Por ejemplo, imagínate un programa que utilice el número $\pi$. Por ejemplo
para calcular el área de una circunferencia, necesitaríamos escribir
\verb!surface = PI * pow(r, 2)!. Pero, imagina que nos equivocamos y escribimos
\verb!surface = PI *= pow(r, 2)!, este error sería muy difícil de ver porque
la primera vez la superficie estaría bien calculada, pero \verb!PI! habría
quedado sobreescrita por el uso del operador \verb!*=!, y todos los cálculos
posteriores serían incorrectos. Si declaramos \verb!PI! como una constante,
el compilador nos notificará de estos errores.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Uso de una constante numérica},
label={lst:constantUsage}]
#include <stdio.h>
#include <stdlib.h>

const double PI = 3.141592;

double surface_circle(double radius) {
    return PI * radius * radius;
}

double perimeter(double radius) {
    return 2 * PI * radius;
}

int main(void)
{
    double r = 3.5;
    printf("Un círculo con un radio de %.3f tiene un perímetro de %.2f y un área de %.2f\n", r, perimeter(r), surface_circle(r));
}
\end{lstlisting}
\end{minipage}

En la línea cuatro del código puedes ver cómo declaramos \verb!PI! como una
constante de tipo \verb!double!. Puedes ver que, además, estamos declarándola
como variable global. Si recuerdas cuando te expliqué el alcance las variables y
lo que era una variable global, te dije que era útil cuando había funciones.
Aquí puedes ver uno de los usos comunes de las variables globales, cuando se
definen constantes universales, como podrían ser $\pi$, $e$ o la constante
gravitatoria $G$. Pero volviendo al hecho de la constante, si intentas escribir
una instrucción que modifique la constante, el compilador lanzará un error como
este:

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=terminalStyle]
\$  gcc -o main.exe main.c
main.c: In function 'main':
main.c:17:8: error: assignment of read-only variable 'PI'
   17 |     PI = 1.1;
      |        ^
\end{lstlisting}
\end{minipage}

Pero el modificador \verb!const! se aplica en otro sitio muy importante,
se utiliza en las declaraciones de los argumentos de las funciones para indicar
que los argumentos no se pueden modificar. De nuevo, los argumentos de las
funciones son copias de sus valores, así que, sabiendo esto, no tendría utilidad
una manera de decir que no los podemos modificar, el asunto nuclear de esto es
que el modificador \verb!const! se aplica a punteros, indicando que no se puede
modificar su contenido, y es ahí donde se vuelve tremendamente útil en
conjunción con las funciones. Por ejemplo, volvamos a la función que utiliza
punteros para calcular la distancia entre dos estructuras \verb!point_s!, como
no queremos que estas estructuras sean modificadas por la función.


\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Uso de punteros constantes como argumentos de función},
label={lst:constantArguments}]
#include <stdio.h>
#include <stdlib.h>
#include <math.h>

struct point_s {
    double x; double y;
};

double distance(const struct point_s* a, const struct point_s* b) {
    double res = 0.0;
    struct point_s origin = { .x = 0.0 , .y = 0.0 };
    if (NULL == a) {
        a = &origin;
    }
    if (NULL == b) {
        b = &origin;
    }
    double diff_x = a->x - b->x;
    double diff_y = a->y - b->y;
    res = sqrt(diff_x * diff_x + diff_y * diff_y);
    return res;
}

int main(void)
{
    struct point_s a = { .x = 3 , .y = 4 };
    double d = distance(&a, NULL);
    printf(" Distance : %f\n", d);

}
\end{lstlisting}
\end{minipage}

Si miras el programa, la única diferencia es que en la declaración anteponemos
el modificador \verb!const! delante del tipo del dato. Esto impide que
modifiquemos el contenido de este puntero dentro de la función. Si intentas
hacer, por ejemplo: \verb!a->x++;! el compilador lanzará un error. Esto es de
suma utilidad para el programador que use la función sin haberla escrito,
porque así entiende si una función va a modificar los datos que éste le pase,
sin necesidad de saber qué hacer la función por dentro. Cuando veamos cómo
dividir el programa en varios archivos, verás la importancia de esto en su
totalidad.

Además, el modificador \verb!const! añade el concepto de
\textit{const correctness}, este concepto es aquél por el cual hay que respetar
la cualidad de constancia de las variables y argumentos. Esto quiere decir que
debes definir tus funciones con cuidado de indicar todo lo que sea posible
como constante. Por ejemplo, en el caso de la función que calcula la distancia
entre dos puntos los dos argumentos deben ser constantes. Pero es más, una
función \textbf{puede devolver una constante}. Esto sirve cuando se crean
estructuras de datos que no quieres que el usuario sea capaz de modificar
directamente, sino sólo mediante las funciones que tú quieras.

Hablaremos más de esto en un futuro, pero te pongo un ejemplo básico:
imagínate una estructura que guarda datos de una persona.
En esta estructura
tendremos varios punteros a \verb!char!: el nombre, un primer apellido y un
segundo apellido. Lo que haremos es crear una función que cree esta estructura
recibiendo los tres textos, reservará la memoria necesaria y después copiará
los textos a esa memoria. Después, para manejar esa estructuras vamos a crear
funciones que reemplacen estos arrays cuando el usuario quiera. Vamos a por
ello:

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Estructura con punteros constantes -- Funciones de manipulación},
label={lst:structConstPointers}]
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct person_s {
    char* name;
    char* last_name_1;
    char* last_name_2;
};

struct person_s person_create(const char* name,
                              const char* last_name_1,
                              const char* last_name_2) {
    struct person_s res;

    res.name        = malloc(strlen(name) + 1);
    res.last_name_1 = malloc(strlen(last_name_1) + 1);

    for (int ii = 0; ii < strlen(name) + 1; ++ii) {
        res.name[ii] = name[ii];
    }

    for (int ii = 0; ii < strlen(last_name_1) + 1; ++ii) {
        res.last_name_1[ii] = last_name_1[ii];
    }

    if (NULL != last_name_2) {
        res.last_name_2 = malloc(strlen(last_name_2) + 1);
        for (int ii = 0; ii < strlen(last_name_2) + 1; ++ii) {
            res.last_name_2[ii] = last_name_2[ii];
        }
    }
    else {
        res.last_name_2 = NULL;
    }
    return res;
}

void person_set_name(struct person_s* person, const char* name){
    free(person->name);
    person->name = malloc(strlen(name)+1);
    for(int ii = 0; ii < strlen(name) + 1; ++ii){
        person->name[ii] = name[ii];
    }

}

void destroy_person(struct person_s *person){
    free(person->name);
    free(person->last_name_1);
    free(person->last_name_2);
}
\end{lstlisting}
\end{minipage}

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Estructura con punteros constantes -- Funciones de recuperación de información},
label={lst:structConstGetters}]
const char* person_get_name(const struct person_s* person) {
    return person->name;
}

const char* person_get_last_name_1(const struct person_s* person) {
    return person->last_name_1;
}

const char* person_get_last_name_2(const struct person_s* person) {
    if (NULL == person->last_name_2) {
        return "";
    }
    else {
        return person->last_name_2;
    }
}

\end{lstlisting}
\end{minipage}

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Estructura con punteros constantes -- función \texttt{main}},
label={lst:structConstMain}]
int main(void)
{
    struct person_s myself = person_create("Francisco", "Rodríguez", "Melgar");

    printf("Esta persona es: %s %s %s\n", person_get_name(&myself),
            person_get_last_name_1(&myself),
            person_get_last_name_2(&myself));

    person_set_name(&myself, "José");

    printf("Esta persona es: %s %s %s\n", person_get_name(&myself),
           person_get_last_name_1(&myself),
           person_get_last_name_2(&myself));

    destroy_person(&myself);
}
\end{lstlisting}
\end{minipage}
En este código puedes ver como <<ocultamos>> al usuario cómo manejamos estos
punteros. Para impedir que él cambie su contenido sin utilizar nuestras
funciones, las funciones que devuelven los punteros para poder usarlos, por
ejemplo para imprimirlos, devuelven punteros constantes. Si intentaras hacer,
por ejemplo: \lstinline[style=C]!person_get_name(&myself)[3] = 'a'! el
compilador lanzaría un error. Esto es una herramienta para impedir que el
usuario de la estructura se olvide de liberar la memoria a la hora de reemplazar
el texto por otro.

Si estás atento, te habrás dado cuenta de que todo esto es algo inútil cuando
el usuario de la estructura podría simplemente escribir
\verb!myself.name[0] = 'a'!, y tendrías razón. En secciones posteriores veremos
maneras de evitar esto. Pero incluso con este problema, hacer esto es una buena
manera de ahorrarle trabajo al usuario de la estructura.

El otro modificador que quiero presentarte es el signo, o mejor dicho, la
ausencia de signo. La palabra reservada \lstinline[style=C]!unsigned! nos
permite declarar variables de los mismos tipos que los tipos básicos, pero
que sólo contengan valores positivos. Si no ves a primera vista la utilidad de
esto, ésta reside en que al hacer el tipo sin signo, aumentas el rango que puede
almacenar en los números positivos, si un \verb!char! tiene un rango en
$[-127, 128]$, al hacerlo sin signo, éste tiene un rango de $[0, 255]$. Además,
esto permite añadirle significado a tus variables.

Por ejemplo, una variable que guarde el tamaño de algo, por ejemplo de un array
o de un vector, no debería tener signo, porque nunca puede ser negativa. Una
variable que guarde un mes, por ejemplo, tampoco. En el caso de tamaños de
arrays o vectores es importante porque hacer las variables que guardan su
tamaño no tengan signo, porque así nos permite hacer arrays el doble de grandes.
No existen tipos sin signo para números de coma flotante (\verb!float!
y \verb!double!).
Veamos un ejemplo de cómo utilizar el modificador \verb!unsigned! para declarar
variables, argumentos y tipos de retorno.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Uso de tipos sin signo},
label={lst:unsignedTypes}]
#include <stdio.h>

unsigned int factorial(unsigned int n) {
    unsigned int res = 1;
    for (unsigned int ii = 0; ii < n; ++ii) {
        res *= n - ii;
    }
    return res;
}

int main(void)
{
    unsigned int number = 10;
    printf("%d! =%d\n", number, factorial(number));
}
\end{lstlisting}
\end{minipage}

Sé que parece un poco engorroso escribir \verb!unsigned! cada vez, más adelante
veremos cómo solventar esto.
\subsection{Ejercicios de la sección}
El ejercicio más apropiado es que revises todos los ejercicios que
hemos hecho hasta ahora y los reescribas teniendo en cuenta la constancia de las
funciones y el signo.
\section{Comunicar tu programa con el exterior}
Por fin vamos a llegar al punto en que tu programa pueda comunicarse con el
exterior, hasta ahora, todos los datos que hemos introducido en el programa
están escritos en el código como literales. Eso es muy impráctico, en términos
generales, un programa leerá, ya sea por consola o desde un archivo concreto,
los datos que deba utilizar. Hay tres fuentes de información externa
básicas que vamos a manejar:
\begin{enumerate}
\item Argumentos de la línea de comandos.
\item La entrada por consola.
\item Ficheros.
\end{enumerate}

Lo primero es algo que aún no sabes qué es, pero que será bastante útil. Hasta
ahora, la función \verb!main! no recibía ningún argumento, pero puede
recibirlos. Si \verb!main! es una función que sólo sirve como punto de entrada
a nuestro programa, ¿quién la puede llamar con argumentos? Básicamente
estos argumentos vienen de la línea de comandos con la que llamemos a nuestro
programa. Para poder acceder a ellos dentro del programa, debemos declarar
la función \verb!main! de este modo:

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Declaración de una función \texttt{main} que reciba argumentos},
label={lst:mainArguments}]
int main(int argc, const char** argv) {
// ...
\end{lstlisting}
\end{minipage}

De estos dos argumentos, el primero es el número de argumentos que ha recibido
tu programa, y el segundo es un vector de vectores a \verb!char! que nos llega
en forma de puntero a puntero. Los argumentos que recibe un programa vienen
en formato de cadenas de texto, por lo que, si son números, debemos utilizar
funciones auxiliares para convertirlos a esos tipos de dato. Vamos a hacer
un programa que reciba un número indeterminado de argumentos y los imprima, cada
uno en una línea nueva.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Utilización de los argumentos de un programa},
label={lst:argumentProgram}]
#include <stdio.h>

int main(int argc, char const *argv[])
{
    for (int ii = 0; ii < argc; ++ii) {
        printf("%s\n", argv[ii]);
    }
}
\end{lstlisting}
\end{minipage}

Y quizás te preguntes que cómo le paso esos argumentos al programa, bien, es
sencillo: al llamar el programa, después de la ruta al ejecutable, pones
todos los argumentos separados por espacios, por ejemplo:
\begin{lstlisting}[style=terminalStyle]
\$./main.exe argumento1 argumento2 argumento3
\end{lstlisting}
Si compilas este programa y lo ejecutas con esos argumentos, imprimirá esto:

\begin{lstlisting}[style=terminalStyle]
./main.exe
argumento1
argumento2
argumento3
\end{lstlisting}

Y sí, como ves, el primer argumento es el comando con el que se llamó el
programa, esto es importante porque, como deducirás, quiere decir que tu
programa siempre recibirá al menos uno. Este primer argumento cambia según la
orden con la que llamemos a nuestro programa, por ejemplo, si en vez de con
esa ruta relativa lo llamamos con una ruta absoluta, obtendríamos los siguiente:
\begin{lstlisting}[style=terminalStyle]
\$ /home/usuario/test/project/main.exe arg1 arg2 arg3
/home/usuario/test/project/main.exe
arg1
arg2
arg3
\end{lstlisting}

Como última nota, si el espacio es el carácter que se usa para separar
argumentos, ¿pueden tener espacios los argumentos? Sí, simplemente rodea el
argumento de comillas dobles. Y, entonces, ¿pueden tener comillas dobles? Sí,
simplemente pon una barra inversa delante de la comilla, veamos un ejemplo
rápido,
\begin{lstlisting}[style=terminalStyle]
\$ ./main.exe "Esto es una comilla: \"" \"\"\" "Frase con espacios"
./main.exe
Esto es una comilla: "
"""
Frase con espacios
\end{lstlisting}

Si necesitamos leer un número, debemos utilizar, como ya hemos dicho, una
función que nos convierta el argumento en un número. La función básica para
hacer esto es \verb!atoi! (del inglés: \emph{ASCII to integer}). Por ejemplo,
vamos a crear un programa que reciba una serie de argumentos y los sume:

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Programa que suma argumentos},
label={lst:sumArgs}]
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char const* argv[])
{

    int total = 0;

    for (int ii = 1; ii < argc; ++ii) {
        total += atoi(argv[ii]);
    }

    printf("La suma de los argumentos es: %d\n", total);
}
\end{lstlisting}
\end{minipage}

Nota que empezamos a sumar desde el segundo argumento (la posición uno del
vector) porque el primero no es un número. Esto me lleva a advertirte de que
\verb!atoi! es una función muy básica y si introduces en ella una cadena que no
es un número, devolverá valores sin sentido, en muchas ocasiones 0. Así
que ten cuidado sobre esto. De todos modos, en otras secciones veremos maneras
de manipular cadenas de texto más complejas que nos permitirán comprobarlo.
Sería un ejercicio interesante que hicieras un programa que comprobara si una
cadena de texto es un número o no. Finalmente, también existe \verb!atof! que
hace lo mismo, pero con decimales.

Otra opción que existe que dejar que, una vez iniciado el programa, el usuario
escriba por consola lo que deba éste recibir. Por ejemplo, podríamos hacer un
programa que sea una versión 2.0 de nuestro primer \emph{Hola Mundo}. Esta
versión podría primero preguntar el nombre del usuario y después saludarle por
él. Para conseguir esto se utiliza (o se puede utilizar, hay otras alternativas)
la función \verb!scanf!. Esta función es la hermana gemela de \verb!printf!
porque se comporta igual, simplemente especificas un formato y le das las
variables donde quieres guardar los datos y la función leerá de la terminal
con ese formato. Por ejemplo, hagamos este \emph{Hola Mundo 2.0}.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Ejemplo básico de \texttt{scanf}},
label={lst:basicScanf}]
#include <stdio.h>
#include <stdlib.h>

#define NAME_LENGTH ((size_t)1024)

int main(int argc, char const* argv[])
{

    char name[NAME_LENGTH] = "";
    printf("Hola, ¿cuál es tu nombre?\n");
    scanf("%s", name);
    printf("Escantado de conocerte, %s.\n", name);
}
\end{lstlisting}
\end{minipage}

Como puedes ver, es sencillo, pero debes tener en cuenta que si lees tipos
de datos básicos con \verb!scanf! debes pasarle punteros a esas variables. En
el caso de un puntero a \verb!char! es menos evidente. Además, salvo que llames
a otras funciones para cambiar cómo se comporta la terminal, \verb!scanf! sólo
leerá hasta el primer carácter en blanco que se encuentre, es decir, hasta el
primer espacio, por ejemplo. Eso quiere dedir que si quieres leer varias
palabras debes invocar a \verb!scanf! varias veces o invocarlo con varios
especificadores de formato. Vamos a ver un ejemplo un poco más complicado para
que quede todo esto claro.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Ejemplo avanzado de \texttt{scanf}},
label={lst:scanfExample}]
#include <stdio.h>
#include <stdlib.h>

#define NAME_LENGTH ((size_t)1024)

int main(int argc, char const* argv[])
{

    char name[NAME_LENGTH] = "";
    int age = 0;
    double height = 0.0;
    printf("Hola, quiero conocerte, dime tu nombre, tu edad y cuánto mides en metros\n");
    scanf("%s %d %lf", name, &age, &height);
    printf("Escantado de conocerte, %s. Así que tienes %d años y mides %f m\n", name, age, height);
}
\end{lstlisting}
\end{minipage}

Como hemos dicho, \verb!scanf! deja de leer en los espacios, así que puedes
escribir cada dato y pulsar enter o escribir las tres respuestas separadas
por espacios y darle a enter una sola vez. Además, nota que, como queremos
leer en un \verb!double!, tenemos que usar el especificador \verb!%lf!, esto
también se puede hacer al imprimir, para que se imprima con mayor precisión,
pero en este caso como es en la dirección inversa, el compilador lanza un
\emph{warning} si lo dejamos con simplemente \verb!%f!. Esta función
\textbf{bloquea} el programa hasta que recibe \textbf{todos} los argumentos
pedidos por los especificadores. Además, lo que se escriba en la terminal y
no se consuma (se lea por \verb!scanf!) queda pendiente para llamadas
posteriores, es decir, si en vez de escribir en nuestro ejemplo una sola
llamada, escribieras tres, una con cada especificador y variable, el efecto
sería el mismo, podrías seguir escribiendo todo separado por espacios. Del
mismo modo que \verb!atoi!, si especificas que recibirá números y la entrada
es distinta, fallará dando valores con poco o ningún sentido.

Y finalmente: los ficheros, o archivos. Los programas pueden eliminar, crear,
escribir y leer de archivos. Para esto hay varias maneras, algunas más pedestres
que otras, porque algunas son más estándar y otras dependen del sistema
operativo. Al contrario que con los otros métodos, los ficheros tienen un
ciclo de vida más complejo. El ciclo de vida es, en este contexto, la descripción
de cuándo empieza a existir, existe y deja de existir algo. Por ejemplo,
el ciclo de vida de una región de memoria dinámica es desde que la reservas
hasta que la liberas, el de un array, desde que se entra en su bloque de código
hasta que se sale, etc. Con los archivos pasa algo parecido.

Los archivos son un concepto que, de nuevo, gestiona el sistema operativo,
de tal modo que tenemos que utilizar funciones concretas para abrirlos, escribir
y leer en ellos y, finalmente, cerrarlos. A la mínima que estés un poco atento,
verás el paralelismo entre esto y la reserva de memoria. La función para abrir
un archivo es \lstinline[style=C]!fopen!, veamos su declaración:

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Declaración de la función \texttt{fopen}},
label={lst:callocSignature}]
FILE *fopen(const char *pathname, const char *mode);
\end{lstlisting}
\end{minipage}

Devuelve un puntero a un tipo llamado \verb!FILE!, este tipo es \textbf{opaco},
esta es una palabra que se utiliza en informática para decir que no puedes saber
lo que hay dentro, es decir, es el sistema quien lo gestiona y tú sólo
interactúas con este tipo mediante llamadas a función. Los argumentos de esta
función son dos punteros a \verb!char!. El primero es la ruta al archivo.
Esta ruta puede ser relativa o absoluta, pero ten cuidado, si es relativa, ésta
toma como origen \textbf{el directorio de trabajo} de la terminal donde lo
ejecutes. Es decir, si le dices a la función que abra un archivo en la ruta
\verb!./file.txt!, lo buscará (o lo creará, según proceda), en tu directorio
de trabajo, no en el que se encuentre el ejecutable, salvo que sean el mismo.

El segundo argumento es interesante, es, como indica su nombre, el modo de
apertura del archivo. En éste argumento se suele escribir un literal que
contiene una serie de letras, estas letras son atributos a la manera en que
abrimos el archivo, veamos qué opciones tenemos.
\begin{enumerate}
\item \verb!r!: Abre el archivo para lectura (sólo para lectura) la cabeza
de lectura se sitúa al inicio del archivo. Si el archivo no existe, se produce
un error y la función devuelve \verb!NULL!.
\item \verb!r+!: Igual que la anterior, pero permite escribir también.
\item \verb!w!: \textbf{Vacía} el archivo o lo crea si no existe
y permite escribir en él, situando la cabeza de lectura, lógicamente, al inicio.
\item \verb!w+!: Igual que la anterior, pero permite leer también.
\item \verb!a!: Abre el archivo para escribir, pero \textbf{no lo vacía},
sí que lo crea si no existe. La cabeza se sitúa al final del archivo, para
\textbf{añadir} a al contenido que hubiera.
\item \verb!a+!: El archivo es creado si no existe, se escribirá al final
del mismo y permite también leer.
\end{enumerate}

En la descripción de las opciones hablo de una cosa llamada cabeza de lectura.
Es un concepto propio de los ficheros, en un fichero el programa guarda la
posición del mismo en el que está esta cabeza. Cuando escribes o lees, ésta
se mueve hacia delante tanto como el tamaño de los datos que hayas leído o escrito.
Una analogía que se solía utilizar es que un fichero es como una cinta de vídeo,
y el cabezal de lectura como el del reproductor. El cabezal empieza al inicio
de una cinta y vez de 10 minutos, la pausas y la vuelves a reaundar, empezarás
desde donde lo dejaste. Todo sea dicho, el cabezal de lectura es único por
proceso y archivo, así que dos programas pueden leer o escribir en el mismo
archivo en puntos distintos. Por otro lado, cuando la cabeza de lectura llega
al final, se para allí (lógicamente), pero si estás realizando una operación
de escritura, el archivo se agrandará, como es lógico, porque de no ser así,
no podríamos escribiríamos en archivos nuevos o vacíos.

Ahora que ya sabes cómo abrir un archivo, veamos cómo se lee o escribe de él.
Las funciones que se usan para esto son dos: \verb!fwrite! y \verb!fread!.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Declaración de la función \texttt{fread}},
label={lst:freadSignature}]
size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);
\end{lstlisting}
\end{minipage}

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Declaración de la función \texttt{fwrite}},
label={lst:fwriteSignature}]
size_t fwrite(const void *pt, size_t size, size_t nmemb, FILE *stream);
\end{lstlisting}
\end{minipage}

Las dos funciones se comportan más o menos igual, reciben un puntero, un tamaño,
otro número y finalmente el puntero a la estructura que simboliza el fichero.
El primer puntero es de entrada para escribir y de salida para leer. Es donde
pondremos nuestros datos, o la memoria para que la función lo escriba cuando
leemos. Es un puntero a \verb!char!, que es el puntero que se utiliza para
simbolizar una continuidad de datos genérico, es decir, un continuo de bytes.

Finalmente, después de hacer lo que deseas con los archivos que has abierto,
debes cerrarlo. Cerrar el archivo provoca que todos los cambios que se han
escrito se sincronicen con el disco duro o sistema de almacenamiento subyacente.
Esto es importante, si te olvidas de cerrar un archivo puedes ver que cambios
que has escrito no se reflejan en el archivo. La función para cerrar archivos
se llama \verb!fclose!, su \emph{signature} es la siguiente.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Declaración de la función \texttt{fclose}},
label={lst:fcloseSignature}]
int fclose(FILE *stream);
\end{lstlisting}
\end{minipage}
Como puedes ver, sólo recibe el archivo que deseamos cerrar o liberar.

Ahora que ya hemos explicado las funciones que hay que utilizar, vamos a ver
un ejemplo simple de programa que utilice ficheros. Un programa muy típico
podría ser uno que copie un fichero a otro, como el comando \verb!cp!, que es
el que se usa en Linux para hacer eso. Vamos a hacer un programa que reciba dos
argumentos, el primero será el archivo que deseamos copiar y el segundo dónde.
El comando en Linux admite que la segunda localización sea una carpeta, es
decir, podrías hacer \verb!cp ~/novel.txt /home/joe/novels! pero para hacer
más sencillo nuestro ejemplo, obligaremos a que el usuario siempre especifique
dos rutas completas. Veamos cómo se haría.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Ejemplo de manejos de ficheros},
label={lst:fileBasic}]
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char const* argv[])
{

    FILE *origin_file  = NULL;
    FILE *destiny_file = NULL;
    char byte          = 0;

    if (argc < 3) {
        printf("Uso: main.exe <origen> <destino>\n");
        return EXIT_FAILURE;
    }

    origin_file = fopen(argv[1], "r");

    if (NULL == origin_file) {
        printf("ERROR: El archivo de origen no existe.\n");
        return EXIT_FAILURE;
    }

    destiny_file = fopen(argv[2], "w");

    if (NULL == destiny_file) {
        printf("ERROR: El archivo de destino no existe.\n");
        fclose(origin_file);
        return EXIT_FAILURE;
    }

    while (0 != fread(&byte, sizeof(char), 1, origin_file)) {
        fwrite(&byte, sizeof(char), 1, destiny_file);
    }

    fclose(origin_file);
    fclose(destiny_file);
    return EXIT_SUCCESS;
}

\end{lstlisting}
\end{minipage}

Como puedes ver, hemos declarado dos variables de tipo puntero a \verb!FILE!,
las inicializamos a \verb!NULL! y empezamos el programa. Cuando recibes
argumentos es recomendable que los interpretes primero, porque si éstos son
incorrectos no tiene sentido seguir procesando. Después, intentamos abrir el
archivo de origen, nota que lo abrimos para solo lectura y sin eliminarlo,
lógicamente. Si esa llamada falla, el valor devuelto será nulo, comprobamos
que esto no es así antes de continuar. Hacemos lo mismo, después, con el
archivo de destino, pero date cuenta de que en caso de error, además
de salir del programa (terminar la función \verb!main! con la palabra
\verb!return! termina el programa, lógicamente), debemos cerrar el archivo
anterior que ya abrimos. Finalmente, utilizamos un bucle para leer byte a byte
el archivo de origen y escribirlo en el de destino. Como puedes ver,
la condición del bucle es que continuará hasta que el \verb!fread! devuelva
cero. Esto es así porque tanto \verb!fread! como \verb!fwrite! devuelven
el número de estructuras del tamaño indicado por el segundo argumentos leídas o
escritas, cuando se devuelva cero, es que se ha terminado de leer el archivo.

Voy a concentrarme en el valor de retorno, como ya vimos hace poco, a
\verb!fread! o \verb!fwrite! le indicamos un tamaño y un multiplicador, los
argumentos \verb!size! y \verb!nmemb! respectivamente. Esto nos permitiría
indicar, por ejemplo, que se escribieran \verb!nmemb! estructuras de su tamaño
hallado con \verb!sizeof!. El tamaño devuelto por las funciones es el número
de estructuras escritas, no el de bytes. Si quieres escribir, como en este
caso, un número de bytes, simplemente indica que \verb!size! es uno y
\verb!nmemb! es el tamaño en bytes de lo que quieres escribir.

Ahora bien, quizás pienses que escribir un programa como este que lee byte a
byte es un poco ineficiente, y tienes razón. Cada llamada a las funciones
que tratan con cosas que gestiona el sistema operativo es relativamente
costosa, por lo que es inteligente minimizarlas. En este caso, podríamos leer
todo el primer archivo en memoria, cerrarlo y escribir en el segundo, en una
sola orden, todo lo que ya leímos. El problema es que si por ejemplo intentaras
copiar un archivo de 12~GB es probable que llenaras toda la memoria
de un ordenador normal. Cuando eso pasa, o bien el sistema operativo termina tu
proceso, o simplemente el ordenador se bloquea. Para evitar ambos extremos, lo
que se suele hacer es utilizar un tamaño moderado lógico que guardar en memoria
cada vez. Por ejemplo, digamos que queremos copiar los archivos mediante bloques
de 100~MB, (o mejor dicho, 100~MiB). Veamos cómo
quedaría el programa.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Ejemplo de lectura de fichero con \textit{buffer}},
label={lst:readWithBuffer}]
#include <stdio.h>
#include <stdlib.h>

#define BLOCK_SIZE ((size_t)(1024 * 1024)) //10^20 = MiB

int main(int argc, char const* argv[])
{

    FILE   *origin_file  = NULL;
    FILE   *destiny_file = NULL;
    char   *buffer       = malloc(BLOCK_SIZE);
    size_t  bytes_read   = 0;

    if (argc < 3) {
        printf("Uso: main.exe <origen> <destino>\n");
        return EXIT_FAILURE;
    }

    origin_file = fopen(argv[1], "r");

    if (NULL == origin_file) {
        printf("ERROR: El archivo de origen no existe.\n");
        return EXIT_FAILURE;
    }

    destiny_file = fopen(argv[2], "w");

    if (NULL == destiny_file) {
        printf("ERROR: El archivo de destino no existe.\n");
        fclose(origin_file);
        return EXIT_FAILURE;
    }

    while (0 != (bytes_read = fread(buffer,
                                    sizeof(char),
                                    BLOCK_SIZE,
                                    origin_file)))
    {
        fwrite(buffer, sizeof(char), bytes_read, destiny_file);
    }

    fclose(origin_file);
    fclose(destiny_file);
    free(buffer);
    return EXIT_SUCCESS;
}

\end{lstlisting}
\end{minipage}

El único cambio es que en vez de un único \verb!char! declaramos un vector de
ellos con un tamaño definido en la macro correspondiente y que, después,
en el bucle de copia, en vez de copiar siempre un byte, intentamos leer
el tamaño del bloque, y al escribirlo, utilizamos el valor de retorno de
\verb!fread!. Quiero detenerme aquí porque quizás esta línea te sorprende.
Cualquier asignación es una expresión con un valor. Esto es lo que nos permite
hacer algo como \verb!a = b = c!. Gracias a esta propiedad, puedes comparar
el valor de una asignación con otra variable, que es lo que estamos haciendo.
En este caso, podríamos incluso prescindir de la operación de comparación,
porque comprobar si un número es distinto de cero es lo mismo que pasa si pones
ese número en el \verb!if! directamente, sin embargo, me gusta hacerlo
explícito.

Esto es un uso básico de lectura y escritura en archivos, pero otra cosa que se
hace a veces es \textbf{mover la cabeza de lectura} sin leer o escribir.
Por ejemplo, imagínate que queremos imprimir un archivo en orden inverso.
Nos vemos en el mismo problema que el caso de uso anterior: lo más sencillo
sería leer el archivo entero y después invertirlo, pero es un gran problema
si el archivo es muy grande. Podríamos hacer lo mismo que hicimos antes, leer
el archivo a trozos, invertir los trozos y después ponerlos juntos, también
en orden inverso. Eso es complicado, gracias a que podemos mover la cabeza
de lectura, podemos leer directamente los bloques en el orden inverso, gracias
a esta operación.


\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Ejemplo de uso de funciones para mover la cabeza de lectura},
label={lst:fseek}]
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define BLOCK_SIZE ((long) 100)

void invert_bytes(char* stream, int length)
{
    for (int ii = 0; ii < length / 2; ++ii) {
        char temp = stream[ii];
        stream[ii] = stream[length - 1 - ii];
        stream[length - 1 - ii] = temp;
    }
}
int main(int argc, char** argv)
{
    long  current_pos = 0;
    FILE* file = NULL;
    if (argc != 2) {
        printf("Uso del comando: main.exe <archivo>\n");
        return EXIT_FAILURE;
    }
    file = fopen(argv[1], "r");

    if (NULL == file) {
        return EXIT_FAILURE;
    }

    fseek(file, 0, SEEK_END);
    current_pos = ftell(file);
    while (current_pos != 0) {
        char block[BLOCK_SIZE + 1] = {};
        long next_pos = 0;
        long block_size = 0;
        if (current_pos - BLOCK_SIZE < 0) {
            next_pos = 0;
            block_size = current_pos;
        }
        else {
            next_pos = current_pos - BLOCK_SIZE;
            block_size = BLOCK_SIZE;
        }
        fseek(file, next_pos, SEEK_SET);
        fread(block, 1, block_size, file);
        fseek(file, -block_size, SEEK_CUR);
        invert_bytes(block, block_size);
        printf("%s", block);
        current_pos = ftell(file);
    }
    fclose(file);
    printf("\n");
}
\end{lstlisting}
\end{minipage}

El programa es un poco complicado, pero, como siempre, iremos por partes. Lo
primero que hacemos es definir una función que pueda invertir los bytes de un
array a \verb!char!. No es lo principal de este ejemplo, pero quédate con el
algoritmo porque es una tarea usual y un algoritmo clásico. Después empieza lo
que queremos hacer, es un poco complicado, pero me interesa más que veas lo que
hacen las funciones de las que estamos hablando más que el proceso general.
Hasta la línea 27 lo único que hacemos es algo con lo que ya estás
familiarizado: procesamos los argumentos y abrimos el archivo, comprobando que
todo ha ido bien. Después usamos la función \verb!fseek! que nos permite
\textbf{mover la cabeza de lectura y escritura}, concretamente al final. Veamos
cómo funciona.

Esta función nos permite poner la cabeza de lectura en un punto añadiendo un
desplazamiento, que puede ser positivo o negativo. Hay tres puntos de referencia
que puedes usar con esta función:
\begin{enumerate}
\item \verb!SEEK_SET!: El inicio del archivo, por ejemplo:
\verb!fseek(100, SEEK_SET);! pondría la cabeza en el centésimo byte del archivo.
Si usas este punto de referencia no puedes usar desplazamientos negativos,
lógicamente.
\item \verb!SEEK_CUR!: Es la posición actual, puedes usar desplazamientos
positivos o negativos. Por ejemplo: \verb!fseek(100, SEEK_CUR);! podría usarse
en un bucle para leer el byte 100, el 200, el 300...
\item \verb!SEEK_END!: Es el final del archivo, por ejemplo: si quisieras
ir al tecer byte desde el final podrías escribir: \verb!fseek(-3, SEEK_END);!
\end{enumerate}

En la línea 29 lo que hacemos es irnos directamente al final del archivo.
Después usamos otra función interesante llamada \verb!ftell!. Esta función nos
da la posición actual de la cabeza lectora en el archivo que recibe como
argumento. Así sabremos la posición absoluta en que estamos. Después comprobamos
si nos queda un tamaño del bloque que hemos elegido entero hasta el inicio del
archivo. Si podemos, utilizamos ese tamaño del bloque, si no, utilizamos
lo que podamos. Después, desplazamos a la siguiente posición que hemos calculado
la cabeza, como puedes ver, usamos un posicionamiento absoluto. Leemos y
\textbf{volvemos a desplazarlo hacia atrás} tantos bytes como hemos leído.
Después llamamos a la función que invierte los bytes e imprimimos la cadena
de texto. Después, actualizamos la variable que nos dice en qué posición
estamos. Cuando hayamos llegado a la primera posición del archivo, sabremos que
hemos terminado. Debes tener cuidado, \verb!fseek! sólo funciona cuando es
posible moverse a donde le indicas. Cuando no es posible, no mueve la cabeza y
da error (devuelve -1). Finalmente, cerramos el archivo e imprimimos un salto
de línea para que el \textit{prompt} salga en la siguiente línea.

No lo hemos usado en el ejemplo, pero podemos \textbf{eliminar} archivos. Para
ello utilizamos la función \verb!remove!, cuya \textit{signature} es ésta:

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Declaración de la función \texttt{remove}},
label={lst:signatureRemove}]
int remove(const char *pathname);
\end{lstlisting}
\end{minipage}

Como puedes ver, simplemente recibe un nombre de archivo. Veamos un ejemlo
básico de programa que haga uso de ella: uno que reciba por argumento una ruta
y la elimine.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Ejemplo de programa que usa la función \texttt{remove}},
label={lst:exampleRemove}]
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char const *argv[]) {
    if (argc != 2) {
        printf("Usage: ./main <path to the file>");
    }

    int error = remove(argv[1]);

    if (error == 0) {
        return EXIT_SUCCESS;
    } else {
        return EXIT_FAILURE;
    }
}
\end{lstlisting}
\end{minipage}

Como puedes ver, el programa es muy sencillo, llamo a \verb!remove! con el
primer argumento (después del nombre del programa) y compruebo si ha funcionado
o no.

\subsection{Ejercicios de la sección}
\begin{exercises}[resume*]
\item Escribe un programa que reciba un número variable de números como
argumentos e imprima la descomposición en factores primos de todo ellos de este
modo: si los argumentos fueran: 10, 8, 55 y 103:

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{verbatim}
Factors of
10: 2, 5
8: 2, 2, 2
55: 11, 5
103: 103
\end{verbatim}
\end{minipage}

Se recomienda hacer control de errores comprobando que los argumentos son
números antes de utilizarlos, etc.
\item Escribe un programa que lea \textbf{por consola} una serie de palabras
y que sólo deje de leer cuando se introduzca <<!!>> como palabra. Después, debe
imprimir dichas palabras en orden aleatorio. La función \verb!rand! devuelve
un número aleatorio entre cero y el máximo entero positivo. Si quieres que
devuelva números aleatorios \textbf{distintos} cada vez debes ejecutar
\verb!srand(time(NULL));! al inicio de la función \verb!main!. Debes incluir la
cabecera \verb!time.h!.

\item Haz una función que lea dos archivos e \textbf{intercambie} su contenido,
escribe dicho programa de tal modo que no sea necesario alojar ninguno de los
dos archivos en memoria completamente. Para hcer esto puedes usar este proceso:
\begin{enumerate}
\item Copia los contenidos del primer archivo
en un archivo auxiliar en el directorio \verb!/tmp/!
\item Cierra el archivo que has copiado.
\item Ábrelo de nuevo con un modo que elimine su contenido.
\item Copia los contenidos del segundo archivo en el primero.
\item Cierra el segundo archivo.
\item Ábrelo de nuevo en un modo que elimine su contenido.
\item Copia los contenidos del archivo auxiliar en el primero.
\end{enumerate}

\item Escribe una función que reciba una palabra como argumento e indique
en qué posición (en bytes) dentro del archivo se encuentra la palabra. Sólo
tienes que dar la primera ocurrencia, si la palabra no se encuentra, devuelve
un número negativo. Haz un programa que, con esa función, reciba una ruta a un
archivo y una palabra e imprima el resultado de buscar la palabra en el archivo.
\end{exercises}
\section{Cómo escribir programas legibles y claros}
Todos los lenguajes de programación tienen un grado mayor o menor de
\textbf{legibilidad}. Se entiende por esto lo sencillo que es para programadores
que lean código en este lenguaje entender rápidamente qué está haciendo ese
código fuente. No es el lenguaje que se usa lo único que afecta a la
legibilidad, cómo se escriba en él afecta mucho a la legibilidad. Algunos
consejos para aumentar la legibilidad son:
\begin{enumerate}
\item Utiliza nombres de variables significativos, es decir, en vez de \verb!a!,
llama a las variables cosas como \verb!length!, \verb!days! o algo que tenga
que ver con su significado.
\item Utiliza nombres de función que expliquen lo que hace la función, del mismo
modo, utiliza nombres de argumentos que indiquen qué son.
\item Escribir el código tabulando cada bloque de código nuevo, etc.
\end{enumerate}

Además, en C hay dos herramientas de vital importancia para aumentar la
legibilidad del código que ahora te voy a presentar. Una es la palabra
reservada \lstinline[style=C]!typedef!. Esta palabra reservada nos permite
\textbf{darle nombre a un tipo de dato}. Es decir, nos permite poner otros
nombres a tipos que ya existieran. Uno de los usos más prácticos de él es que
nos permite definir un tipo con una sola palabra para referirnos a una
estructura, así nos ahorramos el hecho de escribir \verb!struct mystruct_s!,
no me dirás que no es un alivio después de tantos programas llenos de la palabra
\verb!struct!. Veamos un programa ejemplo de esto:


\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Definición de un tipo a partir de una estructura},
label={lst:structTypeDefinition}]
#include <stdio.h>

struct point_s {
    double x;
    double y;

};

typedef struct point_s point_t;

int main(void)
{
    point_t p = {.x = 3.3, .y = 1.1};
    struct point_s q = { 1,3 };
}
\end{lstlisting}
\end{minipage}

Esta sería la sintaxis más explícita para hacer esto, hay otra alternativa que
veremos ahora.
En las líneas 1 a 4 no hay nada nuevo, simplemente declaramos la estructura,
es la línea 6 la que es clave, como puedes ver, usamos la palabra
\verb!typedef! para definir que el tipo \verb!struct point_s! se va a llamar
ahora también \verb!point_t!. Nota que, como se ve en la línea 14, podemos
seguir usando el nombre antiguo de los tipos. Todo sea dicho, salvo que quieras
expresar un significado distinto, es lo mejor usar siempre el mismo nombre para los
tipos. Hay una manera más abreviada para hacer esto, de hecho, dos, puedes
combinar la sentencia \verb!typedef! en una única línea con la creación del
\verb!struct!. Al hacer esto, puedes elegir ponerle nombre a la estructura o no,
porque su nombre <<real>> será el que definas en el \verb!typedef!. Veámoslo:


\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Diferentes combinaciones de \texttt{struct} con \texttt{typedef}},
label={lst:structTypeCombo}]
#include <stdio.h>

typedef struct point_s {
    double x;
    double y;

} point_t;

typedef struct {
    point_t center;
    double radius;
} circle_t;

int main(void)
{
    struct point_s p = { 1.1, 2.3 };
    point_t        q = { 1.2, 3.4 };
    circle_t  origin = { .center = {.x = 0, .y = 0}, .radius = 1 };
}
\end{lstlisting}
\end{minipage}

Las dos declaraciones de estas dos estructuras son equivalente en el hecho
de que les asignan un nombre simple: \verb!point_t! y \verb!circle_t!, pero con
un matiz: la estructura punto conserva su nombre de \verb!struct!, por lo que
se podría utilizar para declarar variables de su tipo como se ve luego, al
\verb!struct! círculo no le hemos puesto nombre de estructura, sólo lo hemos
usado para definir un tipo. Esto es más simple, pero tiene un problema, cuando
haces esto y el compilador necesita decirte que ha habido un error, será
distinto dependiendo de la técnica que utilices. Con la estrutura
\verb!circle_t!, si declaramos una función que recibe un argumento de este tipo
y la llamamos con un tipo distinto, provocando un error, el mensaje del
compilador será:

\begin{lstlisting}[style=terminalStyle]
main.c:14:18: note: expected 'circle_t' {aka 'struct <anonymous>'} but argument is of type 'int'
   14 | int foo(circle_t c){
\end{lstlisting}

Como puedes ver, te dice el nombre que tiene el tipo, y después intenta
explicarte qué tipo era originariamente, el problema es que como hemos definido
la estructura sin nombre, no tiene nada que decirnos, es un \verb!struct!
anónimo. Y te estarás preguntando que todo esto cómo puede ser, bueno, es porque
en C puedes declarar estructuras sin nombre con una variable para usarlas
y tirarlas. Te lo voy a enseñar, pero es algo que no he visto en código
profesional, así que, como el \verb!goto!, interioriza que existe, pero sería
mejor que no lo usaras.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Estructura anónima y efímera},
label={lst:anonymousStruct}]
#include <stdio.h>


int main(void)
{
    struct { double x; double y; } temporal_point = { .x = 1, .y = 2 };
    printf("Esto es un punto temporal que está en [%1.2f, %1.2f]\n", temporal_point.x, temporal_point.y);
}
\end{lstlisting}
\end{minipage}

Es por eso que podemos definir \verb!struct! que no tienen nombre y usar ese
\verb!struct! anónimo para definir un tipo. Mi consejo es que siempre le pongas
nombre a los \verb!struct! para evitar que el error del compilador sea más
difícil de leer. Compara ese error del compilador que te he presentado antes con
éste para la estructura punto que sí tenía un nombre independiente del
\verb!typedef!.


\begin{lstlisting}[style=terminalStyle]
main.c:13:18: note: expected 'point_t' {aka 'struct point_s'} but argument is of type 'int'
   13 | void foo(point_t p){
      |          ~~~~~~~~^
\end{lstlisting}

Terminando ya con este tema: si te fijas, siempre que le he puesto nombre a una
estructura, lo he terminado con \verb!_s!, y siempre que he hecho un
\verb!typedef!, lo he terminado con \verb!_t!. Esto es una convención, es decir,
es algo que los programadores hacemos por tradición, pero no es obligatorio,
ni el compilador ni ningún analizador de código te dirán que esto está mal
(salvo que, claro, los hayas configurado para seguir la convención). El subfijo
\verb!_s! es menos importante, pero sí te recomiendo encarecidamente que
termines todos los tipos que definas con \verb!typedef! en \verb!_t!, primero:
porque es muy común, lo hace casi todo el mundo y, segundo: porque los editores
entienden que cualquier identificador (nombre, vaya), que termina en \verb!_t!
es un tipo, y lo utilizan para darte pistas sobre qué es cada cosa, por ejemplo,
los editores de texto colorearán todos los identificadores terminados en
\verb!_t! del color de los tipos en ese editor.

Aparte de esta utilidad tan cómoda para nosotros, hay otra, sirve para renombrar
tipos básicos, por ejemplo, podemos renombrar el \verb!char! sin signo como
\verb!byte_t!. Así si utilizamos nuestro programa para manejar listas de bytes
podemos usar este tipo y el lector de nuestro código sabrá de qué estamos
hablando.


\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Redefinición de un tipo básico},
label={lst:typedefBasicType}]
#include <stdio.h>

typedef unsigned char byte_t;

void print_byte(byte_t b) {
    byte_t current_byte = 128;
    for (int ii = 0; ii < 8; ++ii) {
        printf("%d", (b & current_byte) != 0);
        current_byte /= 2;
    }
    printf("\n");
}

int main(void)
{
    print_byte(110);
}
\end{lstlisting}
\end{minipage}

Quizá no entiendas todo este código, la línea 8, concretamente, pero simplemente
observa cómo al utilizar un tipo concreto, se lee todo mucho mejor. Además,
nos ahorramos escribir \verb!unsigned! múltiples veces.
Del mismo modo que con el
modificador de signo, podemos definir tipos con el modificador constante, por
ejemplo: \verb!typedef const char letter_t!.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Ejemplo de definición de tipo a partir de un tipo constante},
label={lst:typedefConstType}]
#include <stdio.h>

typedef const char letter_t;

letter_t dictionary[] = { 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z' };

int pos_of_letter(letter_t l){
    for(unsigned int ii = 0; ii < sizeof(dictionary); ++ii){
        if(l == dictionary[ii]){
            return ii + 1;
        }
    }
    return -1;
}

int main(void)
{
    letter_t l = 'f';
    printf("%c es la letra número %d del diccionario.\n", l, pos_of_letter(l));
}
\end{lstlisting}
\end{minipage}

Aunque esto es posible, en general la constancia es mejor dejarla
\textbf{explícita}, es decir, definir tipos para lo que necesites, pero
escribir el modificador \verb!const! cuando sea necesario, en vez de ocultarlo
detrás del tipo redefinido.

<<Y el más difícil todavía>> decían los maestros de ceremonias de los antiguos
circos cuando los trapecistas o los payasos realizaban el truco final. Con
\verb!typedef! este truco final es que, como los arrays de distintas dimensiones
son tipos distintos, puedes definir un tipo a partir de un tipo array. ¿Qué
utilidad tiene esto? A veces un conjunto de cosas de un tamaño concreto es un
concepto en sí mismo. Dos personas juntas son un matrimonio, siete días son una
semana y una mano tiene cinco dedos. La sintaxis de esto es un poco distinta a
la que podrías pensar, pongo el ejemplo y explico por qué rápidamente.


\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Definición de un tipo personalizado a partir de un array},
label={lst:typedefArrayType}]
#include <stdio.h>

typedef unsigned char pixel_t[3];

int main(void)
{
    pixel_t pixel = { 125,33,129 };
    printf("Este pixel tiene los valores: Rojo = %hu, Verde = %hu, Azul = %hu\n", pixel[0], pixel[1], pixel[2]);
}
\end{lstlisting}
\end{minipage}

Como puedes ver, \verb![3]! se pone a la derecha del nombre del nuevo tipo, en
vez de a la izquierda, que sería lo intuitivo. Simplemente recuérdalo si quieres
hacer esto. De todos modos, al igual que con la constancia, que un tipo sea
un array es algo que es recomendable dejar explícito.

La otra herramienta para añadir significado a tus programas, semántica, es
el \verb!enum!, o tipo enumerado. Este es un tipo en C que nos permite asignar
números correlativos automáticamente a nombres, los ejemplo clásicos (tan
clásicos que casi son manidos) son los siguientes: días de la semana,
meses del año, colores del arcoíris... La utilidad de esto es que podemos
codificar fácilmente conjuntos de nombres como estos a números y utilizarlos
para iterar, para indexar arrays, etc. Veamos el ejemplo de los días de la
semana.


\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Ejemplo básico de tipo enumerado},
label={lst:BasicEnum}]
#include <stdio.h>

enum week_days {
    MONDAY,
    TUESDAY,
    WEDNESDAY,
    THURSDAY,
    FRIDAY,
    SATURDAY,
    SUNDAY
};

int main(void)
{
    printf("Hoy es: %d\n", SATURDAY);
}
\end{lstlisting}
\end{minipage}

Si compilas y ejecutas esto verás que imprime <<Hoy es: 5>>. Esto es porque
cuando escribes un enumerado así, el primer elemento recibe el valor cero, el
siguiente uno, y así sucesivamente, en este caso de cero a seis.
Y los enumerados pueden dar más de sí los combinas con arrays de tipos que
ayuden a añadir la semántica, observa:


\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Enum combinado con array de nombres},
label={lst:EnumWithNames}]
#include <stdio.h>

enum week_days {
    MONDAY,
    TUESDAY,
    WEDNESDAY,
    THURSDAY,
    FRIDAY,
    SATURDAY,
    SUNDAY
};

const char* WEEK_DAYS_NAMES[] = { "lunes","martes","miércoles","jueves","viernes","sábado","domingo" };

int is_today_weekend(int day){
    return day == SUNDAY || day == SATURDAY;
}

int main(void)
{
    for(int ii = MONDAY; ii <= SUNDAY; ++ii){
        if(is_today_weekend(ii)){
            printf("¡Es fin de semana!\n");
        }else{
            printf("No es fin de semana.\n");
        }
    }
}
\end{lstlisting}
\end{minipage}

Como puedes ver, tener el tipo enumerado nos permite que los programas sean
mucho más legibles, que es lo que queríamos, porque como puedes ver, el bucle
se lee como <<siendo \verb!ii! LUNES, hasta que sea igual a DOMINGO, si
\verb!ii! es un fin de semana, imprime que lo es, si no, no>>. Habrás notado que
tanto para \verb!ii! como para la declaración de la función utilizo el tipo
\verb!int!. Esto es porque <<por dentro>> un tipo enumerado es un tipo entero,
pero para escribir las cosas más claramente, podemos definir un tipo enumerado
como definimos un tipo a partir de un \verb!struct!.

Para ver que la legibilidad el código ha aumentado, mira cómo en la
comprobación se puede ver que se lee como <<si el día es SÁBADO o DOMINGO,
es un fin de semana>>. Pero el \verb!enum! tiene más flexibilidad, podemos
definir el valor de cada etiqueta, o, esto es más útil: definir el valor de la
primera, y las siguientes tomarán el valor correlativo correspondiente. Voy
a poner en un mismo programa un ejemplo de ambas cosas, los días de la semana
y los meses del año. El siguiente programa aúna todas las posibilidades
anteriores:


\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Ejemplo final de enumerados},
label={lst:finalEnums}]
#include <stdio.h>

typedef enum week_days_e {
    MONDAY = 2, TUESDAY = 4, WEDNESDAY = 6, THURSDAY = 8, FRIDAY = 10, SATURDAY = 12, SUNDAY = 14
} week_days_t;

typedef enum months_e {
    JANUARY = 1, FEBRUARY, MARCH, APRIL, MAY, JUNE, JULY, AUGUST, SEPTEMBER, OCTOBER, NOVEMBER, DECEMBER
} months_t;

typedef enum seasons_e {
    SPRING, SUMMER, FALL, WINTER
} seasons_t;

const char* season_names[] = { "primavera", "verano", "otoño", "invierno" };
const char* month_names[] = { "NOT USED", "enero","febrero","marzo","abril","mayo","junio","julio","agosto","septiembre","octubre","noviembre","diciembre" };
int is_today_weekend(week_days_t day) {
    return day == SUNDAY || day == SATURDAY;
}

seasons_t season(months_t m) {
    if (m >= MARCH && m <= MAY) {
        return SPRING;
    }
    else if (m >= JUNE && m <= AUGUST) {
        return SUMMER;
    }
    else if (m >= SEPTEMBER && m <= NOVEMBER) {
        return FALL;
    }
    else {
        return WINTER;
    }
}

int main(void)
{
    for (months_t ii = JANUARY; ii <= DECEMBER; ++ii) {
        printf("Estamos en %10s y es %s\n", month_names[ii], season_names[season(ii)]);
    }
}
\end{lstlisting}
\end{minipage}

He tenido que declarar los \verb!enum! en una línea para que quepa en esta
página, pero eso no afecta. Mira bien como en el caso de los días de la semana
he hecho que cada uno valga un valor arbitrario. Además, en iniciado los meses
en el valor uno, no he definido valor del resto, por lo que se sucederán
valiendo dos, tres... Esta definición tiene una implicación, en el
caso de los días de la semana ya no puedo escribir el mismo
bucle \verb!for! para iterar sobre
ellos \textbf{porque ahora sus valores no son correlativos},
sino que son arbitrarios. Además, si miras el array de
los nombres de los meses del año, he tenido que poner al principio una
posición que no se usa para que encaje.

Al contrario que \verb!typedef!, los \verb!enum! son muy situacionales, aunque,
como el \verb!do-while! o el \verb!switch!, cuando se da dicha situación son
la herramienta ideal.
\subsection{Estilo de código}
Ahora que ya hemos hablado de muchas herramientas del lenguage, es hora de que
establezcamos algunas reglas para escribir nuestros programas que he dejado
implícitas y que me gustaría empezar a escribir aquí. En este epígrafe vamos
a ver cómo deben escribirse los programas más allá de que funcionen o, incluso,
de que sean eficientes. Cuando uno trabaja en programación, hay muchos momentos
en que vas a estar más tiempo leyendo el código de otros programadores que
escribiendo código nuevo. Y, consecuentemente, debes escribir tu código con la
intención de que sea claro para otros programadores que lo lean. Vamos a ver
un ejemplo de cómo un fragmento de código puede ser trivial o indescifrable
simplemente cambiando cómo está escrito.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Ejemplo de programa escrito con un mal estilo},
label={lst:badStyle}]
#include <stdio.h>
#include <stdlib.h>
int main(void)
{
int** a=malloc(10*sizeof*a);
for(int ii=0;ii<10;++ii){
(*(a+ii))=mailloc(5*sizeof**a);
for(int jj=0;jj<5;++jj){
(*(a+ii))[jj]=10*ii+jj;
}
}
for(int ii=0;ii<10;++ii){
for(int jj=0;jj<5;++jj){
printf("%d ",(*(a+ii))[jj]);
}printf("\n");
}
for(int ii=0;ii<10;++ii){
free(*(a+ii));
}
free(a);
}
\end{lstlisting}
\end{minipage}

Intenta leer el programa \ref{lst:badStyle} y dime si sabes qué hace. Es probable
que, después de unos cinco o diez minutos, descifres que simplemente reserva un
vector de vectores, lo rellena, lo imprime y lo libera. Como puedes ver, sin
espacios, sin las líneas tabuladas (tabular las líneas es poner espacios delante
para que queden desplazadas a la derecha), sin líneas en blanco entre
estructuras de control y escribiendo algunas líneas al lado de una llave,
es imposible de
leer. Además, no hemos declarado variables o macros que nos ayuden a entender
si el mismo valor es así por casualidad o por simboliza lo mismo. Además, he
mezclado arbitrariamente operadores distintos para acceder al vector. Si
aplicamos una serie de mejoras a cómo está estrito el código, quedaría así:

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Ejemplo de programa escrito con un buen estilo},
label={lst:goodStyle}]
#include <stdio.h>
#include <stdlib.h>

typedef unsigned int uint_t;

int main(void)
{
    const uint_t ROWS    = 10;
    const uint_t COLUMNS = 5;
    int** matrix = malloc(ROWS * sizeof(*matrix));

    for (uint_t ii = 0; ii < ROWS; ++ii) {
        matrix[ii] = malloc(COLUMNS * sizeof(**matrix));
        for (uint_t jj = 0; jj < COLUMNS; ++jj) {
            matrix[ii][jj] = ROWS * ii + jj;
        }
    }

    for (uint_t ii = 0; ii < ROWS; ++ii) {
        for (uint_t jj = 0; jj < COLUMNS; ++jj) {
            printf("%d ", matrix[ii][jj]);
        }
        printf("\n");
    }

    for (uint_t ii = 0; ii < ROWS; ++ii) {
        free(*(matrix + ii));
    }
    free(matrix);
}
\end{lstlisting}
\end{minipage}
\newpage

Como pudes ver, hemos introducido varias mejoras: los operadores están rodeados
por espacios, las utilizaciones de \verb!sizeof! siempre llevan paréntesis para
que sea más legible, hemos utilizado dos macros para simbolizar el tamaño del
vector en vez de escribir cinco y diez todo el rato en el código,
hemos utilizado siempre la misma manera de acceder a los
vectores y, finalmente, hemos escrito cada instrucción
en una línea con la tabulación correcta. Veamos qué pasos o
principio hay que seguir para escribir código que sea entendible.

\subsubsection{Tabulación}
En la introducción de esta sección hemos hablado de la tabulación, y te he dicho
que es anteponer a algunas líneas espacios para que salgan desplazadas a la
derecha. Es una de las cosas que debes hacer obligatoriamente si quieres que te
tomen en serio como programador, pero hay varias variaciones sobre cómo puedes
hacerlo. La primera decisión que debes tomar es si tabulas con espacios o con
tabuladores. Un tabulador es un carácter especial que indica al editor de texto
que alinee las cosas en la siguiente columna de la pantalla. La ventaja de
tabular con ellos es que puede configurar el editor para que muestre el
tabulador como el número de espacios que más te guste. Este carácter se inserta
con la tecla tabulador, que es la que tiene este símbolo:\tiny
$
\matrix{
    \left|\leftarrow\right.\cr
    \left.\to\right|
}
$
\normalsize .
La otra opción es tabular con espacios, es decir, en vez de usar este carácter
especial, usaremos un número determinado de espacios. En general, no pulsas
varias veces la tecla espacio, sino que configuras tu editor de texto para que,
al pulsar tabulador, se introduzca el número de espacios concreto.

Esta es una de las cosas que hará que los programadores se peleen entre ellos
como fanáticos religiosos o hinchas de un equipo de balompié, por lo que la
elección es tuya. Sin embargo; mi modesta opinión es que los espacios son
mejores porque permiten alinear el código de líneas largas, por ejemplo, mejor.
Además, permiten asegurarte de que el código escrito se verá bien en todos los
entornos, porque no hay ambigüedad sobre cuánto mide un espacio.

La norma general para tabular es que los bloques de código deben tener sus
instrucciones tabuladas un nivel más que allí donde estén definidos. Puedes
observar que esto es así en todos los fragmentos de código que he incluido como
ejemplos. Cada nivel de tabulación debe ser igual al anterior, es decir, si has
elegido cuatro espacios, debes tabular siempre con cuatro
espacios, nunca mezclar, y si utilizas tabuladores, un nivel
de tabulación debe ser siempre un único tabulador.

La tabulación también entra en juego cuando una línea es demasiado larga.
Te preguntarás quizá qué sentido tiene ponerle un límite a la longitud de las
líneas si estamos usando editores de texto que nos permiten que éstas sean tan
largas como queramos. Esto es así por varios motivos: las líneas demasiado
largas suelen ser más difíciles de interpretar, impiden que tengas varios
archivos abiertos a la vez y, además, en el improbable, pero posible caso de
que quisieras imprimir tu código, sería difícil que quedase bien. El último
caso no te afecta a ti, pero me ha afectado a mí en muchos de los programas
que he escrito como ejemplos. La longitud de una líneas de código en C
normalmente viene siendo de unos ochenta caracteres. Para que te hagas una idea,
los fragmentos que he insertado en este manual contienen unos 71.

Bueno, y qué pasa si la línea que estamos escribiendo contiene más de esos
caracteres. Pues que hay maneras de escribir la línea de un modo distinto.
Esta manera cambia según dónde se dé el problema, claro, así que vamos a ver
los sitios más habituales y cómo arreglarlo.

El primer caso es cuando se utilizan funciones con muchos argumentos, o cuyos
nombres son muy largos, un ejemplo clásico de esto son las llamadas a
\verb!printf!, pero se puede dar con otras funciones. Por ejemplo: imagina un
programa que imprime un mensaje un poco largo para el usuario, podría quedar
así:

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Impresión larga},
label={lst:longprint}]
#include <stdio.h>
int main(void)
{
    printf("Este es un mensase importante, por favor, mantente hidratado, bebe agua\n");
}

\end{lstlisting}
\end{minipage}
Como puedes ver, la línea no cabe en la pantalla, lo que se hace en estos
casos es separa la constante de \textit{string} en varias. Siempre que las
escribamos juntas o separadas sólo por espacios y líneas nuevas, C las tomará
como una continua. Veamos cómo quedaría:

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Impresión larga},
label={lst:longprint}]
#include <stdio.h>
int main(void)
{
    printf("Este es un mensase importante, "
           "por favor, mantente hidratado,"
           " bebe agua");
}
\end{lstlisting}
\end{minipage}
Nota que, aunque las separemos, debemos incluir los espacios entre palabras.
Cuando se dividen así cadenas de texto, se suelen poner todas al mismo nivel
de tabulación.

El siguiente ejemplo es una función con muchos argumentos, o con argumentos
muy largos. Imaginemos un programa tal que:

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Muchos argumentos},
label={lst:manyArgs}]
int main(int argc, char** argv)
{
    int list[] = {};
    int the_position = 10;
    int* res = insert_at(list, ARRAY_SIZE(list), 0, rand());
    print_array(res, ARRAY_SIZE(list) + 1);
    free(res);
}
\end{lstlisting}
\end{minipage}

Como no me interesa lo que hace el programa, sino sólo el formato, no voy a
poner la definición de las funciones, pero la función \verb!insert_at! crea
un array nuevo con el elemento dado como último argumento en la posición que
indica el segundo. Si quisiéramos que la línea donde se llama a esa función
fuera separada en varias, lo haríamos generalmente entre los argumentos de la
llamada, veamos algunos estilos:

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Cómo acortar líneas con muchos argumentos},
label={lst:manyArgsShorting}]
//1
int* res = insert_at(list, ARRAY_SIZE(list),
                                        0, rand());

//2
int* res = insert_at(list,
                     ARRAY_SIZE(list),
                     0,
                     rand());

//3
int* res =
    insert_at(list, ARRAY_SIZE(list), 0, rand());
\end{lstlisting}
\end{minipage}

En el primer ejemplo hacemos un único corte en un argumento y ponemos
el resto de la línea un nivel de tabulador por detrás de donde estaría.
Este método es útil cuando nos pasamos del límite por pocos caracteres.
El siguiente es mi preferido y básicamente pone cada argumento en una línea
y al mismo nivel. En el último, nos aprovechamos de que estamos asignando el
resultado de la llamada, utilizamos esta operación para hacer el corte,
con una nueva línea y un nivel de tabulador hacia adentro. Los tres se pueden
combinar como quieras, pero a mí me gusta el segundo porque impide que
queden alineaciones extrañas.

La siguiente localización es la declaración de una función con muchos
argumentos, por ejemplo, una función que imprima una fecha dado el año, el
mes y el día y un argumento boleano que nos diga si lo hacemos en ese orden
y en el inverso:

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Acortamiento de una declaración de función},
label={lst:functionShorting}]
void print_date(unsigned short day,
                unsigned char  month,
                unsigned int   year,
                int            order);
\end{lstlisting}
\end{minipage}

En estos casos se suelen poner todos los argumentos en una línea distinta,
además, me he molestado en alinear los nombres de los argumentos para
que se cree una especie de tabla, lo que facilita la lectura cuando se deben
acortar así las listas de argumentos.

En otros sitios donde se pueden dar estas situaciones es en listas de varios
tipos, estoy usando la palabra listas aquí a la ligera, me refiero a
las sucesiones de cosas separadas por comas que van entre llaves:
listas de inicialización especialmente, en general puedes aplicar lo mismo que
con los argumentos en el método primero de cuando acortamos una llamada a
función.

\subsubsection{Espaciado entre símbolos}
En términos generales la mayoría de los espacios en blanco que pondremos en
nuestros programas son para facilitar esta legibilidad, porque C es un lenguaje
diseñado para que los espacios en blanco no importen. Normalmente,
los operadores matemáticos, lógicos o de cualquier tipo deben ir rodeados de
espacios, es decir: se prefiere \lstinline[style=C]!a = b + 10;!
que \lstinline[style=C]!a=b+10;!,
rodea el operador de asignación y la suma de espacios. Las excepciones a esto
son los operadores unarios (la negación lógica, el asterisco de
desreferenciación de punteros, etc.). Además, en las declaraciones, el asterisco
debe estar siempre pegado o al tipo de dato, o al nombre de la variable. Es una
cuestión de estilo, pero yo recomiendo que se adhieran los asteriscos al nombre
de la variable, o, en su caso, del argumento de la función.
Es decir:
\begin{enumerate}
\item Espacia los operadores: \lstinline[style=C]!int var = a * 3 + ii!
\item Los asteriscos deben ir pegados a las variables a las que afectan, en
declaraciones y desreferenciaciones:
\begin{enumerate}
\item \lstinline[style=C]!double *var1;!
\item \lstinline[style=C]!int function(int *arg1, void **arg2);!
\item \lstinline[style=C]!int a = *ptr1 + *ptr2;!
\end{enumerate}
\end{enumerate}

Además, después de todas las comas que haya en listas de inicialización,
de los puntos y coma de los bucles \verb!for! o de los argumentos de una función
debe haber una coma y un espacio debe rodear los paréntesis de estructuras
de control (nota: llamada a función no es una estructura de control), es decir:

\begin{enumerate}
\item \lstinline[style=C]!for (int i = 0; i < 10; ++i)!\verb! {!
\item \lstinline[style=C]!int list[] = {1, 2, 3, 4, 5, 6};!
\item \lstinline[style=C]!int res = pow(var1, var2);!
\end{enumerate}

\subsubsection{Estilo de las llaves}
Hay varias combinaciones de estilo de las llaves que definen los bloques de
código que componen los cuerpos de bucles, condicionales y demás estructuras
de control. Hay dos estilos fundamentales: llaves K\&R y Allman.
Las primeras se ponen en la misma línea que la estructura de control que
las necesita, es decir:

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Ejemplo de llaves estilo K\&R},
label={lst:KRBrackets}]
int main(void) {
    return 0;
}
\end{lstlisting}
\end{minipage}

Las llaves Allman se ven así:

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Ejemplo de llaves estilo Allman},
label={lst:AllmanBrackets}]
int main(void)
{
    return 0;
}
\end{lstlisting}
\end{minipage}

Hay otros estilos que combinan las tabulaciones de maneras distinta con las
llaves, pero estas son las más importantes. Una manera que se puede ver habitualmente
es que
las definiciones de funciones (que son principalmente bloques de código de
primer nivel) utilicen el estilo Allman, mientras que los bloques internos a
éstas usen el estilo K\&R. Lo más importante es que utilices un estilo o una
combinación racional de ellos y lo mantengas en todo el proyecto. En caso de
añadir código a una base existente, aplica la vieja regla de: <<donde fueres
haz lo que vieres>>, es decir, sigue el estilo que sigan en el proyecto en el
que colabores.

\subsubsection{Declaración de variables, estructuras y enumerados}
Hasta ahora, cada declaración de variable la hemos hecho en una línea distinta,
y cada miembro de una estructura también. Esto no es necesario, se pueden
declarar todas las variables de un mismo tipo en la misma línea, e incluso
inicializarse. Veamos un ejemplo sencillo. Vamos a reescribir el programa
\ref{lst:bidimensionalVector}: \nameref{lst:bidimensionalVector}, pero omitiré
parte de él porque no ha cambiado.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Declaración de variables en una misma línea},
label={lst:singleLineDeclaration}]
#include <stdio.h>
#include <stdlib.h>

int main(void)
{
    int rows = 10, columns = 5, **matrix = NULL;
    matrix = malloc(rows * sizeof(*matrix));

    for (int ii = 0; ii < rows; ++ii) {
    //resto del programa...
\end{lstlisting}
\end{minipage}

Como puedes ver en la línea 6, podemos declarar variables del mismo tipo
en la misma línea, separando sus nombres por comas. Además, podemos incluso
inicializarlas. Si vas a declarar punteros junto a variables de tipos no
puntero, el asterisco que indica que esa variable es un puntero va pegado al
nombre de la variable, como puede ver con \verb!matrix!. En el caso de la
inicialización del puntero, podría ir en la misma línea, pero lo he movido
a otra para impedir que la línea sea excesivamente larga.

En las estructuras se puede hacer lo mismo, es decir, declarar todos los
miembros del mismo tipo en la misma línea, con los enumerados también se puede
hacer, pero es convención que cada identificador de una estructura vaya en
su propia línea. Veamos un ejemplo de ambas cosas:

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Declaración de miembros de un \textit{struct} en una sola línea},
label={lst:singleLineDeclarationStruct}]
struct point_s {
    double x, y;
}

enum week_days {
    MONDAY,
    TUESDAY,
    WEDNESDAY,
    THURSDAY,
    FRIDAY,
    SATURDAY,
    SUNDAY
}
\end{lstlisting}
\end{minipage}

\subsubsection{Convenciones de nombres}
Una de las cosas más importantes es que debes evitar el uso de los llamados
\textbf{números mágicos}. Éstos son los valores literales que se incluyen en
el código y que no se explican, se asignan a una variable y, en el peor de los
casos, se usan en muchas partes del código. Si rescatas el ejemplo de mal código
del programa \ref{lst:badStyle}, verás que nunca defino variables o macros para
definir las columnas y filas de la matriz. Esto lo hago intencionadamente,
porque es una mala práctica. Como puedes ver en el ejemplo de buen código,
lo primero que hago es definir macros para estos conceptos, y, además, las
defino con un cásting añadido a un tipo concreto, para controlar de qué tipo
son, y las encierro entre paréntesis, para evitar los problemas que vimos en
la sección sobre macros.
En general, debes hacer esto, definir macros, variables y constantes para todo
concepto o valor que haya en tu código, \textbf{especialmente si aparece varias
veces}.

Además, hay una serie de convenciones que vamos a reunir aquí sobre los nombres.
Cuando te expliqué el nombre que se le podía poner a una variable, te dije de
que existían el \textit{camel case} y el \textit{snake case} para escribir
nombres con varias palabras. En C lo normal es usar el segundo, es decir:
\verb!my_var!, así que en general será el que me hayas visto aplicar. Por otro
lado, las constantes deben estar escritas en mayúscula, es decir:
\lstinline[style=C]!const int LENGTH = 10;! es preferible a
\lstinline[style=C]!const int length = 10;!, las macros siguen la misma
convención como ya habrás podido notar.

En general, los tipos terminan en \verb!_t!, como ya comentamos, ya sean estos
renombramiento de tipos básicos o creación de estructuras. A los enumerados
se les puede omitir su nombre de enumerado, es decir, es normal escribir:

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Ejemplo de tipo enumerado con typedef},
label={lst:typedefEnum}]
typedef enum {
    MONDAY,
    TUESDAY,
    WEDNESDAY,
    THURSDAY,
    FRIDAY,
    SATURDAY,
    SUNDAY
}week_days;
\end{lstlisting}
\end{minipage}

Las funciones deben tener nombres descriptivos, del mismo modo que sus argumentos,
por ejemplo, es preferible:

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Ejemplo de función descriptiva},
label={lst:descriptiveFunction}]
int multiply_array_scalar(int *array, int array_size, int scalar);
\end{lstlisting}
\end{minipage}

a

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Ejemplo de función no descriptiva},
label={lst:nonDescriptiveFunction}]
int multi(int *a, int s, int n);
\end{lstlisting}
\end{minipage}

En el primer caso queda claro qué hace la función y qué es cada argumento
con un golpe de vista. En el segundo habría que acudir a la implementación
para saber qué hace.


\section{Lo que hay detrás de la compilación}
Hasta ahora hemos dicho que crear un binario a partir de un archivo de código
fuente se llama compilar. Si bien esto es una expresión correcta, no es del todo
cierto. Hay varios procesos involucrados en lo que llamamos compilación:
\begin{enumerate}
\item Preprocesado: Prepara el código fuente para ser compilado, esto incluye
eliminar comentarios, expandir macros, ejecutar directivas y eliminar saltos de
línea.
\item Compilado: Crea el binario de cada archivo de código fuente que se utilice
en el proyecto.
\item Enlazado: Genera los binarios ejecutables propiamente dichos, para ellos
utiliza los binarios del paso anterior y crea enlaces entre ellos, ya sea
juntándolos en el mismo archivo o simplemente indicando dónde están los que
necesita.
\end{enumerate}

Esto introduce muchos conceptos nuevos que explicaré a continuación, pero lo
principal es que esta va a ser la sección en que aprendas a hacer programas con
más de un archivo de código fuente. Esto es útil porque, como has visto, en el
momento en que un programa se hace un poco complejo, empieza a hacerse confuso
subir y bajar por el fichero de código buscando lo que necesitas o modificando
cosas. Por esto, todo proyecto serio de programación en C contiene varios
archivos de código fuente. Algunos proyectos muy grandes pueden llegar a tener
hasta decenas de miles o cientos de miles de archivos de código fuente.
Voy a explicar ahora los tres procesos.

\subsection{Preprocesado}
El preprocesado es la etapa que se realiza más discretamente, porque todo
archivo de código fuente que se compile pasa primero por ella sin que tengamos
que hace nada. En la introducción de esta sección he comentado que se realizan
varias tareas, siendo la primera la eliminación de comentarios. Ya es hora de
que te explique qué son los comentarios. Un comentario es una herramienta que
nos permite introducir cualquier texto dentro del códido de tal modo que podamos
explicar cosas, apuntar datos o cosas así. Veamos un ejemplo. Voy a incluir
comentarios en el código del
programa \ref {lst:pointStruct}: \nameref{lst:pointStruct}


\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Ejemplo de definición de estructura punto},
label={lst:comments1}]
#include <stdio.h> //for printf
#include <math.h>  //for sqrt

//Definimos la estructura punto bidimensional.
struct point_s {
    double x;
    double y;
};

int main(void)
{
    struct point_s A;
    struct point_s B;

    A.x = 1.1;
    A.y = 3.2;
    B.x = 2.3;
    B.y = 5.4;

    double diff_x = A.x - B.x;
    double diff_y = A.y - B.y;
    /*Recordemos que la distancia
    entre dos puntos es la raíz
    cuadrada de la suma de los cuadrados
    de la diferencia entre sus coordenadas*/
    double distance = sqrt(diff_x * diff_x + diff_y * diff_y);

    printf("P1 : [%f, %f]\n", A.x, A.y);
    printf("P1 : [%f, %f]\n", B.x, B.y);
    printf("Distance: %f\n", distance);
}
\end{lstlisting}
\end{minipage}

Como habrás adivinado, los textos que salen en verde son los comentarios. Se ve
claramente que son cualquier texto que queramos, y que no tienen nada que ver
con código en C. El preprocesador los eliminará antes de pasarle el programa al
compilador. Hay dos tipos de comentarios:
\begin{enumerate}
\item Comentarios de una línea: Se empiezan con \verb!//!, son comentarios que
hacen que el preprocesador elimine todo después de las barras inclinadas, éstas
incluidas. Se pueden poner varios en líneas correlativas.
\item Comentarios multilínea: Empiezan por \verb!/*!, y \textbf{terminan con}
\verb!*/!. El comentario ignorará saltos de línea y cualquier carácter que
haya hasta que se encuentre el final, como puedes ver en el ejemplo.
\end{enumerate}

En general, puedes poner los comentarios que consideres oportunos, sobre todo,
se comentan funciones que tengan algoritmos difíciles o cosas que no sean
evidentes. Como nota, al ser el inglés la \emph{lingua franca} de esta época y
estar además los lenguajes de programación basados en él, los comentarios del
código se hacen siempre en inglés en entornos profesionales.


El siguiente paso es la expansión de macros. Y te estarás
preguntando qué es una macro. Una macro es una constante simbólica que definimos
en el código y que el preprocesador sustituirá por su valor allá donde la
escribamos. Veamos un ejemplo.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Directiva \texttt{define}},
label={lst:defineDirective}]
#include <stdio.h>

#define LIST_LENGTH 100

int main(void)
{
    int list[LIST_LENGTH];
    for(int ii = 0; ii < LIST_LENGTH; ++ii){
        list[ii] = ii;
    }
}
\end{lstlisting}
\end{minipage}


En la línea tres puedes ver la única novedad que tenemos aquí, la directiva
\verb!define!. Las directivas empiezan con almohadilla (\verb!#!). Y ya vamos
desvelando uno de los misterios que más tiempo llevan en nuestros programas, las
líneas que contienen \verb!#include! son, efectivamente, una directiva. Pero
hablemos de la directiva \verb!#define!. Esta directiva define (lógico, claro)
un símbolo que será sustituido por otro por el preprocesador, en este caso,
hemos definido que allá donde escribamos \verb!LIST_LENGTH!, el preprocesador
lo sustiuirá por \verb!100!. Un uso común para esto es, como puedes ver,
definir el tamaño de arrays. ¿Quiere decir esto que cada array debe tener
su macro correspondiente? No, sólo si se va a usar en varios sitios o tiene
un significado, por ejemplo, el tamaño de una lista de pruebas que vas a
hacer al mismo código.

Como las macros se expanden \textbf{antes} de la compilación, sí que puedes
definir el tamaño de un array y la vez inicializarlo. Esto tiene una ventaja:
cuando inicializas un array, pero faltan elementos, el resto se rellena a 0
automáticamente, así que podemos escribir nuestros programas como:


\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Uso de \texttt{define} con arrays},
label={lst:defineArray}]
#include <stdio.h>

#define LIST_LENGTH 65536

int main(void)
{
    int list[LIST_LENGTH] = {};
    for(int ii = 0; ii < LIST_LENGTH; ++ii){
        if(list[ii] != 0){
            printf("Hay elementos que no son 0.\n");
            break;
        }
    }
}
\end{lstlisting}
\end{minipage}

Ya te expliqué que una variable no se podía usar para indicar el tamaño de un
array que inicializaras con una lista de inicialización
porque esa variable podía valer lo que fuera (el
compilador no puede saberlo, porque eso sólo se sabría al ejecutar el programa).
Quizás te preguntes si una variable constante, por ejemplo,
\verb!const int LENGTH=100;! podría valer. No, una variable marcada con
\verb!const! sigue siendo una variable, porque hay mecanismos, algunos normales
y otros producto de abusos del lenguaje C, que permiten que el valor de esa
variable cambie. Haz una prueba: compila y ejecuta ese programa de ejemplo
algunas veces (no compiles cada vez, sólo necesitas compilar si cambias el
código). Verás que jamás se imprime el mensaje. Ahora, elimina la inicialización
del array, deja la línea 7 como \verb!int list[LIST_LENGTH];! y después de
compilar verás que casi siempre se imprimirá. Esto es porque, recuerda, lo que
no inicializas tiene valores aleatorios.

Pero las macros tienen una potencia increíble, porque admiten argumentos.
Habrás notado que hay cosas que hacemos muy comúnmente, como por ejemplo hallar
el cuadrado de un número, para eso podemos invocar a la función \verb!pow!, lo
que implica compilar enlazando la biblioteca correspondiente, como vimos, o
escribiendo \verb!var*var!, con una macro, podemos hacerlo más legible.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Uso de macro con argumentos},
label={lst:macroWithArguments}]
#include <stdio.h>

#define SQUARE(a) a*a

int main(void)
{
    for(int ii = 0; ii < 10; ++ii){
        printf("%d^2 = %d\n", ii, SQUARE(ii));
    }
}
\end{lstlisting}
\end{minipage}

Como puedes ver, este programa funciona como se espera. Siendo esto así, ¿por
qué no se usan macros para todo? El primer motivo es que se pueden convertir
en un auténtico infierno para encontrar errores o problemas en tus programas.
Esto es porque, recuerda, no son más que un copiar y pegar automático. Imagínate
que hiciéramos un bucle con macros (cosa perfectamente posible), al final, ese
bucle se traduciría en tantas líneas como iteraciones tenga el bucle. Así que si
alguna de ellas es incorrecta, tienes que depurar sobre líneas que no existen ni
puedes ver porque sólo existen después del preprocesado. Además, al ser un
copiar y pegar automático, se pueden producir problemas porque no se comprueban
tipos ni se respetan preferencias de operadores por ser una sustitución
simbólica. Cambiemos un poco el programa anterior:

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Ejemplo de error por una macro},
label={lst:macroError}]
#include <stdio.h>

#define SQUARE(a) a*a

int main(void)
{
    for(int ii = 0; ii < 10; ++ii){
        printf("%d^2 = %d\n", ii, SQUARE(ii+1));
    }
}
\end{lstlisting}
\end{minipage}

Si lees este programa, pensaríamos que debería imprimir: 1, 2, 4, 9... Pero
no es lo que pasa, imprime: 1, 3, 5, 7, 9... Y esto es así porque esta macro
está mal escrita, haz el ejercicio de sustituir \verb!a! en la macro por
\verb!ii+1! mentalmente, verás que sale: \verb!ii+1*ii+1!. Eso no es lo que
querías escribir. La solución a esto es escribir \verb!a! entre paréntesis en la
macro, quedando \verb!#define SQUARE(a) (a)*(a)!, pero aunque en este caso sea
sencillo, sirva este ejemplo para demostrarte que las macros son peligrosas.
Puedes usar macros con argumentos, pero se recomienda que sea para cosas
sencillas, por ejemplo este cuadrado de un número, un valor absoluto, etc.

Además, hay una versión de las macros que pone como una cadena de texto
lo que se introduzca como argumento. Se hace con la almohadilla de nuevo,
veamos el ejemplo.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Uso de macros con cadenas de texto},
label={lst:macroText}]
#include <stdio.h>

#define PRINT_INT(a) printf(#a"=%d\n", a);

int main(void)
{
    for(int ii = 0; ii < 10; ++ii){
        PRINT_INT(ii);
    }
}
\end{lstlisting}
\end{minipage}

Como puedes apreciar, al poner \verb!#a! le estamos diciendo que sustituya
\verb!a! por \verb!"a"!. No te lo he dicho, pero dos cadenas de texto escritas
como literales, juntas, se convierten en una, es decir: \verb!"Hola"" Mundo"!
es equivalente a \verb!"Hola Mundo"!. Y después hemos escrito \verb!a! para que
la sustituya de manera normal. Estos serían los fundamentos más importantes
sobre las macros.

La siguiente directiva que nos importa es, por fin, la directiva \verb!include!.
Es la directiva que hemos usado para poder utilizar una variedad de funciones
como \verb"printf" o \verb!malloc!. Esto es por lo que hace la directiva:
incrusta el contenido de un archivo de código fuente en el tuyo. Sí, lo has
oído bien, cuando escribes \verb!#include <stdio.h>!, lo único que estamos
haciendo es pegar en este archivo de código los contenidos de un archivo
distinto, en este caso, \verb!stdio.h!. Es extraño que sea un archivo con
extensión \verb!.h!, si todos los programas los hemos escrito en un archivo
acabado en \verb!.c!. Esto es porque este archivo es un archivo de
\textbf{cabeceras}, en este tipo de archivo, del que veremos más adelante
ejemplos y te enseñaré a hacer, se escriben sólo definiciones, es decir:
declaraciones de funciones, declaraciones de variables globales, de tipos
nuevos...

Pero, de momento, puedes experimentar con esta directiva escribiendo estos
dos archivos: \verb!main.c!, el que ya teníamos, y \verb!other.c!. En el primero
escribe esto:

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Ejemplo de directiva \texttt{include}, archivo principal},
label={lst:include1}]
//main.c
#include <stdio.h>
#include "other.c"

int main(void)
{
    int a = 10;
    printf("a ahora vale: %d\n", a);
    multiply(&a, 2);
    printf("a ahora vale: %d\n", a);
}
\end{lstlisting}
\end{minipage}

Como puedes ver, al incluir \verb!other.c!, estamos usando comillas en vez de
los signos de menor que y mayor que. Esto es porque cuando a la directiva le
indicamos el nombre del archivo entre menor que y mayor que, los busca en los
directorios predefinidos que el sistema tiene para cabeceras. Si pones comillas,
los busca en donde está este archivo de código fuente que lleva la directiva
\verb!include!. Por ello, cuando utilices archivos que no estén en esos
directorios, debes tener esto en cuenta. En el archivo \verb!other.c! irá este
contenido:

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Ejemplo de directiva \texttt{include}, archivo incluido},
label={lst:include2}]
//other.c
void multiply(int* a, int b){
    *a *= b;
}
\end{lstlisting}
\end{minipage}

Si miras el contenido de ambos archivos, simplemente estamos <<sacando>> la
función a otro archivo y hemos usado la directiva para que desde el archivo
principal se escriba todo el contenido del segundo en el primero. No obstante;
una regla de oro es que nunca debes incluir archivos de código fuente, sino esos
archivos de cabecera que te presenté antes. Sin embargo;
para poder hacer esto, debemos primero ver los dos pasos siguientes de la
creación del binario.

Antes de llegar allí, sin embargo; quiero que veas un par de directivas muy
interesantes: \verb!ifndef!, \verb!ifdef! y
\verb!endif!, que siempre van juntas. Su nombre
es más o menos explicativo, pero se trata de lo siguiente, estas directivas
comprueban si una macro está definida, y si según esté o no, el código
entre \verb!ifdef/ifndef! y \verb!endif! se incluirá o no. Veamos un ejemplo
sencillo.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Uso de directivas \texttt{ifdef} e \texttt{ifndef}},
label={lst:ifdefAndIfndef}]
//main.c
#include <stdio.h>

int main(void)
{
#ifndef MY_MACRO
    printf("¡Hola mundo!\n");
#else
    printf("¡Adiós Mundo!\n");
#endif
}
\end{lstlisting}
\end{minipage}

Aquí puedes ver que usamos \verb!ifndef!, \verb!else! y \verb!endif!, creo
que es muy explicativo, pero simplemente, cuando \verb!MY_MACRO! no está
definida, el código que resulta del preprocesado imprimirá <<¡Hola, mundo!>>;
cuando sí lo está (en el \verb!else!), el código resultante
imprimirá <<¡Adiós Mundo!>>. Las macros se pueden definir desde la línea de
comandos a la hora de compilar (ten en cuenta que aquí ni siquiera nos
interesa su valor, tan solo si existe o no) así que esto permite
modelar nuestra compilación a distintos entornos.
Para definir una macro en el comando de compilación con gcc simplemente
agregar: \verb!-DNOMBRE_MACRO=valor!, por ejemplo, en el caso que acabo
de presentarte: \verb!-DMY_MACRO=0!. Pruébalo, compila el programa anterior
con esta orden: \verb!gcc -o main.exe main.c! y ejecútalo, imprimirá <<¡Hola,
mundo!>>, si lo compilas con esta: \verb!gcc -o main.exe main.c -DMY_MACRO=0!,
imprimirá <<¡Adiós, mundo!>>.

Por ejemplo, se usa para
hacer que existan o no impresiones por pantalla que sólo deben verse en
compilaciones usadas para hallar errores en el código, pero no en la compilación
final, la que se vendería, por ejemplo. Estas directivas son muy importantes
por algo que veremos en la sección siguiente.

\subsection{Compilación de objetos}
El siguiente paso es el de la compilación propiamente dicha. Es un paso
muy sencillo, pero con implicaciones muy interesantes. Lo que has venido
haciendo hasta ahora es compilar un binario de un único fichero de código
fuente. Pero si ejecutaras la orden de compilación de otro modo:
\begin{verbatim}
gcc -c <fichero de código fuente>
\end{verbatim}

Esto generará un fichero con el mismo nombre que el de código, pero con la
extensión \verb!.o!. Esto es un fichero de código \textbf{objeto}. Estos
ficheros son un punto intermedio entre el código fuente en C y el ejecutable,
es un punto intermedio porque estos archivos tienen aún información sobre
símbolos (variables, funciones...) etc. Si compilas con esta opción el programa
Hola Mundo que escribimos al principio, verás que \textbf{no} puedes ejecutar
este archivo de código objeto, pero estos archivos son los ingredientes que
usaremos en nuestra marmita para poder componer por fin un ejecutable con
varios códigos objeto.

Para hacer esto quiero que recuperes los ficheros \verb!main.c! y \verb!other.c!
y \textbf{elimines} la línea donde incluías \verb!other.c!. Si ahora intentas
compilar el archivo \verb!main.c! con la orden
\verb!gcc -c main.c! el compilador lanzará un \emph{warning} como este:

\begin{lstlisting}[style=terminalStyle]
main.c: In function 'main':
main.c:8:5: warning: implicit declaration of function 'multiply' [-Wimplicit-function-declaration]
    8 |     multiply(&a, 2);
      |     ^~~~~~~~
\end{lstlisting}

Nos dice que hemos declarado implícitamente la función \verb!multiply!, eso
significa que el compilador no ha encontrado la definición de la función en el
código fuente, es decir, te advierte que esta función se queda pendiente de
existir tal y como está usada aquí (nombre, tipo de retorno y argumentos).
Quizás esto te parezca una locura, pero así es, en C se pueden declarar
funciones simplemente llamándolas porque se espera que \textbf{estén en otros
códigos objeto}. De ahí que los códigos objeto aún guarden información sobre
los nombres de las funciones, porque así cuando los juntas todos, se juntan
las piezas de este puzzle que es nuestro ejecutable.

Ahora, debemos crear el código objeto del otro archivo, simplemente ejecuta
el mismo comando, pero sobre \verb!other.c!. Ahora tendrás dos archivos:
\verb!main.o! y \verb!other.o!. Ya tenemos las piezas, para juntarlas,
simplemente ejecutarías:
\begin{verbatim}
gcc -o main.exe main.o other.o
\end{verbatim}

Esto generará un ejecutable que podrás ejecutar normalmente y verás que,
efectivamente, funciona. Como comprenderás, es muy mala idea que cuando compilas
un archivo de código fuente haya funciones que existen simplemente porque las
usas, imagínate el horror de tener que compilarlo todo para luego descubrir que
has llamado mal a una función (por ejemplo, con un número equivocado de
argumentos). Si has experimentado con los ejercicios, habrás visto que muy
sencillo cometer esos errores y que el compilador es, de hecho, tu mejor aliado
para señalártelos. En la solución a esto es donde entran los archivos de cabecera
y los archivos de código. Como ya vimos en la sección \ref{funciones}, se pueden
declarar en un sitio y definir en otro, y es aquí donde esto nos resulta más
útil. Todas las funciones pueden ir declaradas en un fichero de cabeceras, de
tal manera que el compilador \textbf{conozca} la cabecera de la función y
pueda generar el objeto comprobándola. Para ello, vamos a escribir el archivo
de cabeceras que corresponde a \verb!other.c!, es decir, \verb!other.h!. Es muy
sencillo, como sólo tenemos una función, el archivo será tal que así:


\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Archivo de cabecera},
label={lst:headerFile}]
//other.h
void multiply(int* a, int b);
\end{lstlisting}
\end{minipage}

Hay que cambiar \verb!other.c!, simplemente \textbf{incluyendo} la propia
cabecera. Esto lo hacemos así porque, si nos equivocamos al definir la función,
por ejemplo, imagínate que se nos olvida el asterisco, el compilador nos dirá
que hemos redefinido la función porque, al haberla declarado en dos maneras
distintas, sería como dos funciones con el mismo nombre, y eso no está
permitido. Quedaría así:


\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Archivo de definiciones con cabecera incluida},
label={lst:fileCofHeader}]
//other.c
#include "other.h"
void multiply(int* a, int b) {
    *a *= b;
}
\end{lstlisting}
\end{minipage}

Finalmente, en \verb!main.c! incluiremos el archivo de cabeceras. Quedaría así:

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Archivo principal con cabeceras incluidas},
label={lst:fileCofHeader}]
//main.c
#include <stdio.h>
#include "other.h"

int main(void)
{
    int a = 10;
    printf("a ahora vale: %d\n", a);
    multiply(&a, 2);
    printf("a ahora vale: %d\n", a);
}
\end{lstlisting}
\end{minipage}

Ahora, para generar el binario, simplemente tenemos que generar ambos
objetos y después el ejecutable con estas órdenes:

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=terminalStyle]
gcc -c main.c
gcc -c other.c
gcc -o main.exe main.o other.o
\end{lstlisting}
\end{minipage}

Si observas, el compilador ya no nos lanza el \emph{warning} de que hemos
usado la función sin una declaración previa. Pero hay un problema, el código
de \verb!other.h! será incrustado en todos los archivos que utilicen la función,
porque en todos ellos estará la directiva de inclusión. Si dejamos esto tal y
como está, no podríamos usar la función en otro archivo, porque el compilador
vería esto como una redefinición. Incluyo aquí todos los archivos para que
tengas toda la información.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Ejemplo de redefinición -- \texttt{point.h}},
label={lst:redefInclude}]
//point.h
struct point_s{
    double x;
    double y;
};

typedef struct point_s point_t;

double distance(const point_t* a, const point_t* b);
\end{lstlisting}
\end{minipage}
\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Ejemplo de redefinición -- \texttt{point.c}},
label={lst:redefInclude}]
//point.c
#include "circle.h"
#include <math.h>
#include <stddef.h>

double distance(const struct point_s* a, const struct point_s* b) {
    double res = 0.0;
    struct point_s origin = { .x = 0.0 , .y = 0.0 };
    if (NULL == a) {
        a = &origin;
    }
    if (NULL == b) {
        b = &origin;
    }
    double diff_x = a->x - b->x;
    double diff_y = a->y - b->y;
    res = sqrt(diff_x * diff_x + diff_y * diff_y);
    return res;
}
\end{lstlisting}
\end{minipage}
\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Ejemplo de redefinición -- \texttt{circle.h}},
label={lst:redefInclude}]
//circle.h
#include "point.h"

#define PI ((double)3.141592)

struct circle_s {
    point_t center;
    double  radius;
};

typedef struct circle_s circle_t;

double area(const circle_t* c);

double diameter(const circle_t* c);
\end{lstlisting}
\end{minipage}

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Ejemplo de redefinición -- \texttt{circle.c}},
label={lst:redefInclude}]
//circle.c
#include "circle.h"
double area(const circle_t* c) {
    return c->radius * c->radius * PI;
}

double diameter(const circle_t* c) {
    return 2 * PI * c->radius;
}
\end{lstlisting}
\end{minipage}

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Ejemplo de redefinición -- \texttt{main.c}},
label={lst:redefInclude}]
//main.c
#include <stdio.h>
#include "point.h"  //for using points
#include "circle.h" //for using circles


int main(void)
{
    point_t a = {1.1, 2.3};
    point_t b = {4.1, 3.3};
    printf("La distancia entre a y b es: %f\n", distance(&a, &b));

    circle_t circle = {a, 1};
    printf("La el círculo tiene un área de: %f\n", area(&circle));
}
\end{lstlisting}
\end{minipage}

Si intentas generar los objetos de todos los archivos de código fuente (los
archivos de cabeceras no se compilan), verás que a la hora de compilar
\verb!main.c! éste da errores sobre redefiniciones. Esto es porque, si sigues
el <<rastro>> de las inclusiones, verás que \verb!main.c! incluye
\verb!circle.h! y éste incluye \verb!point.h!. Por otro lado, el propio
\verb!main.c! incluye \verb!point.h!, esto provoca que el contenido de éste
último esté presente dos veces. Si bien en este ejemplo se podría solucionar
sencillamente eliminando la inclusión de \verb!point.h! en el archivo principal,
pero no podemos hacerlo, porque entonces no habría modo de usar las estructuras
definidas en esa cabecera aquí. En proyectos con más archivos es una tarea
imposible rastrear estos problemas
para comprobar si incluyes un archivo más de una vez. Además, si hicieras esto,
volveríamos a esa situación en que no podrías saber si estás usando bien las
funciones en \verb!main.c!, porque no has incluido la cabecera correspondiente.
Por esto, se usan los llamados \emph{include guards}.

Éstos son simplemente el uso de directivas de tipo \verb!ifndef endif! para
hacer que, si un archivo de cabeceras se incluye más de una vez, las
repeticiones sean archivos vacíos. Es costumbre que todos los archivos
de cabeceras de un proyecto lleven uno, así que para cuando uses varios
archivos de código te recomiendo que te acostumbres desde ahora a usarlos.
Veamos cómo añadir un \emph{include guard} a \verb!point.h!


\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Ejemplo de \emph{include guard}},
label={lst:includeGuard}]
//point.h
#ifndef POINT_H
#define POINT_H

struct point_s{
    double x;
    double y;
};

typedef struct point_s point_t;

double distance(const point_t* a, const point_t * b);

#endif
\end{lstlisting}
\end{minipage}

Como puedes ver, lo que se hace es encerrar todo el contenido del archivo
en un condicional del preprocesador.
Si la macro \verb!POINT_H! no está definida, la definiremos,
y con ella todo el código de la cabecera. Así, cuando se incluya por segunda
vez, como dicha macro ya está definida, el \verb!ifndef! no se cumplirá y,
a efectos del compilador, este archivo estará vacío. El nombre de la macro
suele ser el nombre del archivo, sustituyendo los puntos por guiones bajos,
si usaras directorios dentro de tu proyecto, lo ideal sería que la macro tuviera
la ruta completa del archivo relativa al directorio donde guardes tu proyecto,
por ejemplo, si este archivo estuviera en:
\verb!proyecto/lib/math/geometry/include!, el nombre de la macro del
\emph{include guard} debería ser:
\verb!LIB_MATH_GEOMETRY_INCLUDE_POINT_H!.


\subsection{Enlazado}
El enlazado es la fase final del proceso de creación de un ejecutable. En él,
lo que se hace es juntar los códigos objeto y las diferentes
\textbf{bibliotecas} (en inglés: \textit{libraries})
necesarias para el funcionamiento del ejecutable. Ya
sabemos qué son los códigos objeto, y ya has usado varios para crear un
ejecutable, pero ahora vamos a centrarnos en las bibliotecas.

Una biblioteca es, en términos conceptuales, un conjunto de funcionalidades que
se compilan y distribuyen en un paquete que el usuario de la misma puede
utilizar en sus programas. La principal ventaja es que el código fuente de una
biblioteca es prácticamente imposible de reconstruir a partir de la misma, y,
sobre todo, de una manera comprensible. Esto es una ventaja porque el código
fuente está sujeto a propiedad intelectual, y, si bien es común que existan
proyectos de código abierto, muchas bibliotecas comerciales se distribuyen sin
acceso al código.

Además, las bibliotecas trasladan la responsabilidad del código de las mismas
a quien las vende o distribuye, descargando al usuario de éstas de la tarea
de fabricar
el binario cuando cambie el código. Son una herramienta de distribución de
\emph{software} imprescindible. De hecho, ya has usado bibliotecas, todas las
funciones que has usado hasta ahora que venían dadas simplemente poniendo
alguna directiva de inclusión de una cabecera (\verb!malloc!, \verb!printf!...)
residen en distintas bibliotecas \textbf{proporcionadas como parte de tu
sistema operativo Linux}. Cuando el sistema operativo se actualiza, estas
bibliotecas podrían cambiar y por tanto su funcionalidad verse actualizada.
Esto puede implicar que necesites recompilar tus programas para ver esos cambios
o no, dependiendo de qué tipo de bibliotecas utilices, habiendo dos tipos:

\begin{enumerate}
\item Bibliotecas dinámicas: Son aquéllas que se cargan en memoria cuando el
programa se ejecuta, de ahí su nombre, pues se cargan sólo cuando son
necesarias.
\item Bibliotecas estáticas: Son aquéllas que se combinan con el binario en
tiempo de compilación. Esto implica que cuando se cambia una biblioteca de este
tipo se deben recompilar los binarios que la usen.
\end{enumerate}

Las bibliotecas, como el ejecutable, \textbf{son gestionadas por el sistema
operativo}, es decir, los ejecutables que utilicen bibliotecas solicitarán al
sistema operativo (sin que el programador deba hacer nada a nivel de código
fuente) que las cargue cuando sea necesario. Además, es él el que gestiona
las versiones, permitiendo al programador de un binario indicar que su
ejecutable sólo funcionará con determinada versión de una biblioteca dinámica
pero no con otras.

En general, cuando se generan bibliotecas se utilizan herramientas que
automatizan la compilación de todos los códigos objeto y el enlazado de
bibliotecas. Pero voy a mostrarte cómo se haría <<a mano>>.

Supongamos que queremos hacer una biblioteca con nuestra estructura punto y
nuestra estructura círculo y que la vamos a llamar \verb!libGeometry!.
Es convencional que todas las bibliotecas empiecen por \verb!lib!.
El primer paso es generar el código objeto,
pues de él nos valemos tanto para crear ejecutables como para crear bibliotecas.
\begin{verbatim}
gcc -c point.c
gcc -c circle.c
\end{verbatim}

Una vez hecho eso, creamos la biblioteca, para ello utilizamos este comando:
\begin{verbatim}
gcc -shared -o libGeometry.so point.o circle.o
\end{verbatim}

Utilizamos la opción \verb!shared! para indicar que estamos compilando
una biblioteca dinámica. Ahora, para crear el ejecutable, debemos enlazar con
la biblioteca:

\begin{verbatim}
gcc -shared -o pointLib.so point.o circle.o
\end{verbatim}

Esto creará nuestro archivo de biblioteca, \verb!pointLib.so!, ahora podemos
compilar el ejecutable utilizando la biblioteca en vez de los códigos objeto
directamente. Para ello se usaría este comando:

\begin{verbatim}
gcc -L. -Wl,-rpath=. -o main.exe main.o -lGeometry -lm
\end{verbatim}

Este comando es un poco complicado, la opción \verb!-L! nos permite indicar
en qué fichero deben buscarse las bibliotecas para la compilación, esto se hace
indicando la ruta punto (\verb!.!), que significa este directorio. Por otro
lado, la opción \verb!-Wl,-rpath=! nos permite indicar dónde debe buscarse
el archivo de la biblioteca en el momento de la ejecución,
igualmente, escribimos punto. El resto del
comando es igual, pero añadimos el enlazado de las dos bibliotecas: la nuestra y
la biblioteca matemática, con la opción \verb!-lm!. Ahora, si ejecutas el
programa con el comando \verb!./main.exe!, funcionará perfectamente.
Para comprobar que la biblioteca se enlaza dinámicamente, prueba a eliminarla,
puedes hacerlo con el comando \verb!rm libGeometry.so!. Si ahora ejecutas el
programa, no funcionará, porque lo buscará en tiempo de ejecución.

En el caso de una biblioteca estática, éstas se crean de manera más sencilla,
crea los objetos como antes, y ahora crea la biblioteca estática:

\begin{verbatim}
ar rvs libGeometry.a point.o circle.o
\end{verbatim}

Ahora se puede compilar incluyendo la biblioteca (tenemos que seguir añadiendo
\verb!-lm! porque usamos la función \verb!sqrt! que está en la biblioteca
matemática):

\begin{verbatim}
gcc -o main.exe main.o libGeometry.a -lm
\end{verbatim}

Para comprobar que es estática, eliminar \verb!libGeometry.a! y verás que el
ejecutable sigue funcionando. Esto es porque la biblioteca se incrusta en
el momento en que realizas el ejecutable con todo sus códigos objeto. Esto hace
que el resultado sea similar a simplemente utilizar todos los códigos objeto,
pero sigue permitiendo la \textbf{distribución} sencilla del \emph{software}.
Además, así nos permite crear unidades conceptuales de software mayores que
los códigos objeto de un único fichero, simplificando nuestros procesos de
creación y distribución de los programas.


\section{Funciones de la biblioteca estándar}
La biblioteca estándar de C es una biblioteca que se incluye en todos los
programas compilados en C en Linux. Esto es así porque contiene la mayoría
de funciones que son implescindibles para realizar tareas básicas, por ejemplo:
\verb!malloc! y \verb!free! están en ella. Aunque haya una cabecera que se llame
\verb!stdlib.h!, la mayoría de funcionalidades que se pueden usar sin enlazado
de bibliotecas extra (como la matemática) están en la biblioteca estándar.
En esta sección vamos a hablar de algunas de estas funciones y a demostrar por
qué son necesarias incluso en niveles básicos.

\subsection{Manejo de memoria}
Aunque ya hemos visto las funciones más básicas para el manejo de memoria:
\verb!malloc! y \verb!free!, hay otras funciones que son útiles que está bien
que conozcas. Éstas son \verb!calloc!, \verb!realloc! y \verb!memset!. Las dos
primeras sirven para reservar memoria y la última sirve para poner a un mismo
valor todos los bytes de una zona de memoria. Suelen verse mucho en programas
con muchas operaciones de memoria.

La primera de ellas: \verb!calloc! es una función que nos permite indicar la
reserva de varios framentos de un tamaño concreto, que se reservarán en una
zona contigua. Para empezar, veamos la declaración de la función:

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Declaración de la función \texttt{calloc}},
label={lst:callocSignature}]
void *calloc(size_t nmemb, size_t size);
\end{lstlisting}
\end{minipage}
Como puedes ver, al igual que su <<hermana>> \verb!malloc!, devuelve un
puntero a \verb!void!, que después podrá ser asignado a cualquier tipo de
puntero. Sin embargo, recibe dos argumentos: el número de elementos que vas
a reservar y el tamaño de los elementos. Si estás pensando que una llamada a
esta función es equivalente a un \verb!malloc! multiplicando los dos argumentos,
tienes razón, pero hay \textbf{una diferencia}: la memoria reservada con
\verb!calloc! será inicializada a \textbf{ceros}. Esto provoca que algunos
programadores utilicen una llamada a \verb!calloc! con el primer argumento
valiendo uno para reservar una zona de memoria que esté inicializada a ceros.

La siguiente función, \verb!realloc!, es más interesante, es una función que nos
permite \textbf{redimensionar} y automáticamente mover, si fuera necesario,
una zona de memoria, su declaración es la siguiente:

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Declaración de la función \texttt{realloc}},
label={lst:callocSignature}]
void *realloc(void *ptr, size_t size);
\end{lstlisting}
\end{minipage}
Como puedes ver, recibe un puntero como primer argumento, éste es el puntero
de la zona de memoria \textbf{que queremos redimensionar} y, como segundo argumento,
recibe el tamaño nuevo, \textbf{en bytes}, de la zona de memoria. En este caso hay
dos posibilidades, que estés ampliando la zona inicial o que la estés
encogiendo. En ninguno de los dos casos tienes garantizado que la zona de
memoria sea la misma, así que debes comprobar que no ha devuelto \verb!NULL! y
además volver a guardar el valor del puntero, porque ha podido cambiar.
Además, si el puntero que se le da a esta función es nulo, simplemente se
comporta como \verb!malloc!, esto es útil para poder usarla en bucles sin tener
que mezclarla con una llamada a \verb!malloc! inicial.
Para ilustrar el uso de esta función, implementaremos con ella el programa
\ref{lst:mallocAndFree} donde demostramos el primer uso de reserva de memoria
dinámica.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C, label={lst:reallocExample},
caption={Utilización de \texttt{realloc}}]
#include <stdio.h>
#include <stdlib.h>

int* erase_reps(int* array, int array_length, int* final_length) {
    *final_length = 0;
    int* result = realloc(NULL, sizeof(*result) * array_length);
    for (int ii = 0; ii < array_length; ++ii) {
        int unique = 1;
        for (int jj = 0; jj < ii; ++jj) {
            if (array[ii] == array[jj]) {
                unique = 0;
            }
        }
        if (unique) {
            result[*final_length] = array[ii];
            ++(*final_length);
        }
    }

    return realloc(result, *final_length * sizeof(*result));
}


int main(void)
{
    int array[] = { 20,1,2,3,4,5,6,5,8,7,9,6,6,5,4,1,2,3,8,5,4,4,5,6 };
    int length;
    int* result = erase_reps(array, 24, &length);
    if (NULL == result) {
        printf("Ha habido un error de memoria\n");
        return -1;
    }
    for (int ii = 0; ii < length; ++ii) {
        printf("%d\n", result[ii]);
    }
    free(result);
}
\end{lstlisting}
\end{minipage}

Si comparas ambos programas, verás que en la primera tuvimos que declarar un
array para poder tener un sitio en el que guardar los datos hasta que sepamos
cuántos hay que alojar. La desventaja de esto es que después tenemos que copiar
los datos a la nueva zona que vamos a devolver y reservamos con \verb!malloc!,
en este caso en que usamos \verb!realloc!, dejamos que sea el gestor de memoria
del sistema operativo el que se preocupe de esto, y, siendo sensatos, es poco
probable que al encoger una zona de memoria se mueva el contenido, así que
podemos asumir que nos ahorraremos la copia la mayoría de veces. Ojo, repito:
poco probable; pero posible.

La siguiente función es también interesante, \verb!memset! es una función que se
encuentra declarada en la cabecera \verb!string.h!. Y esto tiene sentido porque,
al poner todos los bytes de una zona de memoria al mismo valor, se usa mucho
cuando se utilizan cadenas de texto, para permitir rellenar un texto con el
mismo carácter. La función tiene esta forma:

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Declaración de la función \texttt{memset}},
label={lst:memsetSignature}]
void *memset(void *s, int c, size_t n);
\end{lstlisting}
\end{minipage}
El primer argumento es el puntero es donde vas a escribir los cambios, el
segundo es el valor que vamos a escribir \textbf{en cada byte} y el último
el número de bytes que se van a escribir. El típico ejemplo de uso para esto
es cuando necesitas inicializar a ceros una zona de memoria. Esto es típico
cuando reservas memoria para alguna estructuras cuyo valor necesitas controlar
o que requiere que sea inicializada así. En ejemplos posteriores las veremos.
El ejemplo que voy a poner, sin embargo, es más original. Imagina que
quieres imprimir una carra de progreso en modo de texto que tenga este aspecto:
\begin{verbatim}
[#############################.....................]
\end{verbatim}
Imagino que ves por dónde voy. Para que la barra se imprima de manera
<<bonita>>, tengo que presentarte un  nuevo caracter especial: \verb!\r!, que
se llama retorno de carro, es decir, lleva el punto de impresión al principio
de la línea, permitiéndote sobreescribirlo. Además, voy a usar una función
llamada \verb!usleep!, que nos permite pausar el programa durante algún tiempo,
si no, el programa haría la secuencia muy deprisa. Finalmente, la función
\verb!fflush! te permite \textbf{forzar} a la terminal a que imprima caracteres
que estén pendientes, esto lo hacemos porque, como no imprimimos ninguna línea
nueva, la terminal imprimiría sólo cada cierto tiempo, fastidiando el efecto.


\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Utilización de la función \texttt{memset}},
label={lst:memsetExample}]
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#define ARRAY_SIZE(array) ((sizeof((array)))/(sizeof((array)[0])))
#define BAR_LENGTH ((size_t)100)

void print_bar(int progress) {
    //el resto de chars serán cero
    char bar[BAR_LENGTH + 3] = { '[' };
    //dejamos espacio al final para el último cero
    bar[ARRAY_SIZE(bar) - 2] = ']';
    //escribimos las almohadillas que indican completado
    memset(bar + 1, '#', progress);
    //escribrimos los puntos que indican la parte sin completar
    memset(bar + 1 + progress, '.', BAR_LENGTH - progress);
    //imprimimos y volvemos al principio de la línea
    printf("%s\r", bar);
    //obligamos a la terminal a actualizarse inmediatamente
    fflush(NULL);
}

int main(void)
{
    for (int ii = 0; ii <= 100; ++ii) {
        print_bar(ii); //imprimimos la barra
        usleep((unsigned int)(2.50 * 100000)); //esperamos
    }
    //imprimimos una línea nueva para que el prompt salga
    //en la siguiente
    printf("\n");
}
\end{lstlisting}
\end{minipage}

Como puedes ver, la función que imprime una barra dado determinado progreso
es muy simple. Debido a que aparecen varias cosas que no había explicado antes,
he comentado el código exhaustivamente. Aquí lo hago en español, pero, como
ya dijimos, en cualquier entorno profesional los comentarios se hacen en inglés.

Otra función muy útil es la que nos permite \textbf{copiar} lo que hay en una
zona de memoria a otra. Esto es especialmente útil porque nos permite copiar
de una parte a otra cualquier tipo de dato sin tener que hacer un bucle, cuando
un algoritmo copia muchas veces de un sitio a otro, al final esos simples
bucles pueden hacer el código más difícil de leer. Como con las demás, vamos
a ver su declaración:


\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Declaración de \texttt{memcpy}},
label={lst:memcpy}]
void *memcpy(void *dest, const void *src, size_t n);
\end{lstlisting}
\end{minipage}

Recibe tres argumentos, el primero es la zona de memoria donde copiaremos
los datos, el segundo la zona de memoria desde la que los copiaremos
y el tercero el número de bytes que queremos copiar. Para recordar qué argumento
va primero (si el destino o el origen), yo recuerdo que funciona como una
asignación, es decir, el destino va a la izquierda. Veamos un ejemplo, imagínate
una función que nos permite insertar un elemento en la posición que queramos de
un array.


\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Utilización de la función \texttt{memcpy}},
label={lst:memcpyExample}]
int *insert_at(int *list,
               int  list_size,
               int  position,
               int  element)
{
    int *res = malloc(sizeof(*res) * (list_size + 1));
    memcpy(res, list, sizeof(*res) * position);
    memcpy(res + position, &element, sizeof(*res));
    memcpy(res + position +1,
               list + position,
               sizeof(*res) * (list_size - position));
    return res;
}
\end{lstlisting}
\end{minipage}

La función es bastante sencilla, simplemente copiamos desde la primera posición
a la posición de inserción, copiamos el elemento que queremos insertar (esto
lo podríamos hacer con un operador de asignación, pero ya que estamos en el
negocio...) y después copiamos los elementos que vienen después del que
queríamos insertar.


\subsection{Manejo de cadenas de texto}
Quizás hayas notado que, debido a que los \emph{strings} en C son simplemente
arrays y a que no podemos hacer una serie de cosas con ellos de manera sencilla,
siempre ocurre que es complicado manejarlos. Si no, ya te comunico que utilizar
cadenas de texto en C intensivamente es algo ligeramente (si no mucho) más
engorroso que con otros lenguajes. Pero hay muchas funciones que nos ayudan
a manejarlos. Veamos de qué funcionalidades disfrutamos:

\begin{enumerate}
\item Comparar cadenas y ordenarlas lexicográficamente
\item Saber la longitud de cadenas de texto.
\item Duplicar una cadena.
\item Crear cadenas nuevas con formato determinado.
\end{enumerate}

Como puedes ver, tenemos una enorme cantidad de funcionalidades a nuestra
disposición para manipular cadenas de texto. Estas funciones están todas en las
cabeceras \verb!string.h! y \verb!stdio.h! (la misma que \verb!printf!).
Vayamos funcionalidad por funcionalidad.

En general, las variables básicas se comparan con el operador \verb!==!, pero
las cadenas de texto en C son punteros. Si hicieras una comparación con este
operador, simplemente compararías las direcciones de ambas cadenas que, salvo
que fueran la misma, nunca serían iguales. Supongo que, con lo que ya sabes del
lenguaje, podrás deducir cómo se hace la comprobación: simplemente un bucle que
compare carácter a carácter hasta que se llegue al final de uno de los dos, que
debería ser el mismo número de iteraciones para que sean iguales. La función
para hacer esto es \verb!strcmp!.

En general, cuando comparas cosas en un lenguaje, invocas un operador o una
función que devuelve cierto si son iguales y falso si son distintos. Por
ejemplo: \verb!a == b!. Pero en este caso, \verb!strcmp! devuelve un número
menor que cero si la primera cadena es anterior a la segunda en orden
lexicográfico (alfabético), \textbf{cero si son iguales} y un número mayor
que cero si la segunda es anterior a la primera. Veamos un ejemplo de su uso,
vamos a realizar un programa que indique si una sucesión de cadenas está en
orden alfabético.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Ejemplo de uso de \texttt{strcmp}},
label={lst:strcmp}]
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main(int argc, char const* argv[])
{

    if (argc < 3) {
        printf("Necesitamos al menos dos palabra.\n");
        return EXIT_FAILURE;
    }


    for (int ii = 1; ii < argc - 1; ++ii) {
        if (0 < strcmp(argv[ii], argv[ii+1])) {
            printf("Las palabras introducidas como argumento no"
                   " están en orden alfabético\n");
            return EXIT_FAILURE;
        }
    }
    printf("ok\n");
    return EXIT_SUCCESS;
}
\end{lstlisting}
\end{minipage}

El condicional es un poco confuso, pero suele pasar cuando utilizamos
\verb!strcmp!, queremos que los argumentos anteriores sean menores que los
posteriores, por lo que debemos comprobar si el resultado de \verb!strcmp! es
mayor que cero (o, tal y como está escrito, si cero es menor que ese resultado)
porque indicaría que es la palabra en la siguiente posición la que iría antes,
es decir, que están desordenadas. Por otro lado, mira el bucle, empezamos
desde la posición uno, porque en la cero está el nombre del programa y
terminamos en la anterior a la última, porque dentro del bucle comprobamos
la siguiente posición, y no hay siguiente a la última.

La siguiente función que nos ocupa es \verb!strlen!, que nos dice la longitud
de una cadena de texto, eso sí: \textbf{sin contar el carácter nulo}. Para
empezar, antes de ver la \emph{signature} de la función, vamos a hacer el
ejercicio de hacer una función que realice esta sencilla tarea:

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Propia versión de \texttt{strlen}},
label={lst:ownStrlen}]
size_t my_own_strlen(const char* string)
{
    size_t res  = 0;
    char   iter = string[res];

    while ('\0' != iter) {
        ++res;
        iter = string[res];
    }

    return res;
}
\end{lstlisting}
\end{minipage}

La función es muy simple, pero quiero que notes una cosa que se ve bien en
esta implementación (implementación es una manera de decir realización, es
decir, cómo está hecho):
si el \emph{string} no contiene ningún carácter nulo,
esta función leerá lo siguiente que haya en memoria sin parar, lo que, como
ya sabes, suele provocar que los programas fallen y se cierren. Por esto,
ten cuidado al usar la función, porque llamarla sobre un puntero a \verb!char!
sin un carácter nulo provocaría errores en el programa.

Rápidamente, la función que duplica cadenas de texto es \verb!strdup!, y su
\emph{signature} es ésta:

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Definición de \texttt{strdup}},
label={lst:ownStrlen}]
char *strdup(const char *s);
\end{lstlisting}
\end{minipage}
Simplemente es una función a la que le pasas por argumento la cadena que quieres
duplicar y devuelve un puntero a una zona de memoria con este mismo contenido.
Sin embargo, debes liberar los dos, si el primero se reservó con memoria
dinámica, porque no es una operación que mueve, sino que copia.

Por ejemplo, un uso común para esta función es cuando estás creando una
estructura de datos que almacene cadenas de texto, como ya vimos en el programa
\ref{lst:constantArguments}: \nameref{lst:constantArguments}, es útil que
ciertas estructuras de datos se manejen sólo mediante llamadas a funciones,
por ello, en vez de hacer lo que hacemos allí: primero el \verb!malloc! y
después la copia, podemos usar \verb!strdup!, para hacerlo en menos líneas.
Un buen ejercicio sería que reescribieras ese programa utilizando esta nueva
función.

Y llegamos al punto más importante de esta sección, el formateado de una cadena
de texto a partir de variables. Esto ya lo has estado haciendo con la función
\verb!printf!. Para poder hacer esto, existen varias funciones:
\begin{enumerate}
\item \verb!sprintf!: Permite hacer los mismo que \verb!printf!, pero a un
puntero a \verb!char!.
\item \verb!fprintf!: Es la misma idea, pero con ficheros, del mismo modo de
las funciones de escritura y lectura de archivos, recibe un puntero de tipo
\verb!FILE!.
\end{enumerate}

De nuevo, este es un manual de C, y pretendo que siga siendo más o menos
estrictamente eso, pero me es conveniente presentarte un ejemplo de caso de uso
para estas funciones. En informática, a veces, para transmitir información,
por ejemplo, por Internet o entre máquinas de cualquier modo realizamos un
proceso que se llama \textbf{serialización}. Este proceso es la conversión de
datos residentes en la memoria de alguna máquina a texto. Esto se hace porque
las máquinas pueden usar maneras distintas para guardar información en su
memoria, por ejemplo, hay ordenadores cuyos bytes están ordenados <<al revés>>.
Esto quiere decir que el número 10.669 que en hexadecimal es:
0x29AD se compone de dos bytes (recuerda, cada byte son dos dígitos
hexadecimales), en la memoria de algunos ordenadores estará guardado como
0x29~AD y en otras como 0xAD~29. Para evitar este tipo
de confusiones, convertirmos nuestros datos en cadenas de texto.

Volviendo al ejemplo del programa \ref{lst:constantArguments}. Podríamos
crear una función que creara esta serialización de la estructura, por ejemplo,
en el caso de una persona llamada José Pérez Martínez, querríamos serializarlo
así:

\begin{verbatim}
{
    "name":"José",
    "last_name_1":"Pérez",
    "last_name_2":"Martínez"
}
\end{verbatim}

Veamos como quedaría la función (recuerda que sería añadida al programa
que he citado antes) a la que llamaremos \verb!person_to_string!. Esta función
quedaría como:

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Ejemplo básico de \texttt{sprintf}},
label={lst:sprintfExample}]
char* person_to_string(const person_t *p){
    char preliminar[1024] = {};

    sprintf(preliminar,
            "{\n"
            "\t\"name\":\"%s\",\n"
            "\t\"last_name_1\":\"%s\",\n"
            "\t\"last_name_2\":\"%s\"\n"
            "}",
            p->name, p->last_name_1,
            p->last_name_2);

    return strdup(preliminar);
}
\end{lstlisting}
\end{minipage}

Para que se lea mejor, he escrito todos los argumentos de la función en una
línea distinta. En el caso del segundo argumento, el formato, lo he dividido
en varias, si observas un poco verás que no hay comas en esas líneas. Eso es
porque dos literales de \textit{string} escritos juntos son como uno solo. Ese
<<juntos>> incluye si sólo los separan espacios en blanco. Ten en cuenta que
esas líneas nuevas no aparecen en el \textit{string}, por eso debemos poner
\verb!\n! al final igualmente.
Además,
observa como utilizamos un array para formatear el texto porque, como ya es
habitual, no sabemos cuánto mide, una vez lo hemos formateado,
usamos \verb!strdup! para devolver una cadena del tamaño correcto.

No obstante este uso de la función es simple, aún queda un detalle: el valor que
devuelve la función. Tanto \verb!printf! como  \verb!sprintf! y todas las
funciones de esta familia devuelven un entero que indica
\textbf{el número de carácteres impresos}
(sin contar el caracter nulo que incluyen para que el \emph{string} resultante
esté bien formado).
Esto es de suma utilidad cuando quieres imprimir varias cosas en el mismo
\emph{string}. Veamos un ejemplo, imagina un programa que, análogamente,
serializa un array de enteros, si el array es {1,2,3,4,5} la serialización
quedaría como:

\begin{figure}[H]
\begin{verbatim}
[
    1,
    2,
    3,
    4,
    5
]
\end{verbatim}
\end{figure}
La solución más inmediata sería usar \verb!sprintf! para imprimir todos los
enteros, pero tenemos un problema, no sabemos cuántos números hay, así que
no podemos escribir en el formato que pide la función los especificadores
necesarios. Por eso vamos a imprimir con un bucle que utilice el valor
de retorno de la función.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Ejemplo de uso avanzado de \texttt{sprintf}},
label={lst:sprintfExample}]
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_STRING_SIZE ((size_t) 65536)
#define ARRAY_SIZE(array) ((sizeof((array)))/(sizeof((array)[0])))

char* integer_array_to_string(const int* array, size_t array_size)
{
    char res[MAX_STRING_SIZE] = {};
    int  printed_chars        = 0;

    printed_chars += sprintf(res + printed_chars, "[\n");
    for (size_t ii = 0; ii < array_size; ++ii) {
        char* separator;
        if (ii != array_size - 1) {
            separator = ",\n";
        }
        else {
            separator = "\n";
        }
        printed_chars += sprintf(res + printed_chars,
                                     "\t%d%s", array[ii], separator);
    }
    printed_chars += sprintf(res + printed_chars, "]");

    // desbordamiento
    if(printed_chars >= MAX_STRING_SIZE){
        return NULL;
    }

    return strdup(res);
}

int main(void)
{
    int list[] = {1,2,3,4,5,6};
    char *serialization = integer_array_to_string(list,
                                                  ARRAY_SIZE(list));
    printf("%s\n", serialization);
    free(serialization);
}
\end{lstlisting}
\end{minipage}

Si ves cómo hemos escrito la función, aprovechamos este valor de retorno para
concatenar cada impresión, el mecanismo es muy sencillo, si hemos impreso,
por ejemplo, tres letras, debemos sumar a la posición inicial ese número.
Además, usamos un condicional dentro del bucle para impedir que se imprima
una coma en el último elemento. Después del bucle, imprimimos el corchete de
cierre y, finalmente, hay un condicional que comprueba que no hemos impreso
más caracteres de los que habíamos previsto. Nota que utilizamos \verb!>=!
porque debemos provisionar que el último \verb!char! es un cero (\verb!\0!).

No obstante, tenemos un problema, aunque somos capaces de decir cuándo se ha
desbordado el \emph{buffer} inicial que proveímos, \textbf{no podemos impedir
que se desborde}. Esto tiene implicaciones muy serias, porque una vez escribes
en zonas de memoria en que no deberías, no sabes qué puede ocurrir. Por suerte,
hay una variación de la función que estamos usando que nos ayudará en este
propósito. Ésta se llama \verb!snprintf!, y tiene la misma \textit{signature}
que la anterior, pero añade un argumento: el número \textbf{máximo} de
caracteres que debe imprimir, de este modo, nunca desbordará nuestro
\emph{buffer}. Veamos cómo se implementaría el mismo programa usando esta
función.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Ejemplo de uso de \texttt{snprintf}},
label={lst:snprintfExample}]
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#define MAX_STRING_SIZE ((size_t) 100)
#define ARRAY_SIZE(array) ((sizeof((array)))/(sizeof((array)[0])))

char* integer_array_to_string(const int* array, size_t array_size)
{
    char res[MAX_STRING_SIZE] = {};
    int  printed_chars        = 0;

    printed_chars += snprintf(res + printed_chars,
                              MAX_STRING_SIZE,
                              "[\n");
    for (size_t ii = 0;
         ii < array_size && printed_chars < MAX_STRING_SIZE - 2;
         ++ii)
    {
        char* separator;
        if (ii != array_size - 1) {
            separator = ",\n";
        } else {
            separator = "\n";
        }
        printed_chars += snprintf(res + printed_chars,
                                  MAX_STRING_SIZE - printed_chars,
                                  "\t%d%s",
                                  array[ii],
                                  separator);
    }
    printed_chars += snprintf(res + printed_chars,
                             MAX_STRING_SIZE - printed_chars,
                             "]");
    // desbordamiento
    if(printed_chars >= MAX_STRING_SIZE){
        return NULL;
    }
    return strdup(res);
}

int main(void)
{
    int list[24] = { };
    char* serialization =
                    integer_array_to_string(list, ARRAY_SIZE(list));
    if (serialization != NULL) {
        printf("%s\n", serialization);
    }else{
        printf("Error: límite excedido\n");
    }
    free(serialization);
}
\end{lstlisting}
\end{minipage}

Como puedes ver, el segundo argumento de la función es el límite de caracteres
que podemos seguir imprimiendo. Siempre restamos a la longitud del buffer
lo que ya llevamos impreso, así, si ya hemos impreso 100 letras, nos quedan
65536--100. Por otro lado, ten en cuenta que \verb!snprintf! devuelve siempre
el número de caracteres que se imprimirían, es decir, sin contar con que se
realice la impresión o no. A la hora de imprimir, el carácter nulo del final
cuenta, es decir, si a una llamada a \verb!snprintf! le pasas como límite
un tres e intentas imprimir \verb!"abc"!, devolverá tres, pero no escribirá
el carácter nulo.

Ten cuidado, debes comprobar que el argumento del límite no es negativo,
porque está definido como un tipo sin signo, por lo que si le pasaras un número
negativo, sería un número positivo y aleatorio. En este código, lo comprobamos
en el bucle.

\subsubsection{Especificadores posicionales}
Al principio del manual te enseñé a imprimir cosas para que pudieras probar
tus programas, pero lo hice de una manera básica para no abrumarte al inicio
de este manual. No obstante; aprovecho que hemos vuelto a utilizar funciones
de manipulación de texto para desarrollar algo que me dejé entonces en el
tintero. Estos son los especificadores posicionales, ya sabemos qué es un
especificador, indican, dentro del formato, qué tipo dato tiene el argumento
que queremos escribir en esa posición. El problema de este sistema, sencillo,
es que provoca problemas cuando se repite la misma variable varias veces.

Si, por ejemplo, necesitamos imprimir varias veces la misma variable, no
tiene ningún sentido que le pasemos varias veces a la función de impresión.
Por ejemplo, imagínate una función que simulara una partida de nacimiento,
incluyendo el nombre de los padres, es decir, para un padre
llamado Fernando García Pérez y una madre llamada María Fernández López,
si el nombre de pila del niño fuera
Federico, su nombre sería Federico Garía López y deberían incluirse los tres.
La función es trivial, vamos a implementarla simplemente con lo que sabemos:


\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Ejemplo de impresión con argumento repetido},
label={lst:repeatedMessages}]
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct person_s {
    char *name;
    char *last_name_1;
    char *last_name_2;
} person_t;

char *son_name(const person_t *father, const person_t *mother,
               const char *first_name) {
    const int STRING_LENGHT = 65536;
    char res[STRING_LENGHT];
    char *format = "===PARTIDA DE NACIMIENTO===\n"
                   " - Nombre del Padre: %s %s %s\n"
                   " - Nombre de la madre: %s %s %s\n"
                   " - Nombre del hijo: %s %s %s\n";
    snprintf(res, STRING_LENGHT, format, father->name,
             father->last_name_1, father->last_name_2, mother->name,
             mother->last_name_1, mother->last_name_2, first_name,
             father->last_name_1, mother->last_name_1);
    return strdup(res);
}

int main(void) {
    char* text = NULL;
    person_t father = {"Fernando", "García", "Pérez"};
    person_t mother = {"María", "Fernández", "López"};
    text = son_name(&father, &mother, "Federico");
    printf("%s\n", text);
    free(text);
}
\end{lstlisting}
\end{minipage}

La función es sencilla, pero repetimos argumentos, como he introducido antes,
eso no sólo no es eficiente, sino que puede inducir a errores, porque tienes
que ir contando los argumentos. Cuando hay pocos, unos cinco o menos, es
factible, si son muchos más y además hay repeticiones, es sencillo perderse,
por ello, puedes indicar que se imprima el argumento de determinada posición.
Esto nos permite pasárselos sólo una vez a la función. Veamos cómo.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Ejemplo de impresión con argumento repetido y especificador posicional},
label={lst:repeatedMessagesPos}]
typedef struct person_s {
    char *name;
    char *last_name_1;
    char *last_name_2;
} person_t;

char *son_name(const person_t *father, const person_t *mother,
               const char *first_name) {
    const int STRING_LENGHT = 65536;
    char res[STRING_LENGHT];
    char *format = "===PARTIDA DE NACIMIENTO===\n"
                   " - Nombre del Padre: %s %s %s\n"
                   " - Nombre de la madre: %s %s %s\n"
                   " - Nombre del hijo: %s %2$s %5$s\n";
    snprintf(res, STRING_LENGHT, format, father->name,
             father->last_name_1, father->last_name_2, mother->name,
             mother->last_name_1, mother->last_name_2, first_name);
    return strdup(res);
}

int main(void) {
    char *text      = NULL;
    person_t father = {"Fernando", "García", "Pérez"};
    person_t mother = {"María", "Fernández", "López"};
    text            = son_name(&father, &mother, "Federico");
    printf("%s\n", text);
    free(text);
}
\end{lstlisting}
\end{minipage}

El primer cambio es que ahora los dos últimos especificadores son especiales,
un especificador posicional empieza como todos, con un signo de porcentaje,
después la posición en forma de número, un símbolo de dolar y el indicador
del tipo, en este caso, una ese, de \textit{string}. Como puedes ver, nos
ahorramos la repetición de los argumentos.

\subsection{Manejo de errores y manual}
Ahora que hemos visto muchas funciones y sabemos cómo se compila un programa
quiero volver a un ejemplo de programa muy sencillo de algunas secciones atrás,
el programa \ref{lst:exampleRemove}: \nameref{lst:exampleRemove}. Si incluimos el
archivo de cabecera \verb!errno.h! podemos reescribir el programa
de este modo:

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Ejemplo de programa que usa la variable \texttt{errno}},
label={lst:exampleRemove2}]
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char const *argv[]) {
    if (argc != 2) {
        printf("Usage: ./main <path to the file>");
    }

    int error = remove(argv[1]);

    if (error == 0) {
        return EXIT_SUCCESS;
    }
    switch (errno) {
    case ENOENT:
        printf("No such file or directory.\n");
        break;
    case EACCES:
        printf("Permission denied\n");
        break;
    default:
        printf("Undetermined error\n");
        break;
    }
    return EXIT_FAILURE;
}
\end{lstlisting}
\end{minipage}

Como has visto en el programa \ref{lst:exampleRemove} compruebo el valor de
retorno de la función que he llamado y, si es cero (lo que suele indicar éxito)
devuelvo yo mismo \verb!EXIT_SUCCESS!, terminando el programa. En cambio, si
el valor devuelto no es cero, entramos en un \verb!switch! sobre una variable
que no conocemos. En él, utilizamos una serie de valores que tampoco están
presentes en el programa. Esto es porque hemos incluido la cabecera
\verb!errno.h!. Esto nos permite utilizar la variable global
\verb!errno!.

Esta variable existe para que cuando llamemos a alguna función que la utilice
para notificar errores, su valor será escrito en consecuencia del error a uno
de los valores también definidos como macros en la cabecera. Por ejemplo, aquí
hemos contemplado algunos de los casos. Sin embargo; se presenta la pregunta
de cómo saber qué funciones utilizan esta variable global y cuáles no, y qué
valores hay. Para esto se utiliza el \textbf{manual}. Esta es una función de
los sistemas operativos Linux en la que puedes invocar el comando \verb!man!
para encontrar información sobre una función o cabecera. Por ejemplo, prueba
a escribir en una terminal

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=terminalStyle]
\$ man errno
\end{lstlisting}
\end{minipage}

Verás que sale un resultado que empieza por:

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=terminalStyle]
NAME
       errno - number of last error

SYNOPSIS
       #include <errno.h>

DESCRIPTION
       The <errno.h> header file defines the integer variable errno, which is set by system calls and some library functions in the event of an error to indicate what went wrong.

   errno
       The  value  in errno is significant only when the return value of the call indicated an error (i.e., -1 from most system calls; -1 or NULL from most library functions); a function that succeeds is
       allowed to change errno.  The value of errno is never set to zero by any system call or library function.

       For some system calls and library functions (e.g., getpriority(2)), -1 is a valid return on success.  In such cases, a successful return can be distinguished from an error return by setting  errno
       to zero before the call, and then, if the call returns a status that indicates that an error may have occurred, checking to see if errno has a nonzero value.
<continúa>
\end{lstlisting}
\end{minipage}

En las pantalla de manual te mueves con las flechas del teclado y sales de ellas
pulsando la tecla q. Si quieres saber el contenido de cualquier cabecera
(funciones, variables...) o la \textit{signature} de cualquier función, sólo
debes escribir \verb!man! seguido del nombre de la cabecera o función. Si
consigues resultados que no son lo que buscabas, ejecuta \verb!man 3 <nombre>!
en su lugar. El manual tiene información sobre otras cosas (como comandos),
pero la sección tres es la que habla de funciones de C.


\subsection{Ejercicios de la sección}
\begin{exercises}[resume*]
\item Reescribe el ejercicio 15 prescindiendo del array estático de punteros
a \verb!char!. (Usa \verb!realloc! y \verb!strdup!.

\item Escribe un programa que reciba un número indeterminado de palabras como
argumentos y los ordene alfabéticamente y que, después, los imprima.
\item Haz un programa que reciba como argumento una palabra y un número. Si el
número es cero, debe convertir la palabra a minúscula, si el número es distinto
de cero, debe convertirla a mayúscula. Por ejemplo:

\noindent
\begin{minipage}[H]{\linewidth}
\begin{lstlisting}[style=terminalStyle]
\$ ./main.exe Anthony 0
anthony
\$ ./main.exe USA 0
usa
\$ ./main.exe spqr 1
SPQR
\end{lstlisting}
\end{minipage}
Pista: Consulta la tabla ASCII para saber qué distancia hay entre una letra
mayúscula y una minúscula.
\item Crea un programa que dado un número como argumento imprima una pirámide
como esta de tantos pisos como el número indicado:

\noindent
\begin{minipage}[H]{\linewidth}
\begin{lstlisting}[style=terminalStyle]
%%%%%%%%%
 %%%%%%%
  %%%%%
   %%%
    %
\end{lstlisting}
\end{minipage}
Nota: utiliza la función \verb+memset+.
\item Escribe un programa que reciba una serie de puntos y de nombres para
cada uno y después los imprima en orden de su distancia al origen de menor a
mayor. Ejemplo de ejecución:

\noindent
\begin{minipage}[H]{\linewidth}
\begin{lstlisting}[style=terminalStyle]
\$ main.exe 2 3 Valencia 4 5 Cuenca -1 3 Vizcaya
-1 3 Vizcaya
2 3 Valencia
4 5 Cuenca
\end{lstlisting}
Nota: crea una estructura llamada \verb!tagged_point! que maneje los
\textit{strings} como se ve en el programa
\ref{lst:structConstPointers}, pero utilizando la función \verb!strdup!.
\end{minipage}
\end{exercises}


\section{Lógica avanzada}
Hasta ahora nos hemos conformado con utilizar cualquier tipo entero
(generalmente \verb!int!) para almacenar valores lógicos, pero esto se puede
evitar, ahorrando espacio y creando un tipo de dato que nos permita almacenar
propiamente un tipo lógico. Este tipo es el tipo \verb!bool!. Para poder
usar este tipo debes incluir la cabecera \verb!stdbool.h!. Además, este tipo
añade dos nuevas palabras reservadas: \verb!true! y \verb!false!. Palabras
que simbolizan, como puedes imaginar, un valor lógico cierto y uno falso.

Veamos un ejemplo de uso de este tipo en acción:

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Ejemplo del uso del tipo \texttt{bool}},
label={lst:bool1}]
#include <stdio.h>
#include <stdbool.h>

int main(void)
{
    bool it_is_difficult = 10;
    printf("%d\n", it_is_difficult);
}
\end{lstlisting}
\end{minipage}

No existe un especificador para imprimir booleanos, pero si usas el
especificador \verb!%d!, verás que ese programa imprime <<1>>. Es decir, si
somos diligentes almacenando los valores lógicos en el tipo booleano,
podemos asumir que un valor lógico cierto siempre será igual a 1.
Sin embargo, seguimos teniendo un problema, que es la utilización de un byte
entero para un valor que podría ser almacenado en un bit. Este problema viene
del hecho de que los ordenadores no se direccionan porciones de memoria más
pequeñas que bytes. Sin embargo; esto no quiere decir que no podamos manipular
los bits concretos de un byte, por ejemplo, poner a cero un bit concreto,
invertirlos... para eso utilizamos operadores a nivel de bit.

\subsection{Operadores a nivel de bit}
Voy a ser sincero, esta sección no sabía muy bien dónde encajarla, es decir,
no encontraba el sitio donde incluirla en el manual.
Al principio pensé incluirla después de los operadores lógicos, por la
similitud gráfica que ahora verás,
pero la utilidad de éstos era muy difícil de enseñar
en ese momento del manual, o en ese momento de tu aprendizaje, mejor dicho.
Así que mejor los vemos ahora.
Hay varios operadores a nivel de bit, estos son:
\begin{enumerate}
\item Conjunción a nivel de bit, denotada en matemáticas por el punto
medio ($\cdot$), se realiza con el operador \verb!&!.
\item Disyunción a nivel de bit, denotada por $+$, se realiza con el operador
\verb!|!.
\item Negación a nivel de bit, denotado del mismo modo que la negación lógica,
se realiza con el operador \verb!~!.
\item Desplazamiento hacia la izquierda, operador binario que mueve todos los
bits de un tipo entero a la izquierda tantas posiciones como indique el segundo
operando. Se realiza con el operador \verb!<<!.
\item Desplazamiento hacia la derecha, operador binario que mueve todos los
bits de un tipo entero a la derecha tantas posiciones como indique el segundo
operando. Se realiza con el operador \verb!>>!.
\end{enumerate}

Lo que quiere decir que lo hagan a nivel de bit es que, aplicando estos
operadores a dos tipos enteros, el operador genera otro entero cuyo valor será
el resultado de realizar la operación lógica indicada por el operador, pero bit
a bit. Es decir, la conjunción a nivel de byte entre dos números es otro número
en que cada uno de sus bits será el resultado de la conjunción
de los bits en esa posición en los operandos.

Para que endiendas esto bien tienes que entender cómo están representados los
enteros en el ordenador. Ya sabes cómo están representados los enteros sin
signo, en binario natural, es decir, como lo que vimos en la sección
\ref{numericSystems}. Sin embargo; los números negativos se representan
de un modo especial.
Hay varias maneras de representar los números con signo
en binario, la más ingenua es dedicar un bit (el primero, generalmente) al signo
y el resto al valor. De este modo, en un entero de ocho bits el número 7 sería
00000111 y el número -7 es 10000111, pero el problema de esta representación
es que tenemos el número 0 y el -0. Y como somos informáticos,
nos molesta sobremanera desperdiciar un preciado número. Por esto,
los números con signo se representan en \textbf{complemento a dos}.

En este sistema de representación, los números positivos coinciden con su
representación en binario natural, sin embargo, los números negativos se
representan con su complemento, para hallar el complemento a dos de un número
hay que seguir este proceso.
\begin{enumerate}
\item Invertir todos sus bits (el decir, pasar los ceros a unos y
los unos a ceros).
\item Sumarle uno al resultado anterior.
\end{enumerate}
Por ejemplo, volvamos al número 7 y a los ocho bits:
$$
7_{\left(10\right.} = 00000111_{\left(2\right.}; \;\;
\overline{00000111} = 11111000; \;\;
+\matrix{                      11111000\cr
        \underline{\hphantom{0000000}1}\cr
                              11111001
}\to -7_{\left(10\right.} = 11111001_{\left(\mathrm{CA}2\right.}
$$
La ventaja de esta representación es que, además, el primer bit sólo es uno
cuando el número es negativo, así que es el primer bit sigue indicando el signo,
como en la representación ingenua que te comenté al principio. Otra ventaja de
esto es que sólo existe una representación del cero, que cuenta como número
positivo, porque su primer bit es cero. Esto explica por qué cuando enunciamos
los rangos de los tipos básicos, los tipos enteros siempre llegaban a números
con valores absolutos una unidad mayores en el lado negativo que en el positivo,
el \verb!char!, por ejemplo, tiene un rango que va desde -128 a 127.

Volvamos a los operadores a nivel de bit, sea un \verb!char! que valga
-7 y otro que valga 12:
$$
a = -7_{\left(10\right.} = 11111001_{\left(\mathrm{CA}2\right.} \;\;
b = 12_{\left(10\right.} = 00001100_{\left(\mathrm{CA}2\right.}\;\;
a \cdot{} b = \cdot{}\matrix{11111001\cr
        \underline{00001100}\cr
                              00001000}
$$

En cuanto a los desplazamientos, es sencillo, sea por ejemplo el propio número
7, es decir: 00000111, si le aplicamos un desplazamiento hacia la izquierda
de dos bits, se convertiría en 00011100, en decimal: 28. Si no lo has notado ya,
te lo digo yo, desplazar bits hacia la izquierda es una manera rápida de
multiplicar por dos. Por otro lado, si desplazamos a la derecha, quedaría
00000001, los unos que ya no caben, se eliminan, como puedes ver. Análogamente
a lo anterior, desplazar a la derecha es equivalente a dividir entre dos (en
división entera, claro).

La mayor utilidad para esto es que nos permite establecer algo que los
informáticos llamamos \emph{flags}. Es decir, nos permite utilizar los bits de
una variable entera para indicar sendas variables lógicas. Por ejemplo, podemos
crear una función que serialice un objeto de tipo persona, con estas opciones:
\begin{enumerate}
\item Serializar con nombres legibles para personas, es decir,
<<apellido>> en lugar de, por ejemplo <<last\_name\_1>>.
\item Serializar con espacios o no entre caracteres de contro, es decir,
\verb!"last_name_1" : "Johnson"! en vez de \verb!"last_name_1":"Johnson"!.
\item Serializar en varias líneas.
\end{enumerate}

En general, si estas opciones \textbf{fueran excluyentes}, no se pudieran dar
dos juntas, podríamos codificarlas simplemente con un enumerado, pero como no
lo son, deben ser variables lógicas separadas, el problema es que esto
obligaría a que la función recibiera tres argumentos booleanos. Para esto
utilizaremos las \textit{flags}, vamos a asignar a cada opción un bit, y vamos
a crear un tipo enumerado donde cada opción tenga el valor de un entero
con ese bit puesto a uno. Para pasar varias opciones el usuario simplemente
debe hacer una disyunción a nivel de bit con las opciones.
Veamos la implementación de todo esto:

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C, label={lst:options},
caption={Implementación de opciones con operaciones a nivel de bit}]
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef enum {
    LEGIBLE_NAMES   = 1 << 0,
    CONTROL_ESPACES = 1 << 1,
    MULTIPLE_LINES  = 1 << 2
} serialization_options_t;

typedef struct person_s {
    char *name;
    char *last_name;
    unsigned int age;
} person_t;

char *serialize_person(const person_t *person,
                       serialization_options_t opts) {
    char *field_names_legible[] = {"Nombre", "Apellido", "Edad"};
    char *field_names_normal[]  = {"name", "last_name", "age"};
    char **field_names          = NULL;
    char *separator             = NULL;
    char *line_end              = NULL;

    bool legible   = opts & LEGIBLE_NAMES;
    bool espaces   = opts & CONTROL_ESPACES;
    bool multiline = opts & MULTIPLE_LINES;

    field_names = legible ? field_names_legible : field_names_normal;
    separator   = espaces ? " : " : ":";
    line_end    = multiline ? "\n" : "";

    char *fmt = "{%7$s\"%1$s\"%8$s\"%4$s\",%7$s"
                "\"%2$s\"%8$s\"%5$s\",%7$s"
                "\"%3$s\"%8$s%6$u%7$s}";

    char res[65536];
    sprintf(res, fmt, field_names[0], field_names[1], field_names[2],
            person->name, person->last_name, person->age, line_end,
            separator);
    return strdup(res);
}

int main(void) {
    person_t myself = {"Francisco", "Rodríguez", 26};
    char *text = serialize_person(&myself, MULTIPLE_LINES |
                                     LEGIBLE_NAMES | CONTROL_ESPACES);
    printf("%s\n", text);
    free(text);
}
\end{lstlisting}
\end{minipage}

El tipo enumerado de la línea 8 quizás asusta un poco, pero si recuerdas cuando
los explicamos, a un enumerado le puedes explicitar el valor numérico de cada
valor, aquí utilizamos el operador de desplazamiento a la izquierda para
crear valores que sólo tengan un bit a uno, en posiciones distintas. Podría
haberles asignado a mano los valores 1, 2 y 4, pero con el desplazamiento veo
mejor y no me equivoco al calcular porque sé que siempre tiene que salir
\verb!1 <<! y después el número consecutivo.

Después está la difinición de la estructura persona, que no tiene nada
especial. En la línea 20 llegamos a la función de serialización, como es normal,
recibe un puntero constante a la estructura que va a serializar y las opciones.
Al principio declaramos variables, nada fuera de lo normal. Lo interesante
empieza en la línea 28, estoy calculando variables booleanas para cada una de
las opciones, es decir, estoy decodificando las \textit{flags}. El modo es
simple, al hacer la conjunción de las opciones con cada opción individual,
el resultado será cierto si esa \textit{flag} está levantada, falso en otro
caso. Vamos a verlo rápidamente con la opción de la multilínea. Si
\verb!MULTIPLE_LINES = 1 << 2!, es decir 00000100, y  las opciones son, por
ejemplo, 00000101, al hacer la conjunción quedaría 00000100, es decir, un valor
distinto de cero y por tanto cierto.

En la siguientes línea utilizo un artefacto del lenguaje
que es útil cuando tienes muchas operaciones que se basan en valores lógicos.
Se llama operador ternario, y su nombre radica en que es un operador con tres
operandos, su sintaxis es como sigue: \verb!condition ? valor1 : valor2!,
el operador devolverá el \verb!valor1! si la condición es cierta, si no,
devolverá el \verb!valor2!. Ten cuidado, porque ambos valores deben tener el
mismo tipo. Aquí lo utilizo para definir los separadores de campo, de línea y
los nombres de los campos en la serialización.
El final de la función no tiene nada que no hayas visto antes, me aprovecho
mucho de utilizar aquí especificadores posicionales.

Finalmente, en la función \verb!main! llamamos a la de serialización con las
opciones, simplemente las unimos todas con una disyunción a nivel de bit.
Ten cuidado de no confundirte cuando utilices opciones y utilizar sin
intención un operador lógico.

Por otro lado, hay una operación que me gustaría comentarte aparte, que es
cuando tenemos la necesidad de bajar un \textit{flag} concreto de un conjunto de
opciones, por ejemplo, imagina que queremos serializar primero con todas las
opciones y después sin la opción de multilínea, podríamos crear las opciones
en ambas llamadas, pero si quisiéramos, podríamos guardar las opciones en una
variable, usarlas y después bajarle esa bandera. Para hacer esto hay que hacer
una conjunción con la negación de la bandera. Veamos cómo se haría:

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C, label={lst:setFlagOff},
caption={Ejemplo de bajada de una bandera}]
int main(void) {
    person_t myself = {"Francisco", "Rodríguez", 26};
    char *text      = NULL;

    serialization_options_t opts =
        LEGIBLE_NAMES | CONTROL_ESPACES | MULTIPLE_LINES;

    text = serialize_person(&myself, opts);
    printf("%s\n", text);
    free(text);

    opts = opts & ~CONTROL_ESPACES;

    text = serialize_person(&myself, opts);
    printf("%s\n", text);
    free(text);
}
\end{lstlisting}
\end{minipage}

Dicho así queda un poco contraintuitivo, veámoslos con este ejemplo, en la línea
12, \verb!opts! vale 00000111, la opción \verb!CONTROL_ESPACES! es 00000010,
si la negamos, quedaría 11111101, si haces la conjunción bit a bit de ese valor,
verás que todos quedarían como estuvieran en \verb!opts!, salvo el
correspondiente a \verb!CONTROL_ESPACES!, que será forzosamente cero porque
cualquier valor al que se le haga la conjunción con cero será cero.
Así es como bajas una bandera en una serie de opciones. Ten en cuenta que
para todas las operaciones a nivel de bit existen sus equivalentes de
asignación, es decir: \verb!|=!, \verb!&=!, \verb!~=!, \verb!<<=! y
\verb!>>=!, así que podríamos escribir la línea en cuestión aquí de este modo:
\lstinline[style=C]!opts &= ~CONTROL_ESPACES;!

\section{Algoritmos}
Un algoritmo, como ya explicamos en la introducción, es el conjunto de pasos
que debes seguir para conseguir un objetivo. Los programas que hemos hecho
tienen una serie de objetivos, que cumplen mediante algoritmos. En esta sección
quiero dar las primeras pinceladas sobre ellos, y, sobre todo, presentar
algunos que te permitan interiorizar algunos patrones de código. Además, en
secciones posteriores podremos utilizar estos simples algoritmos para introducir
conceptos más complicados (y útiles) del lenguaje.

Lo primero que vamos a ver es cómo expresar un algoritmo, un algoritmo se
a veces se expresa en lenguaje natural, es decir, como hablamos las personas,
si ya tenemos el código que lo ejecuta, también estamos expresando el algoritmo,
pero a veces es necesario utilizar herramientas intermedias, primero: porque
puede ser difícil codificar el algoritmo directamente sin pensarlo antes y,
segundo: porque hacer esto nos permite pensar en él sin tener que pensar en los
artefactos concretos del lenguaje que vamos a utilizar, lo que nos permite
dejar ese trabajo para más tarde.

Estas maneras intermedias son variopintas, por ejemplo, los diagramas del flujo
que utilicé en su momento son una de ellas. Otra manera es el
\textbf{pseudocódigo}, éste es un concepto que permite expresar los algoritmos
de modo estructurado, utilizando artefactos básicos de cualquier lenguaje de
programación: condicionales, bucles, llamadas a función... pero de una manera más
laxa. Veámoslo con un ejemplo: el algoritmo que nos permite eliminar las
repeticiones en un array expuesto en el programa \ref{lst:mallocAndFree}:
\nameref{lst:mallocAndFree}.

\begin{lstlisting}[style=pseudoCode]
algoritmo eliminar_repeticiones :=
entrada: array
solución = {}
para ii desde 0 hasta tamaño(array) - 1:
    elemento = array[ii]
    único = CIERTO
    para jj desde 0 hasta ii - 1:
        elemento2 = array[jj]
        si elemento es igual a elemento2:
            único = FALSO
    si único
        añadir elemento a solución
retornar solución
\end{lstlisting}

Como puedes ver, se entiende mejor lo que hace, porque nos estamos librando
de varios aspectos del lenguaje que no nos interesan, por ejemplo: asumimos
que podemos saber el tamaño del array sin necesidad de preocuparnos de dónde
viene; no tenemos que convertir las variables lógicas a números, podemos
asumir que añadir un elemento a un array es autoexplicativo, podemos ignorar
que hay reserva dinámica y simplemente decir que devolvemos el array. Visto
así, es un poco inútil, pero piensa que escribir esto \textbf{antes} de la
labor de codificación nos habría ayudado.

El problema del pseudocódigo es que podemos hacer <<trampas>>, es decir,
siempre podemos obviar varias cosas importantes que, a la hora de traducirlo a
código real, no sean triviales. Por eso, puedes decidir tú hasta qué punto
obvias o incluyes los artefactos del lenguaje. En este caso, por ejemplo,
podríamos incluir el asunto de que las dimensiones de los arrays no pueden
ser sabidos desde dentro de una función \textit{per se}.

\subsection{Recursividad}
A la hora de definir algunos algoritmos, se definen utilizándolos a ellos
mismos, es decir, parte de ellos incluye su propia utilización. Un ejemplo
clásico de este tipo de algoritmos es el número factorial. Sea $n$ un número
entero, $n$ factorial se denota como $n!$, que es igual a la multiplicación de
todos los números desde 1 hasta $n$. Es decir:

$$
n! = \prod^{n}_{i=1}{i}= 1\!\cdot\!2\!\cdot\!3\!\cdot\!4\dots{}n
$$

Siguiendo con el pseudocódigo, la manera de definir esto más evidente
es la \textbf{iterativa}, es decir, la que utiliza repeticiones mediante
bucles, las soluciones iterativas se contraponen frecuentemente a soluciones
\textbf{recursivas}. Veamos el pseudocódigo de esta manera de resolver el
problema:


\begin{lstlisting}[style=pseudoCode]
algoritmo factorial :=
entrada: n
resultado = 1
para i desde 1 hasta n:
    resultado = resultado*i
retornar resultado
\end{lstlisting}

Sin embargo; podemos sencillamente definir el factorial a partir de sí mismo,
volvamos a su definición matemática:
$$
n! = \prod^{n}_{i=1}{i}= n\!\cdot\!\!\prod^{n-1}_{i=1}{i} = n\left(n-1\right)!
$$

Entonces, si seguimos con este razonamiento, podemos definir el pseudocódigo
como:

\begin{lstlisting}[style=pseudoCode]
algoritmo factorial :=
entrada: n
si n es igual a 0:
    retornar 1
retornar factorial(n - 1) * n
\end{lstlisting}

Si saltamos a la implementación, veremos que es tan sencillo como que la función
se llama a sí misma. Como ya bien sabes, una función puede llamar a otra, y así
sucesivamente, pero nada dice que esa función no se llame a sí misma. El
único problema que tiene esto es que, si se diseña mal, se puede incurrir en
llamadas infinitas, esto provocaría que, como cada llamada sin finalizar
que se acumula añade a datos a la pila, ésta terminara por acabarse y nuestro
programa fallaría.
Para ver la comparación en la implementación con ambas soluciones, crearemos
dos versiones de la misma función, la iterativa y la recursiva, a la primera
la llamaremos \texttt{factorial\_interative} y a la segunda
\texttt{factorial\_recursive}.


\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C, caption={Ejemplo final de variables},
label={lst:factorialIterativeVsRecursive}]
unsigned long factorial_recursive(int n)
{
    if (n == 0) {
        return 1;
    }
    return factorial_recursive(n - 1) * n;
}

unsigned long factorial_iterative(int n)
{
    if (n == 0) {
        return 1;
    }
    unsigned long res = 1;
    for (int i = 1; i <= n; ++i) {
        res *= i;
    }
    return res;
}
\end{lstlisting}
\end{minipage}

Este ejemplo es tan clásico porque se aprecian bien las diferencias de las dos
formas de resolver el problema y, además, se aprecian bien las partes de una
función recursiva. Una función recursiva, en términos generales, debe tener dos
componentes: un caso base y la llamada (o llamadas) recursivas.
El primero está aquí
representado por el condicional, una función recursiva se basa en utilizar
una definición circular, es decir, defines una función usándola a ella misma,
para poder salir de ese ciclo, debe haber un momento en que demos la respuesta
por sabida. Este caso base es cuando $n$ es igual a cero, caso en que la respuesta
es inmediata porque sabemos por definición matemática que es 1. La llamada
recursiva es la siguiente línea.

Comparando las dos soluciones, la primera es lo que se llama más <<elegante>>,
en el sentido de que es una definición más legible (tanto así que podría decirse
que es trivial) mientras que la iterativa es más larga y menos trivial. Sin
embargo; es en general más eficiente la versión iterativa de un algoritmo que
su versión recursiva. Esto es porque las sucesivas llamadas a función tienen
cierto coste, obligan a hacer copias de datos, cada vez que invoques a la
función, $n$ será copiada en la pila, una copia encima de otra, hasta que llegues
a la invocación del caso base. En ese momento, la llamada del caso base
retornará y se empezará a desenrollar esa sucesión de llamadas a la función.

Por contraposición, la solución iterativa no tiene esa necesidad de copiar nada,
ni de ir llamando a funciones una y otra vez, es un simple bucle. Es razonable
pensar que la primera será más lenta. Déjame que lo compruebe y te dé los
resultados para que puedas verlo. La solución recursiva tarda 1,7431 veces más
que la solución iterativa, por lo que se puede apreciar que es más lenta.
Además, recuerda la pila, utiliza más memoria.
En resumen: los algoritmos iterativos son más rápidos que sus contrapartes
recursivas, pero menos elegantes.

Otro ejemplo más claro de las diferencias entre ambos métodos se puede ver en
el cálculo de la sucesión de Fibonacci. Someramente: esta sucesión fue creada
por un matemático italiano en el siglo \textsc{xiii}, cuyo nombre da a esta
sucesión. Es una sucesión que se define así: los dos primeros elementos son 1,
y los demás se definen como la suma de los dos anteriores (ya
se ve que aquí hay un caso base y una definición recurrente). Matemáticamente se
definiría así:
$$
a_1 = 1, a_2 = 1, \forall_{n=3}^{\infty}\left(a_n = a_{n-1} + a_{n-2}\right)
$$

Creo que entiendes que esto, iterativamente, se puede resolver con un bucle,
como el cálculo del factorial. Así que saltemos a la definición recursiva:


\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C, caption={Función para el cálculo de la suceción
de Fibonacci},
label={lst:funFibonacci}]
unsigned long fibonacci(unsigned int n) {
    if (n < 3) {
        return 1;
    }
    return fibonacci(n - 1) + fibonacci(n - 2);
}
\end{lstlisting}
\end{minipage}

Como puedes ver, seguimos el mismo patrón: un condicional que comprueba el caso
base y una llamada recursiva. El caso base es lógico, el primer y segundo
elemento son uno, así que se devuelve uno siempre que $n$ sea menor que tres.
Por otro lado, esto hace que también devolvamos uno cuando se introduce cero,
pero esto es una simplificación que nos podemos permitir. Es la llamada
recursiva la que nos interesa, como puedes ver, hay dos llamadas a esta función
por cada llamada que no sea un caso base. Esto es importante, porque debes tener
claro en qué orden se ejecutan estas llamadas, por esto, vamos a representarlo
aquí.
\begin{itemize}
\item Llamamos a la función para el valor 5
    \begin{itemize}
        \item Se llama a la función para el valor 4
        \begin{itemize}
            \item Se llama a la función para el valor 3
            \begin{itemize}
                \item Se llama a la función para el valor 2
                \item Se devuelve 1.
            \end{itemize}
            \begin{itemize}
                \item Se llama a la función para el valor 1
                \item Se devuelve 1.
            \end{itemize}
            \item Se devuelve 2
        \end{itemize}
        \begin{itemize}
            \item Se llama a la función para el valor 2
            \item Se devuelve 1.
        \end{itemize}
    \item Se devuelve 3
    \end{itemize}
    \begin{itemize}
        \item Se llama a la función para el valor 3
        \begin{itemize}
            \item Se llama a la función para el valor 2
            \item Se devuelve 1.
        \end{itemize}
        \begin{itemize}
            \item Se llama a la función para el valor 1
            \item Se devuelve 1.
        \end{itemize}
        \item Se devuelve 2
    \end{itemize}
    \item Se devuelve 5
\end{itemize}

Estas listas anidadas expresarían cómo funciona la secuencia de llamadas a las
funciones recursivas. Puedes observar varias cosas, la primera es que, incluso
para una llamada pequeña, el quinto elemento, se realiza un gran número de
llamadas a función. Por otro lado, si lo miras bien, se repiten un montón de
cálculos, la llamada para tres se repite dos veces, la llamada a dos tres
veces... y esto sólo para el valor de $n$ igual a cinco. Esto te da la medida
de que la implementación recursiva de este tipo de funciones es muy ineficiente.
Técnicas más avanzadas permiten mitigar esto. En conclusión, es
muy poco recomendable realizar esta implementación.

Y, si esto es así, si los algoritmos recursivos son así de ineficientes, lo
lógico sería pensar que no se utilizan. Sí, se utilizan porque hay algoritmos
que están definidos simplemente de un modo recursivo, es decir, que no es
posible implementar iterativamente (o dicha implementación sería una
simulación de la recursividad que aportaría poco), pero esos algoritmos son más
complicados y serían problemáticos como primeros ejemplos del concepto de
recursividad.

\subsection{Algoritmos de ordenación}
Uno de los conjuntos de algoritmos más elementales que existen en el conjunto
básico de algoritmos de ordenación, entre ellos veremos los siguientes:
\begin{enumerate}
\item De burbuja.
\item Selección.
\item Inserción.
\item \textit{Quick sort}.
\end{enumerate}
Esto es así porque esta tarea (ordenar un vector o array) es muy común y permite
una enorme cantidad de innovación, muchos autores de trabajos científicos se
esfuerzan en proponer mejoras en estos algoritmos. Además, es una operación
muy común y básica en la informática. Los primeros algoritmos son más bien
sencillos, así que hablaremos directamente sobre la implementación en C, pero
los dos últimos necesitarán de una explicación más pausada.

El algoritmo de la burbuja se basa en comparar cada elemento con el siguiente
y, si no están en orden, intercambiarlos. Veamos cómo se haría:

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Implementación del algoritmo de la burbuja},
label={lst:bubbleSort}]
void bubble_sort(int *list, int list_size) {
    for (int ii = 0; ii < list_size - 1; ++ii) {
        for (int jj = 0; jj < list_size - 1; ++jj) {
            if (list[jj] > list[jj + 1]) {
                int aux = list[jj];
                list[jj] = list[jj + 1];
                list[jj + 1] = aux;
            }
        }
    }
}
\end{lstlisting}
\end{minipage}

Es el algoritmo de ordenación más simple, porque, como puedes ver, se compone
de dos bucles anidados y un condicional. Rápidamente: recorres el array,
pero como estás comparando con el siguiente elemento, paras una posición antes.
Si el elemento anterior (\verb!list[jj]!) es mayor que el que viene después,
los cambias. Para cambiarlo simplemente guardas uno en una variable auxiliar,
asignas el otro al primero y finalmente pones la variables auxiliar en el
hueco libre. Esto, hecho una sola vez, provocaría que el elemento más grande
subiera al último puesto del array. Y he usado el verbo subir porque es de
este tránsito del que deriva el nombre del algoritmo, porque los elementos
suben como burbujas de aire en el agua.
De hecho, puedes probar
a ejecutar la función cambiando la condición del primer bucle a \verb!ii < 1!.
Y verás como sólo el último elemento está siempre en orden.

Este algoritmo tiene una ventaja fundamental: utiliza muy poca memoria. Es más,
si obviamos las variables auxiliares, los argumentos en la pila y demás, la
única memoria ocupada es la variable auxiliar, es decir, el tamaño del tipo
de dato que estés ordenando, en este caso: cuatro bytes. En informática casi
siempre se hace un compromiso (en inglés: \textit{trade-off}) entre memoria y
velocidad. Los algoritmos que consumen más memoria para hacer lo mismo suelen
ser más rápidos que los diseñados para ocupar poca memoria. El algoritmo de
la burbuja es un ejemplo claro.

Como añadido, vamos a prestar atención a la realización del intercambio de
elementos: como es algo que voy a usar en todos o casi todos los algoritmos,
vamos a crear una función llamada \verb!swap!, que nos permita intercambiar
rápidamente dos elementos de tipo entero. Veamos cómo quedaría el algoritmo
de la burbuja y cómo sería la definición de la función.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Implementación de \texttt{swap} y uso en algoritmo de la burbuja},
label={lst:bubbleSwap}]
void swap(int *a, int *b)
{
    int aux = *b;
    *b = *a;
    *a = aux;
}

void bubble_sort(int* list, int list_size)
{
    for (int ii = 0; ii < list_size - 1; ++ii) {
        for (int jj = 0; jj < list_size - 1; ++jj) {
            if (list[jj] > list[jj + 1]) {
                swap(&list[jj], &list[jj + 1]);
            }
        }
    }
}
\end{lstlisting}
\end{minipage}

El siguiente algoritmo es el de selección. Este algoritmo se basa en elegir
(seleccionar) el elemento menor y ponerlo en la última posición del array
que tengamos ordenada. Al principio no hay ninguna, cuando hayas puesto una,
deberás poner el siguiente elemento después de esa, y así sucesivamente,
veámoslo:

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Algoritmo de selección},
label={lst:selectionSort}]
void selection_sort(int *list, int list_size)
{
    int ordered = 0;
    while (ordered < list_size) {
        int min_value = list[ordered], min_pos = ordered;
        for (int jj = ordered; jj < list_size; ++jj) {
            if(list[jj] < min_value){
                min_value = list[jj];
                min_pos = jj;
            }
        }
        swap(&list[ordered], &list[min_pos]);
        ++ordered;
    }
}
\end{lstlisting}
\end{minipage}

Esta implementación es un poco ingenua, porque nunca comprobamos si el elemento
siguiente al ordenado resulta estar ordenado. Es evidente que una implementación
un poco más inteligente añadiría una variable para discernir esto, queda como
ejercicio. Con la implementación que tenemos, podemos ver bien cómo funciona,
que es lo que nos interesa. La quinta línea es un poco complicada porque junto
dos declaraciones con sus inicializaciones, pero ya hay que ir acostumbrándose.

Si te das cuenta, este algoritmo ocupa marginalmente más memoria que el de la
burbuja. En este caso debemos mantener siempre en memoria el valor y la
posición del elemento más pequeño. En cambio, es un poco más rápido, ¿por qué?
Porque en el peor de los casos, este algoritmo hace $n!$ comparaciones y
$n$ intercambios. En el algoritmo de la burbuja haremos las mismas comparaciones
y, sin embargo, haremos muchos más intercambios, porque los elementos van
<<pasito a pasito>>, no a su lugar directamente como en este caso.

El siguiente algoritmo es el de inserción. En el anterior elegíamos el elemento
más pequeño y lo poníamos al principio, en este, el razonamiento es el
contrario, crearemos una lista que definiremos como ordenada, inicialmente
vacía, después, cogeremos un elemento de la lista original y lo insertaremos
en la posición que le corresponda en la lista ordenada. De este modo, la lista
ordenada siempre permanecerá así. Veamos un pseudocódigo más claro:

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=pseudoCode]
algoritmo insertion_sort :=
entrada: array
lista_ordenada = {}
para i desde 0 hasta size(array):
    insertar_ordenado(lista_ordenada, array[ii])
array = lista_ordenada
\end{lstlisting}
\end{minipage}

El problema de esto es que insertar en una lista ordenada es algo lo
suficientemente complejo como para necesitar su propia definición. Vamos
a definir un algoritmo que inserte un elemento en una lista, pero que
\textbf{cuenta con que ya está reservada la memoria}.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=pseudoCode]
algoritmo insertar_ordenado :=
entrada: array, elemento
insertado = 0
para i desde 0 hasta size(array):
    si array[ii] es mayor que elemento:
        insertar(array, elemento, ii)
        insertado = 1
        break
si no insertado:
    insertar(array, elemento, ii)
\end{lstlisting}
\end{minipage}

Pero seguimos teniendo el problema de cómo insertar, en general, un elemento
en una posición dada, para esto utilizaremos otro algoritmo:

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=pseudoCode]
algoritmo insertar :=
entrada: array, elemento, posición
insertado = 0
para i desde size(array) hasta 0 en paso de -1:
    array[ii] = array[ii - 1]
array[posición] = elemento
\end{lstlisting}
\end{minipage}

Es un poco confuso, pero lo que hacemos es, primero, mover los elementos
posteriores a la posición donde queremos insertar una posición a la derecha,
abriendo así el hueco para el nuevo elemento, después, insertamos el elemento.
Como puedes ver, ya en este algoritmo tenemos que hacer acopio de una serie
de funciones intermedias. Aunque este algoritmo se suele implementar
de un modo más sencillo, aquí lo vamos a hacer así para que empieces a ver
la utilidad de extraer el comportamiento en funciones más pequeñas que se
entiendan mejor en vez de escribir funciones muy largas. La implementación
de las funciones auxiliares sería tal que:


\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Algoritmos auxiliares al de inserción},
label={lst:insertionAuxiliar}]
void insert_at(int* list, int list_size, int position, int element)
{
    for(int ii = list_size; ii != position; --ii){
        list[ii] = list[ii-1];
    }
    list[position] = element;
}

void insert_at_ordered(int* list, int list_size, int element) {
    int inserted = 0;
    for(int ii = 0; ii < list_size; ++ii){
        if(list[ii] > element){
            insert_at(list, list_size, ii, element);
            inserted = 1;
            break;
        }
    }
    if(!inserted){
        insert_at(list, list_size, list_size, element);
    }
}
\end{lstlisting}
\end{minipage}


\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Algoritmo de inserción},
label={lst:insertionSort}]
void insertion_sort(int* list, int list_size)
{
    int ordered_list[list_size];
    int ordered_size =0;
    for (int ii = 0; ii < list_size; ++ii) {
        insert_at_ordered(ordered_list, ordered_size, list[ii]);
        ordered_size++;
    }
    memcpy(list, ordered_list, sizeof(int) * list_size);
}
\end{lstlisting}
\end{minipage}

Este algoritmo es el que usamos inconscientemente para ordenar objetos físicos
cuando los tenemos. Si tuvieras los números $\left\{5,4,6,9,8\right\}$,
probablemente cogerías el cinco y lo pondrías después del cuatro, verías que el
seis está en orden, después verías el nueve y lo pondrías detrás del ocho.
De todos modos, si has pensado que lo que tú harías sería selección, sí, sería
posible que te resultara cómodo hacer eso también.

Pero la manera en que lo hemos implementado es muy ingenua, utilizamos muchos
más pasos de los necesarios. Hay una manera más sencilla si nos damos cuenta
de que podemos realizar todas las operaciones en la misma lista. Para ello
voy a ponerte un ejemplo, imagínate la lista:
\begin{tabular}{|c|c|c|c|c|}
\hline
\textbf{2}&\textbf{6}&2&5&7\\\hline
\end{tabular}

Las celdas en negrita son los elementos de la lista ordenada, lo que vamos
a hacer es guardanos el siguiente elemento después de ellos en una variable,
es decir, el dos. Después, vamos a mover todos los elementos de la lista ordenada
mayores que dos una posición a la derecha, quedando el array así:
\begin{tabular}{|c|c|c|c|c|}
\hline
\textbf{2}&\color{white}2\normalcolor&\textbf{6}&5&7\\\hline
\end{tabular}.
Con una posición vacía, como puedes ver. Ese hueco se utiliza
para colocar el elemento que está en la variable que hemos mencionado antes,
quedando el array así:
\begin{tabular}{|c|c|c|c|c|}
\hline
\textbf{2}&\textbf{2}&\textbf{6}&5&7\\\hline
\end{tabular}
Si sigues a mano esta ejecución verás que nos guardaríamos el cinco, moveríamos
el seis, pondríamos el cinco a la izquierda del seis; nos guardaríamos el siete
volveríamos a mover el seis, pondríamos siete en el hueco libre y el array
quedaría ordenado. La implementación de esto sería, por ejemplo, la siguiente:

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C, label={lst:insertionOptimized},
caption={Implementación alternativa de ordenación por inserción}]
void insertion_sort_optimized(int *array, int array_size)
{
    int element;
    for (int ii = 1; ii < array_size; ii++) {
        element = array[ii];
        int jj;
        for (jj = ii - 1; jj >= 0; --jj) {
            if (array[jj] <= element) {
                break;
            }
            array[jj + 1] = array[jj];
        }
        array[jj + 1] = element;
    }
}
\end{lstlisting}
\end{minipage}

La lógica de esto quizá es menos evidente. El bucle exterior es
muy sencillo, recorremos todo el array \textbf{desde la segunda posición}.
Nos guardamos el elemento siguiente a los ordenados en la variable
\verb!element!. Después, en este bucle \verb!for! interno moveremos todos los
elementos de la lista ordenada a la derecha una posición, en orden inverso,
por eso \verb!jj! disminuye de uno de uno. Cuando hemos encontrado el elemento
que es mayor, paramos (\verb!break!). Finalmente, ponemos el elemento en su
sitio.

Finalmente, llegamos al algoritmo \textit{Quick Sort}, que, como puedes ver,
no se basa en cómo lleva a cabo la tarea de ordenación sino por una cualidad
muy interesante del mismo: es un algoritmo muy rápido. Si recuerdas lo que he
dicho unos párrafos antes, en informática, velocidad y memoria ocupada son
valores ortogonales (perpendiculares, cuando uno se propicia, es en detrimento
del otro). Me interesa especialmente que lo veas porque \textbf{es un algoritmo
recursivo}. Y es uno de esos algoritmos que es puramente así.
Además, como es más complejo (como probablemente hayas podido deducir), vamos a
ver primero su pseudocódigo.


\noindent
\begin{minipage}[H]{\linewidth}
\begin{lstlisting}[style=pseudoCode]
algoritmo quick_sort :=
entrada: array
lista_pequeña = {}
lista_grande  = {}
pivote        = array[0]
si size(array) es igual a 1:
    res = {pivote}
    retornar res
para i desde 0 hasta size(array):
    si array[i] es menor que pivote:
        añadir(array[i], lista_pequeña)
    en otro caso:
        añadir(array[i], lista_grande)
lista_pequeña_ordenada = quick_sort(lista_pequeña)
lista_grande_ordenada  = quick_sort(lista_grande)
res = juntar(lista_pequeña_ordenada, pivote, lista_grande_ordenada)
retornar res
\end{lstlisting}
\end{minipage}

Este algoritmo se resume en lo siguiente: el caso base es cuando la lista
es de tamaño uno, porque una lista de un elemento siempre está ordenada.
Cuando no estamos en el caso base, creamos dos listas: en una irán los elementos
menores que el pivote, y en otra los demás. El pivote es sencillamente un
elemento cualquiera de la lista, a este nivel es irrelevante cuál, aunque
su elección influye mucho en la eficiencia del algoritmo en casos especiales,
es decir, con arrays concretos.
La implementación de este algoritmo es la siguiente:

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Implementación de \textit{Quick Sort}},
label={lst:quick_sort}]
int *quick_sort(int *list, int list_size)
{
    int *biggers          = NULL, *smallers         = NULL,
        *biggers_ordered  = NULL, *smallers_ordered = NULL,
        *res              = malloc(list_size * sizeof(int));

    int bigger_size = 0, smaller_size = 0, pivot = 0;

    if (list_size == 1) {
        *res = list[0];
        return res;
    }

    if(list_size == 0){
        return NULL;
    }

    pivot = list[0];
    biggers = malloc(sizeof(int) * list_size);
    smallers = malloc(sizeof(int) * list_size);

    for (int ii = 1; ii < list_size; ++ii) {
        if (list[ii] < pivot) {
            smallers[smaller_size] = list[ii];
            smaller_size++;

        }
        else {
            biggers[bigger_size] = list[ii];
            bigger_size++;
        }
    }

    biggers  = realloc(biggers, sizeof(int) * bigger_size);
    smallers = realloc(smallers, sizeof(int) * smaller_size);

    biggers_ordered  = quick_sort(biggers, bigger_size);
    smallers_ordered = quick_sort(smallers, smaller_size);

    memcpy(res, smallers_ordered, sizeof(int) * smaller_size);
    res[smaller_size] = pivot;
    memcpy(res + smaller_size + 1,
               biggers_ordered, sizeof(int) * bigger_size);

    free(biggers);
    free(smallers);
    free(smallers_ordered);
    free(biggers_ordered);
    return res;
}
\end{lstlisting}
\end{minipage}

El algoritmo es un poco más complicado así que lo que era en el pseudocódigo,
pero debes seguirlo paralelamente a aquél. Lo primero es la declaración de todas
las variables. De nuevo, vamos a empezar a declarar varias juntas, o si no las
funciones de harían interminables. Nota que inicializamos sin comprobar
nada la variable \texttt{res} (que es donde guardaremos el resultado)
llamando a \texttt{malloc} para reservar un vector del mismo tamaño de la lista.
No hay peligro porque llamar a \texttt{malloc} para reservar cero bytes es
totalmente seguro. Después, como ya es normal en nuestras funciones recursivas,
comprobamos si estamos o no en el caso base, el caso base es tanto una lista
que mida uno como una lista vacía. Ambas listas están ordenadas por definición.

Después, empieza el caso recursivo, lo primero es leer el valor del pivote,
lo hacemos ahora porque antes de comprobar el tamaño de la lista no sabemos
si hay primer elemento. Ahora reservamos memoria para las listas de los
elementos mayores y menores que el pivote respectivamente. Esto también lo hemos
visto antes: como no sabemos cuánto pueden medir, utilizamos un umbral superior,
en este caso es evidente que ninguna de estas listas puede medir más que el
tamaño de la lista original. Después entramos en el bucle que cribará qué
elementos van a cada lista. Como aquí estamos limitados por las restricciones de
C, tenemos que hacerlo así: copiamos el elemento en cuestión a la posición
siguiente al final de la lista (que es igual a su tamaño) y aumentamos
en uno el tamaño. Cuando hemos terminado el bucle, procedemos a redimensionar
las listas de elementos mayores y menores al tamaño real que deben tener. Del
mismo modo que con \verb!malloc!, si se llama con un tamaño de cero no hay
problemas, además, es equivalente a llamar a \verb!free!, pero el puntero
sigue siendo válido para pasarse a esta función.

Ahora que ya tenemos ambas listas, simplemente llamamos al mismo \textit{Quick
Sort} que nos otorgará las listas ordenadas. Del mismo modo que cuando
te expliqué cómo utilizar \verb!memcpy!, copiamos juntos la lista de elementos
menores, el pivote y la lista de elementos mayores. Una vez hecho esto, sólo
nos queda liberar la memoria que hemos utilizado para almacenar datos
auxiliares. En este caso, las cuatro listas. Es evidente que con todas estas
reservas de memoria este algoritmo consume mucho más que los anteriores, pero,
además, recuerda lo que pasa con las funciones recursivas, esta memoria que
hemos reservado se quedará bloqueada hasta que se terminen las llamadas
recursivas, es decir, cada llamada tendrá sus propias copias de las listas.
Esto explica, además, por qué \textit{Quick Sort} es un algoritmo que
no modifica la lista que se le pasa sino que
\textbf{devuelve el resultado en otra}.

Ahora que ya hemos visto el algoritmo conceptual y la implementación de los
algoritmos de ordenación, vamos a comparar su rendimiento en términos de tiempo
de ejecución. Lo que voy a hacer es crear un vector de un tamaño grande, lo voy
a ordenar con un algoritmo, volveré a introducir datos aleatorios en el vector,
lo volveré a ordenar y así sucesivamente. Los resultados son, para 262.144
elementos:

\begin{table}[H]
\begin{tabularx}{\linewidth}{|Y|R|}
\hline
\textbf{Algoritmo}    &\multicolumn{1}{c|}{\textbf{Tiempo $(s)$}}\\\hline
Burbuja               &243,0596                                \\\hline
Selección             &71,2807                                 \\\hline
Inserción             &56,7917                                 \\\hline
Inserción (optimizado)&37,1698                                 \\\hline
\textit{Quick Sort}   &0,0656                                  \\\hline
\end{tabularx}
\caption{Tiempos de ejecución de los distintos algoritmos}
\label{tab:sortingTimes}
\end{table}

Como puedes ver, en cada algoritmo se realiza una mejora bastante importante
respecto al anterior, pero es muy llamativo que \textit{Quick sort} destaque
tanto. Como reflexión: yo no le pondría a un algoritmo que he hecho yo
un nombre tan poco modesto si no fuera al menos mayormente cierto. Sin embargo;
hay ciertos aspectos que hay que tener en cuenta en un algoritmo como estos
más allá de que sean rápidos, por ejemplo, como ya dijimos, \textit{Quick sort}
consume mucha más memoria que todos los demás. Si utilizáramos este algoritmo
en ciertas máquinas quizás nos viéramos con problemas de memoria. Además, hay
una cualidad de los algoritmos llamada \textbf{estabilidad}, que representa
cómo de constante para diferentes casos es el uso de tiempo, memoria, o ambas.
En el caso de estos algoritmos, los únicos estables son el de burbuja y el de
selección. Esto quiere decir que los resultados de los demás pueden variar mucho
en ciertos casos, por lo que si trabajas en sistemas donde esos casos ocurren
con cierta frecuencia o donde la estabilidad es más importante
que la velocidad media, quizás debas usar uno de los
algoritmos más lentos.

El ejemplo más flagrante de esto es lo que le pasa al último algoritmo con
el vector más desfavorable. Para \textit{Quick sort} el peor caso es, irónicamente,
un array que ya esté ordenado (o que esté ordenado inversamente). Si vuelves a
su descripción o a su implementación, verás fácilmente
por qué, al elegir el primer elemento como pivote,
si está ordenado, consistentemente todos los elementos caerán en la lista de
elementos mayores, es decir, por cada nivel de recursividad sólo disminuiremos
el vector en una posición. Eso implica que, en este caso, para un vector de mil
posiciones, haremos mil llamadas recursivas que harán sendas copias del vector
midiendo éstas mil, 999, 998, etc. Eso es insostenible a la mínima que el
vector sea muy grande. Vamos a comparar el algoritmo de selección
(que es estable), con \textit{Quick Sort} en un vector ya ordenado.

El primer hecho que te llamará la atención es que no puedo utilizar la misma
cantidad de elementos que en la comparación anterior, esto es porque mi
ordenador no cuenta con memoria suficiente para que \textit{Quick Sort} termine
bajo estas condiciones. He utilizado un vector de 65.536 elementos. El
algoritmo de selección tarda 4,58 segundos y \textit{Quick Sort} tarda, ni más
ni menos que 21,55. Aquí es donde entra en juego la estabilidad, selección
es de media peor, pero nunca tarda mucho más. De hecho, como sí que puedo
ejecutar el algoritmo de selección sobre 262.144, vamos a que cuánto tarda y
compararlo con el resultado bajo el vector aleatorio.

Selección tarda 72,05 segundos, como puedes ver, casi exactamente lo mismo
que con un vector aleatorio. Además, el consumo de memoria es siempre el mismo,
cualidad que comparte con los algoritmos anteriores a él.
Esto demuestra que hay que tener
en cuenta más factores aparte de lo rápido que sea un algoritmo, pero todas
estas cosas sería objeto de un libro en sí mismo y de un curso de agoritmia que
no ha lugar, el motivo de esta sección es más bien enunciar la existencia de
este tipo de problemas y mostrar la importancia de la elección e implementación
de algoritmos para tareas incluso tan prosaicas como ordenar un array.

\subsection{Búsqueda}
La búsqueda es otra de las tareas más importantes de un informático o
programador, pero la búsqueda depende de dónde estés buscando. Hasta ahora sólo
conocemos la estructura del array o del vector, que en relación a la búsqueda
son indistinguibles. La búsqueda es, dado un valor, encontrar en la estructura
el valor dado, o la primera ocurrencia de él. Es evidente cómo resolver este
problema en general, un bucle que compruebe si el elemento concreto del vector
es igual al elemento que queremos buscar. Si esto es así, se devuelve el
índice donde se encuentra, si no, se devuelve un valor que generalmente es -1
o cualquier negativo.

Pero hay una manera de buscar más rápidamente en un array o vector, si éste está
ordenado, puedes buscar con la búsqueda binaria. Se llama binaria porque te
mueves en dos direcciones: empiezas en el medio del array y compruebas si éste
es menor que el que buscas, vas hacia delante en el array un cuarto de su
longitud, repites la operación y vuelves a dividir entre dos la distancia que
saltas. Veamos el pseudocódigo.


\noindent
\begin{minipage}[H]{\linewidth}
\begin{lstlisting}[style=pseudoCode]
algoritmo búsqueda_binaria :=
entradas: array, objetivo

mientras array no es igual a {}:
    pos = centro(array)
    elemento = array[pos]
    si elemento es igual a objetivo:
        retornar pos
    si elemento es menor que objetivo:
        array = mitad_después(array, pos)
    si elemento es mayor que objetivo:
        array = mitad_antes(array, pos)

retornar -1
\end{lstlisting}
\end{minipage}

Básicamente, aprovechamos que el array o vector está ordenado para que, cuando
elegimos una posición, sepamos que necesariamente el elemento que buscamos
está en la mitad del array que quede después o antes de este elemento. Dividimos
pues el tamaño del problema entre dos en cada iteración de este proceso hasta
que queda sólo el elemento que buscamos (si sólo hay uno) o nada, y por tanto
no existe el elemento.


\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Implementación del algoritmo de búsqueda lineal},
label={lst:binarySearch}]
int binary_search(int* array, int array_size, int target)
{
    int low_end = 0;
    int high_end = array_size;
    while (high_end != low_end) {
        int pos = (high_end - low_end) / 2 + low_end;
        int element = array[pos];
        if (element == target) {
            return pos;
        }
        else if (element < target) {
            low_end = pos;
        }
        else if (element > target) {
            high_end = pos;
        }
    }
    return -1;
}
\end{lstlisting}
\end{minipage}

Como en C dividir arrays es complicado, vamos a realizar el juego con las
posiciones. Definimos un umbral inferior y otro superior que serán
los límites de la zona donde queremos buscar (la parte del array donde
puede estar el elemento buscado). Lo que hacemos es siempre situarnos
en el medio de esa zona del array y comprobar si hemos dado con el elemento
que queremos, si no, vemos si es menor o mayor que donde estamos. Si el objetivo
es mayor que donde estamos, movemos el límite inferior aquí,
decir: sabemos que lo que buscamos no puede estar antes de la posición actual.
Si el objetivo es menor, sabemos que debe estar antes. Si en algún momento los
límites colisionan, es que nos hemos quedado sin zona que buscar y devolveremos
-1.

La ventaja que tiene este algoritmo reside en un comentario que he dejado caer
unos pocos párrafos atrás, cada vez que comprobamos si un elemento es el que
buscamos, dividimos el problema entre dos. Esto quiere decir que, de media,
haremos $\log_{2}{\left(n\right)}$ comprobaciones. En el caso de la búsqueda <<normal>>, en
cualquier array, de media haremos $\frac{n}{2}$ comprobaciones. Esto hace que
sea un algoritmo más deseable, aunque hay que tener en cuenta que el array
debe estar ordenado, y si no lo estaba, esto tiene un coste. Lo ideal es
que se utilice con arrays que se mantengan siempre ordenados, es decir, donde
las inserciones se hagan ordenadas, pero eso tiene un coste a su vez porque
hay que mover los elementos en la operación de inserción.

%\subsection{Cómo dividir funcionalidad entre distintos archivos}
%Aunque esto es en sentido estricto un manual de programación, y no de
%ingeniería del \emph{software}, tenemos que hablar de algunos consejos sobre
%cómo dividir tu funcionalidad en distintos archivos, ahora que ya saber hacerlo.
%Como la mejor manera de aprender a montar en bicicleta es montando, vamos a
%utilizar un ejemplo para ver de qué manera podemos dividir entre archivos
%funcionalidades distintas. Vamos a hacer un programa que calcule el camino
%más corto entre en un punto A y un punto B en un mapa. Para ello, deberemos
%hacer estas cosas:
%
%\begin{enumerate}
%\item Crear mapas
%\item Guardar mapas en un archivo y leerlos de él
%\item Encontrar el camino de un punto A al punto B sabiendo que es el más corto.
%\end{enumerate}
%
%En general, lo primero que se suele hacer cuando te encuentras con un problema
%complejo es preguntarse qué vamos a modelar en nuestro sistema. Un modelo es,
%en términos generales, una simplificacion de la realidad que nos permite
%entenderla y actuar sobre ella o predecirla. En informática, cuando tienes una
%realidad, lo primero es crear un modelo de datos que nos permita manejarlo
%dentro del lenguaje de programación.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Algoritmos genéricos}
Ahora que ya sabemos qué es un algoritmo en sus términos más elementales y
que conocemos algunos con una complicación suficiente como para retarnos,
podemos dar un paso más: hacer que estos algoritmos sean más <<puros>>, sean
simplemente un conjunto de instrucciones, pero sean ignorantes de qué tipo
de dato van a recibir o de qué operación van a realizar. Dicho así, esto es
confuso, pero lo vas a entender fácilmente. En la sección anterior hemos
implementado varios algoritmos que manejan arrays, y, aunque no lo he dicho,
si retrocedes ahora y miras el código de ejemplo, siempre verás que son
arrays o vectores de enteros, nunca de otro tipo de dato. El problema es que,
como supondrás, el proceso de ordenación de un array de enteros es similar
al de un array de cualquier tipo de dato que admita ordenación. Por ejemplo,
de decimales.

Pensarás que, entonces, siempre podemos copiar el código de la ordenación de
elementos de tipo \verb!int! y sustituir \verb!int! por \verb!double!.
Podríamos, pero esta manera de proceder tiene un defecto muy problemático:
duplica código. Duplicar código es malo por dos motivos: hace nuestros
ejecutables más grandes, y nuestro código en general \textbf{menos mantenible}.
Dicho en términos entendibles, es más difícil que le pases ese código a alguien
y lo entienda rápido y, en caso de haber un error o comportamiento no definido,
lo resuelva rápido. Imagínate que encontramos un error en la implementación de
la función de ordenación, sea la que sea. Tendríamos que rastrear a mano todas
las copias para eliminar ese error. Además, somos programadores:
nuestro objetivo es hacer más con menos.

Para esto tenemos dos herramientas genéricas, la primera es el puntero a
\verb!void!. Cuando te prensenté el puntero a \verb!NULL! y la reserva
de memoria dinámica te dije que \verb!malloc! devuelve un puntero a \verb.void.
que luego se convertirá a cualquier tipo que necesites. Es decir, el puntero
a \verb.void. se convierte implícitamente en el que tú quieras, con la
asignación. Además, después, \verb.realloc. o \verb.free. rediben punteros a
\verb.void. que no necesitas convertir para pasárselo. En resumen: en C el
puntero a \verb.void. tiene conversión implícita a todos los tipos, y todos
los tipos a \verb!void!.

Esto tiene una potencia enorme, porque podemos recibir un puntero a \verb"void"
cuando no sepamos lo que vamos a recibir. El problema es que un puntero de este
tipo \textbf{no se puede desreferenciar}. Como ya te dije en su momento,
no se puede interpretar un puntero a \verb!void!. Sólo se puede interpretar
si asumimos algún tipo y asignamos este puntero sin tipo a uno con él.
Por ejemplo, veamos una función que invierta un array
\textbf{de cualquier tipo}.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Inversión de arrays de cualquier tipo},
label={lst:genericArrayInversion}]
void invert_array(void* array, int array_size, int type_size)
{
    void *var = malloc(type_size);
    for (int ii = 0; ii < array_size / 2; ++ii) {
        void* element = array + (ii * type_size);
        void* opposite = array + (array_size - 1 - ii) * type_size;
        memcpy(var, element, type_size);
        memcpy(element, opposite, type_size);
        memcpy(opposite, var, type_size);
    }
    free(var);
}
\end{lstlisting}
\end{minipage}

Como puedes ver, se parece mucho a como lo harías sabiendo su tipo, pero hay
que recibir como argumento el tamaño del tipo de dato. Lo que hacemos en
el bucle es crear dos punteros que representan los dos elementos que tenemos
que intercambiar, no podemos hacerlo con variables porque no sabemos el tipo.
Estos punteros no son necesarios, pero, siendo sinceros, sin ellos las líneas
quedan totalmente ilegibles. Después, usamos la función \verb!memcpy! para poder
mover el elemento en la posición \verb!ii! a una variable auxiliar, el elemento
en la posición opuesta (\verb!ii - 1 - array_size!) a la i-ésima y después desde
la variable al elemento opuesto.

Lo primero que se nota es algo evidente: una función sencilla enseguida se
convierte en algo más complicado de leer, porque no podemos usar operadores,
sino que tenemos que usar llamadas a función. Pero debes admitir que, ahora,
podemos invertir todos los tipos de arrays sin duplicar nada de código. También
hay una cuestión importante: mientras que el operador de asignación y saber
el tipo provoca que el compilador pueda mapear las operaciones que escribas con
operaciones del procesador para mover bytes en paquetes de cuatro u ocho, por
ejemplo, haciéndolo así, \verb!memcpy! se ve obligado a copiar byte a byte.
Esto hace que los algoritmos genéricos creados así sean más lentos que sus
contrapartes específicas.

Hay muchos ejemplos de algoritmos que bien pueden utilizar esta técnica, pero
sólo con esto no podemos terminar de solucionar el problema. Vamos a crear
una función que imprima un array de elementos genéricos. La función, con las
herramientas que tenemos, quedaría así:


\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Imprimir arrays de varios tipos},
label={lst:genericPrintf}]
void print_array_generic(void*       array,
                         size_t      array_size,
                         const char* separator,
                         type_t      type)
{
    char* specifier[] = { "%d%s","%f%s", "%lf%s", "%c%s" };

    for (size_t ii = 0; ii < array_size; ++ii) {
        switch (type) {
        case int_enumerate:
        {
            int* var = array + (ii * sizeof(int));
            printf(specifier[type], *var, separator);
        }
        break;
        case float_enumerate:
        {
            float* var = array + (ii * sizeof(float));
            printf(specifier[type], *var, separator);
        }
        break;
        case double_enumerate:
        {
            double* var = array + (ii * sizeof(double));
            printf(specifier[type], *var, separator);
        }
        break;
        case char_enumerate:
        {
            char* var = array + (ii * sizeof(char));
            printf(specifier[type], *var, separator);
        }
        break;
        }
    }
}
\end{lstlisting}
\end{minipage}

Aquí necesito saber el tipo, no sólo su tamaño, por una razón: el especificador
de impresión necesita el tipo exacto. Lo que hago es declarar un \verb!enum!
para poder indexar los tipos en un array de especificadores. Además, en el
\verb!switch! utilizo un truco: cada caso está en un bloque de código diferente
(recuerda que se pueden crear bloques de código sin que estén asociados
a una estructura), así en cada uno la variable \verb!var! puede ser del tipo
que queramos. Esto es un paso hacia delante, pero sigue siendo una función
bastante mala. Es como si hubiéramos pegado todas las funciones para cada tipo
y las hubiéramos metido en la misma. Es un avance, sí, porque, aunque mantenemos
los mismos fragmentos de código duplicado, al menos ahora están todos juntos.

Pero lo ideal es que pudiéramos recibir desde fuera la manera de imprimir, sería
deseable que el usuario de la función nos diera una función que a su vez
contuviera el comportamiento de impresión. Es decir, de algún modo debemos
poder convertir un comportamiento, un algoritmo, una función, al final del día,
en algo que se pueda pasar, mover, trasladar de un sitio a otro. En C hay un
mecanismo concreto para hacer esto que nos otorga un poder enorme:
los punteros a función.

Un puntero a función es un puntero (es decir, una dirección de memoria) que
apunta a las instrucciones que se ejecutarán en esa función. Estos punteros nos
permiten, como formulé antes, transferir, comunicar, a funciones de nuestro
programa comportamientos específicos. Cada tipo de función que se puede
declarar es un tipo de puntero distinto. Una función, como vimos en su momento,
se define por su tipo de retorno y por el tipo de los argumentos que recibe.
Esto quiere decir que, por ejemplo, estas dos funciones son iguales a estos
efectos.

\noindent
\begin{minipage}[H]{\linewidth}
\begin{lstlisting}[style=C]
int sum(int a, int b);
int multiply(int x, int y);
\end{lstlisting}
\end{minipage}

Si cada función es un tipo, quizás estés pensando, debe tener un nombre por
el que referenciarlo y una manera de declararlo y de usarse. Sí, pero no, las
funciones no se pueden inicializar como variables, si quisieras guardar el
puntero de una función, podrías asignarlo a un puntero a \verb!void!.
Sin embargo; se recibe como argumento. Para que una función reciba un puntero
a función como argumento se usa este esquema:

\noindent
\begin{minipage}[H]{\linewidth}
\begin{lstlisting}[style=C]
tipo_de_retorno (nombre) (tipo1, tipo2...)
// por ejemplo
int(foo)(int, int)
\end{lstlisting}
\end{minipage}

Con un ejemplo todo se ve mejor, veamos algo sencillo: cómo hacer una función
que reciba otra función y la ejecute. Por ejemplo, vamos a hacer una función
que reciba otra con esta signatura: \lstinline[style=C]!void (void)! y la ejecute
diez veces.

\noindent
\begin{minipage}[H]{\linewidth}
\begin{lstlisting}[style=C, label={lst:argumentFoo},
caption={Ejemplo primero de puntero a función como argumento}]
void execute_10_times(void (foo)()) {
    for (int ii = 0; ii < 10; ++ii) {
        foo();
    }
}
\end{lstlisting}
\end{minipage}

Como puedes ver, lo único distinto es la declaración de la función, que ya
hemos tratado. La llamada a la función \verb!foo! se hace como cualquier otra.
Nos queda la otra cara de esta moneda, cómo se llama a la función
\verb!execute_10_times!. Esto es bien sencillo, porque el puntero de una función
es, simplemente, su nombre sin los paréntesis, así que la llamada quedaría como:

\noindent
\begin{minipage}[H]{\linewidth}
\begin{lstlisting}[style=C, label={lst:foocall},
caption={Llamada a una función que recibe un puntero a función}]
execute_10_times(print_a);
\end{lstlisting}
\end{minipage}

Hecho esto, volvamos a la función de impresión genérica, pero esta vez haremos
que, a su vez, reciba una función que ejecute la impresión de un único elemento.
Tenemos que elegir la signatura de esta función, como es una función que
imprime, lo normal es que no devuelva nada y que reciba sólo el elemento
que queramos imprimir. Si recibiera el elemento en sí mismo, volveríamos
al problema de que hay que definir su tipo. Lo que haremos es una función
que reciba un puntero a \verb!void! y no devuelva nada. Ojo, esa función será
hecha por quien use nuestra función de impresión de arrays, no por nosotros,
salvo que seamos el mismo individuo, claro. Para el ejemplo, enseñaré ambas
funciones.


\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Definición de función de impresión genérica},
label={lst:printArrayGeneric2}]
#include <stdio.h>
#include <stdlib.h>

void print_int(void* num)
{
    printf("%d", *((int*)num));
}


void print_array_generic(void*       array,
                         size_t      array_size,
                         size_t      type_size,
                         const char* separator,
                         const char* end,
                         void(print_foo)(void*))
{
    for (size_t ii = 0; ii < array_size; ++ii) {
        void* element = array + (ii * type_size);
        print_foo(element);
        if (ii != array_size - 1) {
            printf("%s", separator);
        }
    }
    printf("%s", end);
}

int main(int argc, char** argv)
{
    int array[] = {1,2,3,4,5,6,7,8,9,0};
    print_array_generic(array,
                        ARRAY_SIZE(array),
                        sizeof(*array),
                        " ",
                        "\n",
                        print_int);

}
\end{lstlisting}
\end{minipage}

La función genérica de impresión es sencilla, es simplemente un bucle que
recorre el array y le pasa el puntero correspondiente a la función de impresión
que se le pasa como argumento. Como es lógico, necesito el puntero al array,
la longitud del mismo y, al ser un puntero a \verb!void!, necesito el tamaño
del tipo. Como puedes ver, para darle un poco de vidilla he hecho que la
función reciba dos cadenas: una como separador, que imprimiré después de
todos los elementos (menos el último, de ahí el condicional) y un terminador,
que se imprimirá después del array. La que podríamos denominar función
de impresión específica, es decir: \verb!print_int!, es una función terriblemente
simple, sólo llama a \verb!printf! haciendo un cásting a puntero a entero
y desreferenciándolo.

Es cierto que este modelo de función nos lleva al mismo problema, si
queremos imprimir tipos distintos, tendremos que definir funciones distintas.
Sí, pero piensa una cosa: hemos hecho que el código que se duplique sea ínfimo,
porque son funciones triviales de una línea, además, una vez salimos de los
tipos básicos que podríamos, contando sus variantes, agrupar en 10 funciones,
aproximadamente, se acaba la duplicidad de código. Esto es así porque cualquier
otra estructura requeriría una función o bien de impresión o bien de conversión
a cadena de texto hecha a medida para ella.

Como habrás podido notar, la sintaxis para declarar que una función recibe
otra como argumento es complicada y, además, rompe el patrón de una lista
de argumentos que, hasta ahora, era siempre una sucesión de tipos y nombres
separados por comas. Con esta sintaxis para punteros a función se
incluyen varios paréntesis. C permite definir un tipo para los punteros
a función. Es decir, aún descubrimos otra faceta de la poderosa palabra
\verb!typedef!. Veamos cómo se haría y pondré comentarios de algunos ejemplos
de funciones que pertenecerían a ese tipo.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Definición de tipos puntero a función},
label={lst:functionPointerTypedef}]
typedef void(print_fun_t)(void*); //ej: void print_int(void* a);
typedef void(*malloc_t)(void); //ej: void* malloc(void);
typedef int(sum_t)(int, int); // ej: int sum(int a, int b);
\end{lstlisting}
\end{minipage}
Presta atención porque, si la función devuelve un puntero, el asterisco va
dentro de los paréntesis, junto al nombre del tipo, no fuera. Si hiciéramos en
el programa la primera definición, podríamos cambiar nuestra función genérica
por:

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Ejemplo final de función que recibe un puntero},
label={lst:finalPointerFunction}]
void print_array_generic(void*       array,
                         size_t      array_size,
                         size_t      type_size,
                         const char* separator,
                         const char* end,
                         print_fun_t print_foo);
\end{lstlisting}
\end{minipage}
Queda mucho más claro, porque el último argumento se identifica,
como cualquier otro, por un tipo y un nombre.

La utilidad de esto se puede ver muy bien en funciones que ya hemos tratado,
las funciones de ordenación. Ahora mismo esas funciones siempre ordenan vectores
de enteros y, además, siempre de menor a mayor. Esto presenta varias posibles mejoras,
la primera es evidente, tenemos que poner punteros a \verb!void! y utilizarlos,
pero el otro es más interesante. Esta segunda mejora es: sólo podemos utilizar
una relación de orden. Es decir, sólo podemos ordenar números y de menor a
mayor, no podemos comparar estructuras, no podemos comparar cadenas de texto
alfabéticamente, pero podríamos si utilizáramos estas nuevas herramientas.
Para generalizar una función de ordenación necesitaríamos el tamaño del tipo que
vamos a ordenar y una función de comparación.

Las funciones de comparación son un tipo muy concreto, se llaman
predicados, y son funciones que devuelven un valor lógico ante un conjunto
de argumentos. Así que el prototipo de la función que tenemos que
recibir sería una que devolviera un valor lógico entero y recibiera dos punteros
a \verb!void!. De nuevo, recibe dos punteros a \verb!void! para ser compatible
con nuestra función genérica, aunque el predicado sí debe saber qué
tipo está comparando, lógicamente.

Vamos a usar el algoritmo más sencillo de ordenación que tenemos, el de la
burbuja, para ilustrar esto, esto es así porque una implementación genérica
de, por ejemplo, \textit{Quick Sort} sería más compleja y larga, y me interesa
que veas el concepto del puntero a función y de punteros a \verb!void!
trabajando, no que te pierdas en una función de 40 líneas. Además, para verlo
mejor, vamos a utilizar un caso concreto: una función que ordene cadenas
de texto alfabéticamente, usando \verb!strcmp!.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Definición de \texttt{bubble\_sort} genérico},
label={lst:bubbleSortGeneric}]
typedef int(comparator_t)(const void*, const void*);

void generic_swap(void* one, void* other, size_t type_size)
{
    char aux[type_size];
    memcpy(aux, one, type_size);
    memcpy(one, other, type_size);
    memcpy(other, aux, type_size);

}

void generic_bubble_sort(void*        array,
                         size_t       array_size,
                         size_t       type_size,
                         comparator_t comparator)
{
    for (int ii = 0; ii < array_size - 1; ++ii) {
        for (int jj = 0; jj < array_size - 1; ++jj) {
            void* element = array + (jj * type_size);
            void* next_element = array + ((jj + 1) * type_size);
            if (!comparator(element, next_element)) {
                generic_swap(element, next_element, type_size);
            }
        }
    }
}
\end{lstlisting}
\end{minipage}

Como puedes ver, definimos el tipo de nuestra función de comparación, la cual
devolverá un entero y recibirá dos punteros constantes a \verb!void!, y esto
es importante, la definición de un tipo puntero a función no tiene conversiones
implícitas de ningún tipo. Esto es: como hemos definido la función tal que
recibirá dos punteros constantes a \verb!void!, una función que reciba punteros
no constantes no será de este tipo y no se podrá usar como tal, ten esto en
cuenta.

Después tenemos la función de intercambio en su versión genérica, es decir,
en vez de usar el operador de asignación, utilizaremos la función de copia
de memoria con el tamaño del tipo. Y después, la función genérica de ordenación.
Como puedes ver, simplemente hemos sustituido el condicional por la negación
de la llamada a la función. Recuerda cómo funcionaba el algoritmo de la burbuja:
cuando el elemento i-ésimo es \textbf{mayor} que el siguiente, se intercambian.
Es decir: cuando \textbf{no} se cumple el predicado de que elemento $i$ sea
menor que el siguiente.

Dentro del bucle debemos calcular primero los punteros de los elementos. Esto
es así por legibilidad, pero podríamos escribir las expresiones en la propia
función de intercambio. Ten en cuenta que debemos multiplicar, de nuevo,
\verb!ii! por el tamaño del dato. Recuerda: son punteros a \verb!void!, no
entra en juego la aritmética de punteros, son direcciones de memoria
absolutas. Una vez calculados simplemente llamamos a la función de intercambio.

Debemos tener en cuenta también la función de comparación. En el caso de un
\textit{string} es interesante porque uno puede confundirse debido a que los
punteros se suman sobre punteros. Veamos cómo es la función de comparación:

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Función auxiliar de comparación de \textit{strings}},
label={lst:strcompare}]
int compare_strings(const void* one, const void* two) {
    char* const* str1 = one, * const* str2 = two;
    return strcmp(*str1, *str2) < 0;
}
\end{lstlisting}
\end{minipage}

Es muy interesante porque puedes ver la primera línea, que introduce algo
que no habíamos visto. Esta función recibe dos punteros constantes de
\verb!void!. Estos punteros son, en realidad, punteros a punteros a \verb!char!,
es decir: \verb!char**!. Pero como los hemos recibido como constantes, no
podemos hacerles cásting a ese tipo, el compilador nos diría, hablando claro:
<<estás haciendo cásting de un puntero constante a uno que no lo es, podrías
modificar el contenido>>. Pero si pusiéramos el modificador \verb!const!
primero de todo como hemos hecho siempre el compilador seguiría lanzándonos
esa advertencia. La clave es que lo que es constante es lo que, por ejemplo,
\verb!one! apunte, es decir, la constancia está pegada al contenido de
\verb!one! y \verb!two!. Si escribiéramos \verb!const char**! seguiríamos
pudiendo modificar el contenido al que apunta tal dirección. Vamos a verlo
con un dibujo:

\begin{figure}[H]
    \includegraphics[width=\linewidth]{const_char_pointer_pointer}
    \caption{Puntero a carácter constante}
    \label{img:constcharpointerpointer}
\end{figure}

\begin{figure}[H]
    \includegraphics[width=\linewidth]{char_pointer_const_pointer}
    \caption{Puntero a puntero constante a \texttt{char}}
    \label{img:charconstpointerpointer}
\end{figure}

Vamos a explicarlo despacio, si miras el primer dibujo, es <<a lo que estamos
acostumbrados>>, cada asterisco es un nuevo nivel de puntero, así que puedes
leer la declaración desde la izquierda y construirá los tipos. Empecemos:
nos encontramos \verb!const!, lo que venga ahora es constante, después
\verb!char!, ahora llega un asterisco, el asterisco inicia un nuevo nivel, así
que este puntero \textbf{no} será constante, porque no tiene un \verb!const!
a la derecha y, finalmente, otro nivel de puntero, que tampoco será constante.
Ahora que ya tienes los tres grupos, los inviertes, es decir: puntero no
constante, a puntero no contante, a \verb!char! constante.

En el caso siguiente tenemos un \verb!char!, después un asterisco, es decir,
un nivel de puntero, lleva const a la derecha, así que es constante, y después
otro puntero, sin constancia. Es decir, invirtiéndolo: puntero no constante a
puntero constante a char no constante. En ambos casos, en el diagrama, he
señalado en rojo los valores que no puedes cambiar, como puedes ver, en el
superior no podemos cambiar los \textit{strings}, pero sí los punteros
intermedios. En el caso de abajo, por el contrario, podemos modificar los
caracteres, pero no los punteros del array intermedio.

Una de las implicaciones de las funciones genéricas es la siguiente: se
introduce una sobrecarga inevitable, por dos motivos. El primero es que las
funciones que utilizan punteros a \verb!void! tienen que hacer cálculos
explícitos que se harían implícitamente. No voy a entrar en detalles de
arquitectura de computadores, pero los ordenadores tienen en sus procesadores
instrucciones que manejan datos como enteros de cuatro bytes y números decimales
(y algunos más). Al tener que copiar byte a byte, impedimos que se utilicen y,
además, tenemos que darle más vueltas al bucle de copia, lo cual es más costoso.
El segundo es que cuando se llama a una función de manera normal el
compilador cuenta con ello para saber cómo generar el binario. Cuando ésta
es un argumento, esta tarea se le hace más complicada, porque no sabe qué
función es hasta el momento de la ejecución. Para hacer esto patente, vamos
a hacer una comparación con el tiempo que tarden ambas versiones en ordenar
65.536 y 131.072 elementos. Vamos a comparar ambas cargas de trabajo porque
quiero que veas una cosa.

\begin{table}[H]
\begin{tabularx}{\linewidth}{|c|R|R|}
\hline
\textbf{Función}&\textbf{N=35.536}&\textbf{N=131.072}\\\hline
Específica&16,21&64,61\\\hline
Genérica&41,20&164,44\\\hline
\textbf{Ratio}&0,39&0,39\\\hline
\end{tabularx}
\caption{Tiempos de ejecución de los distintos algoritmos}
\label{tab:sortingTimes}
\end{table}

Como puedes ver, la versión genérica tarda más, pero he calculado un dato
importante a ese respecto: el ratio entre el tiempo del algoritmo específico y
el algoritmo genérico. Como puedes ver, aunque el algoritmo genérico es peor
que el específico, la buena noticia es que esa diferencia es constante, es
decir: no empeora con el tamaño del vector. Esto hace que, si podemos asumir
el aumento de tiempo, la solución sea escalable, que es una manera que se tiene
en informática de decir que puedes hacer crecer algo sin quedarte sin recursos
rápidamente.

Un ejercicio muy interesante sería que programaras la versión genérica de
\textit{Quick Sort} y que, además, hicieras estas mismas mediciones. Para
medir el tiempo puedes utilizar este código:

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Cómo medir el tiempo},
label={lst:measure_times}]
#include <stdio.h>
#include <time.h>

double timespec_to_double(const struct timespec* tm)
{
    return tm->tv_sec + tm->tv_nsec / 1000000000.0;
}

int main(int argc, char** argv)
{
    double start, stop;
    struct timespec start_ts, stop_ts;

    clock_gettime(CLOCK_REALTIME, &start_ts);
    start = timespec_to_double(&start_ts);
    // Aquí el código que quieres medir.
    clock_gettime(CLOCK_REALTIME, &stop_ts);
    stop = timespec_to_double(&stop_ts);
    printf("Hemos tardado: %lf\n", stop - start);
}
\end{lstlisting}
\end{minipage}

La función \verb!clock_gettime! es una función para medir el tiempo de un modo
peculiar, en sistemas Linux se mide el tiempo desde el primero de enero de
1970. Así, la estructura \verb!timespec! indica el tiempo pasado desde entonces
como un conjunto de segundos más los correspondientes nanosegundos en sus dos
miembros. Como eso es poco práctico he creado una pequeña función para
convertirlo a número decimal y así poder restarlo cómodamente. Después,
simplemente mido el tiempo antes y después del código que quiero saber cuánto
tarda y los resto, como puedes ver.

\section{Ejemplo completo de programa}
Esta sección está al final porque, si hasta ahora hemos visto cada parte del
lenguaje en detalle y por sí misma, en esta vamos a intentar montar todas las
piezas en una gran fotografía. Para esto vamos a utilizar y refinar un ejemplo
que ha sido recurrente en el manual: la gestión de una estructura que almacena
los datos de una persona, pero vamos a conseguir separar bien al usuario de la
funcionalidad interna del código que se encague de eso.

Lo que haremos es crear un archivo de código fuente llamado \verb!person.c! y
su correspondiente archivo de cabeceras, \verb!person.h!, en este archivo
incluiremos funcionalidad para crear una estructura persona, cambiar
sus atributos, leerlos y serializarla. Además, vamos a ver un interesante
artefacto del lenguaje para poder impedir que el usuario se entrometa en
nuestra estructura y pueda alterar los datos de manera incorrecta. Por ejemplo:
asignando los punteros a una zona de memoria que no controlemos desde estas
funciones proporcionadas para manipular la estructura de datos.

Lo primero que voy a hacer es crear el archivo de cabeceras porque ya hemos
definido de una manera muy concreta la funcionalidad de este código fuente.
Aquí hay una cosa interesante que podremos comentar, veamos el archivo:

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Ejemplo final de programa -- \texttt{person.h}},
label={lst:finalExPerson_h}]
#ifndef PERSON_H
#define PERSON_H

typedef struct person_s person_t;

person_t *create_person(const char *name, const char *last_name,
                        unsigned int age);

void destroy_person(person_t *p);

void person_set_name(person_t *p, const char *name);

void person_set_last_name(person_t *p, const char *last_name);

void person_set_age(person_t *p, unsigned int age);

const char *person_get_name(const person_t *person);

const char *person_get_last_name(const person_t *person);

unsigned int person_get_age(const person_t *person);

char *person_to_string(const person_t *p);

#endif
\end{lstlisting}
\end{minipage}

Y aquí puedes ver una de las cosas interesantes de este ejemplo final: estamos
declarando el tipo \verb!person_t!, pero no el \textit{struct} al que da nombre,
esto quiere decir que cualquier archivo de código fuente que incluya este
\textbf{no} podrá saber la definición de tal \textit{struct}. La implicación de
esto es que no podrá declarar variables de este tipo, tan solo punteros, puede
declarar un puntero, porque todos los punteros tienen el mismo tamaño. Si
intentáramos declarar una variable de este tipo, el compilador lanzaría un error
como el siguiente:

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=terminalStyle]
main.c: In function 'main':
main.c:5:14: error: storage size of 'francis' isn't known
    5 |     person_t francis;
      |              ^~~~~~~
\end{lstlisting}
\end{minipage}

Este es el mecanismo que nos permite impedir que el usuario altere el contenido
de la estructura fuera de nuestro control (como comentamos en el programa
\ref{lst:structConstMain}) porque, del mismo modo que no conoce el tamaño del tipo,
tampoco conoce los miembros de esta estructura, así que no puede accederse a
ellos. Nota, además, como no hemos incluido ninguna cabecera en \verb!person.h!.
Si necesitáramos cabeceras, por ejemplo, la cabecera \verb!stdint.h! contiene
definiciones de tipo útiles como aquéllos de tamaño fijo: \verb!int8_t!,
\verb!int16_t!, etc.; si quisiéramos definir alguna función con un argumento
de este tipo o de tipo de retorno, sí sería necesario que incluyéramos esta
cabecera. Si las necesitamos en las implementaciones (en las declaraciones de
esctructuras, en las definiciones de funciones...), será en el archivo de
código fuente (en el \verb!.c!) donde las incluiremos.

El siguiente archivo es, precisamente, este archivo de código fuente:
\verb|person.c|. Es bastante largo, así que vamos a incluirlo en tres secciones:
la sección de declaración de tipos (que sólo contendrá uno), las funciones de
manipulación del contenido de la estructura y, finalmente, la de recuperación
de la información.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C, label={lst:finalExDefinition},
caption={Ejemplo final de programa -- \texttt{person.c} definiciones}]
#include <string.h> //strdup, memset
#include <stdlib.h> //malloc
#include <stdio.h>  //snprintf
#include "person.h"

struct person_s
{
    char *name;
    char *last_name;
    unsigned int age;
};

person_t *create_person(const char *name,
                        const char *last_name,
                        unsigned int age)
{
    person_t *res = malloc(sizeof(*res));
    memset(res, 0, sizeof(*res));

    res->age = age;
    res->name = strdup(name);
    res->last_name = strdup(last_name);

    return res;
}

void destroy_person(person_t *p)
{
    free(p->name);
    free(p->last_name);
    free(p);
}
\end{lstlisting}
\end{minipage}

Aquí podemos ver la defininión del tipo del que en la cabecera hicimos un
\verb!typedef!, este estilo de declaración de un tipo se llama declaración
anticipada o, en inglés, \textit{forwarding declaration}. Aquí, aparte de la
definición del tipo propiamente dicho, tenemos las funciones que lo crean
y que lo destruyen. Como esta estructura contiene elementos reservados con
memoria dinámica, debemos proveer al usuario una manera de liberar los recursos
de la estructura. Como puedes ver, en las funciones de creación reservamos
espacio \textbf{para la propia estructura} y para sus campos.

Debemos reservar
nosotros dinámicamente la estructura aparte de sus campos porque, recordemos,
fuera de este archivo de código fuente no podremos declarar más que punteros,
y ese puntero no tendrá espacio para nada si no lo declaramos. Después,
reservamos memoria para el contenido al que apuntarán los \textbf{miembros}
de la estructura.
En la función de destrucción, simétricamente, liberamos primero los contenidos
y después la propia estructura. Nota, además, cómo hemos declarado todos los
argumentos que hemos podido como constantes, para que el usuario no tenga dudas
de si vamos a modificar datos que nos proporcione.

Las siguientes funciones son las que nos permiten sobreescribir los datos:

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C, label={lst:finalExSetter},
caption={Ejemplo final de programa -- \texttt{person.c} manipulación}]
void person_set_name(person_t *p, const char *name)
{
    free(p->name);
    p->name = strdup(name);
}

void person_set_last_name(person_t *p, const char *last_name)
{
    free(p->last_name);
    p->last_name = strdup(last_name);
}

void person_set_age(person_t *p, unsigned int age)
{
    p->age = age;
}
\end{lstlisting}
\end{minipage}

Como puedes ver, las funciones son simples, liberamos la memoria de los campos
y después le asignamos la duplicación del argumento que se nos pasa. De nuevo,
observa cómo hemos definido como constantes los argumentos del mismo modo que
hicimos en la función de creación. Las funciones no devuelven nada (\verb!void!)
porque no tendríai sentido. Aunque siempre podrían devolver un entero que
actuara como código de error, por ejemplo si la reserva de memoria fallara,
se podría indicar devolviendo un número menor que cero.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C, label={lst:finalExGetter},
caption={Ejemplo final de programa -- \texttt{person.c} recuperación}]
const char *person_get_name(const person_t *p)
{
    return p->name;
}

const char *person_get_last_name(const person_t *person)
{
    return person->last_name;
}

unsigned int person_get_age(const person_t *person)
{
    return person->age;
}

char *person_to_string(const person_t *p)
{
#define MAX_STRING_SIZE ((unsigned int)1024)

    char res[MAX_STRING_SIZE + 1];
    snprintf(res, MAX_STRING_SIZE, "{\"name\":\"%s\","
                                   "\"last_name\":\"%s\","
                                   "\"age\":%u}",
             p->name, p->last_name, p->age);
    return strdup(res);
#undef MAX_STRING_SIZE
}
\end{lstlisting}
\end{minipage}

Aquí debes notar que devolvemos punteros contantes a \verb!char!, precisamente
para impedir que el usuario libere, manipule o cambie el contenido de los campos
del \textit{struct}. Sin embargo; en la función de serialización (que he
reducido a su versión más simple) devuelvo un puntero no constante porque la
responsabilidad de liberar es del usuario de la funcionalidad, no de esta
biblioteca. Además, en esta última función puedes ver que podemos
\textbf{eliminar} una macro con la directiva \verb!#undef!. Esto es útil cuando
necesitas inicializar un array, como aquí, pero no quieres contaminar de
símbolos el código fuente. Así, si otra función usara strings de otro tamaño,
podríamos usar el mismo nombre, como si la macro fuera una variable distinta.
De nuevo: ten cuidado, las macros trabajan a nivel de preprocesado, por lo que
no estás definiendo ninguna variable en la función, sólo una región de código
donde un símbolo se sustituirá por otro.

Finalmente, en el archivo principal podemos utilizar la funcionalidad:

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C, label={lst:finalExMain},
caption={Ejemplo final de programa -- \texttt{main.c}}]
#include "person.h"
#include <stdlib.h>
#include <stdio.h>

int main(void)
{
    person_t* person = create_person("John", "Smith", 18);

    char* serialization = person_to_string(person);

    printf("%s\n", serialization);
    free(serialization);

    person_set_name(person, "Michael");
    person_set_last_name(person, "Johnson");
    person_set_age(person, 33);

    serialization = person_to_string(person);
    printf("%s\n", serialization);
    free(serialization);
}
\end{lstlisting}
\end{minipage}

Aquí se puede ver cómo se utilizan estructuras con este patrón de diseño.
Primero la reservas, después la usas, la puedes manipular y, finalmente, la
liberas, todo ello con las funciones proporcionadas junto con el tipo de dato.
Con este patrón, el usuario de la funcionalidad que hemos programado tiene
menos capacidad para <<hacer algo mal>>.

Ahora, vamos a ver rápidamente cómo se podría compilar, para recordarlo. Primero
lo haremos utilizando el código objeto y, después, crearemos una biblioteca
dinámica y la enlazaremos. Para compilar utilizando el código
objeto seguiremos estos pasos:

\noindent
\begin{minipage}[H]{\linewidth}
\begin{enumerate}
\item Crear el código objeto de \verb!person.c!

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=terminalStyle]
\$ gcc -c person.c
\end{lstlisting}
\end{minipage}
\item Crear el código objeto de \verb!main.c!

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=terminalStyle]
\$ gcc -c main.c
\end{lstlisting}
\end{minipage}
\item Crear el ejecutable con ambos códigos objeto

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=terminalStyle]
\$ gcc -o main.exe main.o person.o -g -Wall -Wextra
\end{lstlisting}
\end{minipage}
\end{enumerate}
\end{minipage}

Para la biblioteca, seguiremos estos pasos:

\noindent
\begin{minipage}[H]{\linewidth}
\begin{enumerate}
\item Crear el código objeto de \verb!person.c!

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=terminalStyle]
\$ gcc -c person.c
\end{lstlisting}
\end{minipage}
\item Crear una biblioteca con este código objeto:

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=terminalStyle]
\$ gcc -shared -o libperson.so person.o
\end{lstlisting}
\end{minipage}
\item Crear el código objeto de \verb!main.c!

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=terminalStyle]
\$ gcc -c main.c
\end{lstlisting}
\end{minipage}
\item Crear el ejecutable usando la biblioteca:

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=terminalStyle]
\$ gcc -L. -Wl,-rpath=. -o main.exe main.o -lperson
\end{lstlisting}
\end{minipage}
\end{enumerate}
\end{minipage}

En este ejemplo final se han visto ejemplos de la mayoría de conceptos que
se han explicado en el manual: variables, punteros, memoria, reserva dinámica,
estructuras, macros, enlazado, compilación y constancia y signo. Es mucha
información en pocas páginas, pero permite tener una foto global de todo
si ya se ha leído antes con detenimiento.

%\subsection{Ejercicio de la sección}
%En esta sección voy a proponer un último ejercicio, pero detallado, que permita
%practicar todos o casi todos los conceptos vistos en el manual. El ejercicio es
%crear un proyecto que incluye las siguientes funcionalidades:
%\begin{itemize}
%\item Manejo de una estructura <<coordenada>> que permita almacenar
%una coordenada bidimensional (un punto) con un \textbf{nombre} que sea una
%cadena de texto. Esta cadena de texto debe manejarse con funciones que impidan
%que el usuario deje la estructura en un estado inconsistente.
%    \begin{itemize}
%    \item Debe poderse calcular la distancia entre dos puntos. Se recibirán
%    punteros y si uno de ellos o los dos es \verb!NULL! se tomará por el punto
%    de origen.
%    \item Debe poderse ordenar un vector de puntos por su distancia al origen.
%    Idealmente, debería usarse el algoritmo \textit{Quick Sort}.
%    \item Debe poderse cambiar el nombre de un punto si destruirlo y crearlo
%    de nuevo con una función para tal fin.
%    \end{itemize}
%\item Manejo de una estructura <<polígono>> que tenga un conjunto de puntos
%de los descritos anteriormente. Hay que tener en cuenta que cada punto estará
%conectado con el siguiente y el anterior; menos el último, que estará conectado
%al penúltimo y al primero, y el primero, que estará conectado al segundo y
%al último.
%    \begin{itemize}
%    \item Deberá poderse modificar un polígono añadiendo o eliminando puntos
%    al final.
%    \item Deberá poderse insertar un punto en una posición dada de un polígono.
%    \item Deberá poderse calcular el centro del polígono como la media de las
%    coordenadas de un punto.
%    \end{itemize}
%\item Se deben crear funciones que permitan hacer estas tareas con estructuras
%que simbolicen y aumenten las funcionalidades de los vectores,
%idealmente, de cualquier tipo:
%    \begin{itemize}
%    \item Insertar en cualquier posición
%    \item Insertar al final
%    \item Conocer la longitud del vector
%    \item Vaciar el vector
%    \item Eliminar un elemento de la posición del vector
%    \item Ordenar el vector
%    \item Crear un vector con una longitud dada, relleno de un valor concreto
%    \end{itemize}
%Las dos primeras funcionalidades deben estar en una biblioteca llamada
%\verb!libGeo.so! y la siguiente en \verb!libVector.so!. Se debe crear un
%programa que utilice todas las funcionalidades y las pruebe.
%\end{itemize}

\section{Anexo A: soluciones a ejercicios}
\begin{exercises}
\item Escribe un programa y declara en él una estructura que defina un círculo
en dos dimensiones (su centro y su radio). Y haz que el programa declare una
variable de ese tipo y calcule su área.


\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Solución al ejercicio 1},
label={lst:solution1}]
#include <stdio.h>

struct circle_s {
    double x;
    double y;
    double r;
};

int main(void)
{
    struct circle_s circle = { 1 , 1 , 3.4 };
    double area = 3.141592 * circle.r * circle.r;
    printf("El área del círculo en el punto [%f, %f] con un radio de % f es: %f\n", circle.x, circle.y, circle.r, area);
}
\end{lstlisting}
\end{minipage}

\item Haz un programa que, basándose en el struct punto presentado en el
ejemplo, declare e inicialice un array de ellos y vaya diciendo las direcciones
que hay que seguir para ir de uno a otro.


\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Solución al ejercicio 2},
label={lst:solution2}]
#include <stdio.h>
struct point_s {
    double x;
    double y;
};

int main(void)
{
    struct point_s points[10] = { {-1.056171, 3.401877},
                                  {2.984400, 2.830992},
                                  {-3.024486, 4.116474},
                                  {2.682296, -1.647772},
                                  {0.539700, -2.222253},
                                  {1.288709, -0.226029},
                                  {0.134009, -1.352155},
                                  {4.161951, 4.522297},
                                  {2.172969, 1.357117},
                                  {1.069689, -3.583974} };

    for(int ii = 1; ii < 10; ++ii){
        if (points[ii - 1].x < points[ii].x) {
            printf("Derecha");
        }else if(points[ii - 1].x == points[ii].x){
            printf("Quieto");
        }else if(points[ii - 1].x > points[ii].x){
            printf("Izquierda");
        }
        printf(", ");
        if (points[ii - 1].y < points[ii].y) {
            printf("Arriba");
        }else if(points[ii - 1].y == points[ii].y){
            printf("Quieto");
        }else if(points[ii - 1].y > points[ii].y){
            printf("Abajo");
        }
        printf("\n");
    }
}
\end{lstlisting}
\end{minipage}

\item Haz un programa que declare un array bidimensional y calcule la suma de
sus filas y sus columnas.


\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Solución al ejercicio 3},
label={lst:solution3}]
#include <stdio.h>

int main(void)
{
    int array[3][3] = { {1,3,6},{7,3,6},{1,2,4} };

    for (int ii = 0; ii < 3; ++ii) {
        for (int jj = 0; jj < 3; ++jj) {
            printf("%d ", array[ii][jj]);
        }
        int suma = 0;
        for(int jj = 0; jj < 3; ++jj){
            suma += array[ii][jj];
        }
        printf("= %d\n", suma);
    }
    for(int ii = 0; ii < 3*2; ++ii){
        printf("-");
    }
    printf("\n");
    for(int ii = 0; ii < 3; ++ii){
        int suma = 0;
        for(int jj = 0; jj < 3; ++jj){
            suma+=array[jj][ii];
        }
        printf("%d ", suma);
    }
    printf("\n");
}

\end{lstlisting}
\end{minipage}


\item Haz un programa que haga lo siguiente para los números del 1 al 100 ambos
incluidos: si el número es divisible entre 2, debe imprimirse por pantalla
<<fizz>>, si es divisible entre 5, <<buzz>>, y si es divisible entre los dos,
<<fizzbuzz>>, no imprimir nada en otro caso.


\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Solución al ejercicio 4},
label={lst:solution4}]
#include <stdio.h>

int main(void)
{
    for (int ii = 1; ii <= 100; ++ii){
        int end_of_line = 0;
        if (ii % 2 == 0){
            printf("fizz");
            end_of_line = 1;
        }

        if(ii % 5 == 0){
            printf("buzz");
            end_of_line = 1;
        }
        if(end_of_line){
            printf("\n");
        }
    }
}
\end{lstlisting}
\end{minipage}

\item Escribe una función que calcule si un número es primo o no.


\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Solución al ejercicio 5},
label={lst:solution5}]
#include <stdio.h>

int is_prime(int number) {
    int prime = 1;
    for (int ii = 2; ii < number / 2 && prime; ++ii) {
        if (0 == number % ii) {
            prime = 0;
        }
    }
    return prime;
}

int main(void)
{
    for(int ii = 2; ii < 100; ii++){
        printf("El número %d ", ii);
        if(is_prime(ii)){
            printf("es primo.");
        }else{
            printf("no es primo");
        }
        printf("\n");
    }
}
\end{lstlisting}
\end{minipage}

\item Escribe una función que calcule la distancia entre dos estructuras punto
de las usadas en la sección anterior.


\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Solución al ejercicio 6},
label={lst:solution6}]
#include <stdio.h>
#include <math.h>
struct point_s {
    double x;
    double y;
};

double distance(struct point_s a, struct point_s b) {
    double res = 0.0;
    double diff_x = a.x - b.x;
    double diff_y = a.y - b.y;
    res = sqrt(diff_x * diff_x + diff_y * diff_y);
    return res;
}

int main(void)
{
    struct point_s a = {1.2, 4.3};
    struct point_s b = {3.4, 5.5};
    printf("La distancia entre [%f, %f] y [%f, %f] es: %f\n", a.x, a.y, b.x, b.y, distance(a,b));
}
\end{lstlisting}
\end{minipage}

\item Escribe una función que reciba un array de enteros y un caracter separador
que imprima los elementos del array separados por ese caracter.


\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Solución al ejercicio 7},
label={lst:solution7}]
#include <stdio.h>
void print_separated(int array[], int array_size, char separator){
    for(int ii = 0; ii < array_size; ++ii){
        printf("%d%c", array[ii], separator);
    }
}

int main(void)
{
    int my_array[] = {1,2,3,4,5,6,7,8,9,0};
    print_separated(my_array, 10, '|');
    printf("\n");
}
\end{lstlisting}
\end{minipage}

\item Escribe una función que encapsule el programa
\ref{lst:linealSystemFinal}: \nameref{lst:linealSystemFinal}.
La función debe recibir los coeficientes de las ecuaciones
($a$, $b$, $c$, $d$, $e$ y $f$). Puede recibirlos por separado o en un array.
Para devolver el resultado puedes crear una estructura que simplemente tenga
dos \verb!double!.



\begin{lstlisting}[style=C,
caption={Solución al ejercicio 8},
label={lst:solution8}]
#include <stdio.h>

struct solution_s {
    double x;
    double y;
    int solved;
};

struct solution_s linear_system(int a, int b, int c, int d, int e, int f) {

    double divisor;
    struct solution_s res;
    res.solved = 1;
    if (a != 0 && d != 0) {
        divisor = (a * e - d * b);
        if (divisor == 0)
        {
            printf("El sistema es irresoluble .\n");
            res.solved = 0;
        }
        else
        {
            res.y = (a * f - d * c) / divisor;
            res.x = (f - e * res.y) / (d);
        }
    }
    else if (b != 0 && e != 0) {
        divisor = (b * d - e * a);
        if (divisor == 0) {
            printf("El sistema es irresoluble .\n");
            res.solved = 0;
        }
        else {
            res.x = (b * f - e * c) / divisor;
            res.y = (c - a * res.x) / b;
        }
    }
    else if ((a == 0 && b == 0) || (d == 0 && e == 0)) {
        printf(" Esto no es un sistema \n");
        res.solved = 0;
    }
    else {
        if (a != 0) {
            res.x = (double)c / a;
            res.y = (double)f / e;
        }
        else {
            res.x = (double)f / d;
            res.y = (double)c / b;
        }
    }
    return res;
}


int main(void)
{
    struct solution_s sol = linear_system(1, 1, 1, 2, 2, 2);
    printf(" %dx+ %dy= %d\n", 1, 2, 3);
    printf(" %dx+ %dy= %d\n", 4, 5, 6);
    if (sol.solved) {
        printf("x = %f; y = %f\n", sol.x, sol.y);
    }
    else {
        printf("El sistema no tiene solucion.\n");
    }
}
\end{lstlisting}


\item Escribe una función que normalice los elementos de un array de
\verb!double!.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Solución al ejercicio 9},
label={lst:solution9}]
#include <stdio.h>

void normalize(double array[], int array_size) {
    double biggest = array[0];
    for (int ii = 1; ii < array_size; ++ii) {
        if (array[ii] > biggest) {
            biggest = array[ii];
        }
    }
    for (int ii = 0; ii < array_size; ++ii) {
        array[ii] /= biggest;
    }
}

int main(void)
{
    double array[] = { 1,2,3,4,5,6,7,8,9,10 };
    normalize(array, 10);
    for(int ii = 0; ii < 10; ++ii){
        printf("%f\n", array[ii]);
    }
    printf("\n");
}
\end{lstlisting}
\end{minipage}

\item Completa esta tabla de números en diferentes bases numéricas:
\begin{table}[H]
\begin{tabularx}{\linewidth}{|R|R|R|}
\hline
\multicolumn{1}{|Y|}{\textbf{Decimal}}& \multicolumn{1}{Y|}{\textbf{Binario}} & \multicolumn{1}{Y|}{\textbf{Hexadecimal}} \\\hline
73& 0100~1001 & 0x049 \\\hline
 38&0010~0110&0x026 \\\hline
303&0001~0010~1111&0x12F       \\\hline
128&1000~0000&0x080 \\\hline
\end{tabularx}
\end{table}
\item Vuelve al ejercicio noveno y reproduce los contenidos de la pila en cada
bloque de código del programa. Utiliza de referencia la solución que propongo
yo.

\begin{stack}
    \item Función main
    \begin{stack}
        \item Array (10 elementos)
        \item Entramos en la función normalize
        \begin{stack}
            \item Array (puntero a)
            \item \verb!array_size!
            \item \verb!biggest!
            \item Primer bucle for
            \begin{stack}
                \item \verb!ii!
            \end{stack}
            \item Segundo bucle for
            \begin{stack}
                \item \verb!ii!
            \end{stack}
        \end{stack}
        \item Bucle for
        \begin{stack}
            \item \verb!ii!
        \end{stack}
    \end{stack}
\end{stack}

\item Haz un programa que cree un puntero de tres niveles de tipo \verb!int!,
lo reserve correctamente, lo rellene con el valores correlativos
\textbf{empezando en uno} y después lo imprima de una manera comprensible.
Finalmente, libéralo también de tal modo que no quede memoria sin liberar al
final del programa.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,label=lst:solution12, caption={Solución al ejercicio 12}]
#include <stdio.h>
#include <stdlib.h>

#define DEPTH (10)
#define WIDTH (5)
#define HEIGHT (12)

int main(int argc, char const *argv[]) {
    int ***cube = malloc(sizeof(*cube) * DEPTH);

    for (int ii = 0; ii < DEPTH; ++ii) {
        cube[ii] = malloc(sizeof(**cube) * HEIGHT);
        for (int jj = 0; jj < HEIGHT; ++jj) {
            cube[ii][jj] = malloc(sizeof(***cube) * WIDTH);
            for (int kk = 0; kk < WIDTH; ++kk) {
                cube[ii][jj][kk] =
                    kk + jj * WIDTH + ii * HEIGHT * WIDTH + 1;
            }
        }
    }

    for (int ii = 0; ii < DEPTH; ++ii) {
        for (int jj = 0; jj < HEIGHT; ++jj) {
            for (int kk = 0; kk < WIDTH; ++kk) {
                printf("%3d ", cube[ii][jj][kk]);
            }
            printf("\n");
        }
        printf("\n");
    }

    for (int ii = 0; ii < DEPTH; ++ii) {
        for (int jj = 0; jj < HEIGHT; ++jj) {
            free(cube[ii][jj]);
        }
        free(cube[ii]);
    }
    free(cube);

    return 0;
}
\end{lstlisting}
\end{minipage}


\item Basándote en el programa anterior, crea dos funciones, una para crear
una matriz tridimensional con memoria dinámica dadas sus tres dimensiones y
otra para liberarla.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[ style=C,
                    label=lst:solution12,
                    caption={Solución al ejercicio 13 -- reserva}]
int ***malloc_cube(size_t depth, size_t height, size_t width) {
    int ***cube = malloc(sizeof(*cube) * depth);

    for (int ii = 0; ii < depth; ++ii) {
        cube[ii] = malloc(sizeof(**cube) * height);
        for (int jj = 0; jj < height; ++jj) {
            cube[ii][jj] = malloc(sizeof(***cube) * width);
            for (int kk = 0; kk < width; ++kk) {
                cube[ii][jj][kk] =
                    kk + jj * width + ii * height * width + 1;
            }
        }
    }
    return cube;
}
\end{lstlisting}
\end{minipage}

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[ style=C,
                    label=lst:solution12,
                    caption={Solución al ejercicio 13 -- impresión}]
void print_cube(int ***cube, size_t depth, size_t height,
                size_t width) {
    for (int ii = 0; ii < depth; ++ii) {
        for (int jj = 0; jj < height; ++jj) {
            for (int kk = 0; kk < width; ++kk) {
                printf("%3d ", cube[ii][jj][kk]);
            }
            printf("\n");
        }
        printf("\n");
    }
}
\end{lstlisting}
\end{minipage}

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[ style=C,
                    label=lst:solution12,
                    caption={Solución al ejercicio 13 -- liberación}]
void free_cube(int ***cube, size_t depth, size_t height,
               size_t width) {
    for (int ii = 0; ii < depth; ++ii) {
        for (int jj = 0; jj < height; ++jj) {
            free(cube[ii][jj]);
        }
        free(cube[ii]);
    }
    free(cube);
}
\end{lstlisting}
\end{minipage}

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[ style=C,
                    label=lst:solution12,
                    caption={Solución al ejercicio 13 -- función \texttt{main}}]
int main(int argc, char const *argv[]) {
    int ***cube = malloc_cube(DEPTH, HEIGHT, WIDTH);
    print_cube(cube, DEPTH, HEIGHT, WIDTH);
    free_cube(cube, DEPTH, HEIGHT, WIDTH);
}
\end{lstlisting}
\end{minipage}

\item Escribe un programa que reciba un número variable de números como
argumentos e imprima la descomposición en factores primos de todo ellos.
Se recomienda hacer control de errores comprobando que los argumentos son
números antes de utilizarlos, etc.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[ style=C,
                    label=lst:solution12,
                    caption={Solución al ejercicio 13 -- función \texttt{main}}]
int main(int argc, char const *argv[]) {
    int ***cube = malloc_cube(DEPTH, HEIGHT, WIDTH);
    print_cube(cube, DEPTH, HEIGHT, WIDTH);
    free_cube(cube, DEPTH, HEIGHT, WIDTH);
}
\end{lstlisting}
\end{minipage}

\item Escribe un programa que lea \textbf{por consola} una serie de palabras
y que sólo deje de leer cuando se introduzca <<!!>> como palabra. Después, debe
imprimir dichas palabras en orden aleatorio. La función \verb!rand! devuelve
un número aleatorio entre cero y el máximo entero positivo. Si quieres que
devuelva números aleatorios \textbf{distintos} cada vez debes ejecutar
\verb!srand(time(NULL));! al inicio de la función \verb!main!. Debes incluir la
cabecera \verb!time.h!.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[ style=C,
                    label=lst:solution12,
                    caption={Solución al ejercicio 15}]
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#define STRING_SIZE (1024)
#define MAX_WORDS (1024)

int main(int argc, char const *argv[]) {
    char *word_set[1024];
    int word_length = 0;
    do {
        word_set[word_length] = malloc(STRING_SIZE);
        scanf("%s", word_set[word_length]);
        word_length++;
    } while (strcmp(word_set[word_length - 1], "!!"));

    srand(time(NULL));
    for (int ii = 0; ii < word_length - 1; ++ii) {
        char *aux            = word_set[ii];
        int rand_index       = rand() % (word_length - 1);
        word_set[ii]         = word_set[rand_index];
        word_set[rand_index] = aux;
    }
    for (int ii = 0; ii < word_length - 1; ++ii) {
        printf("%s\n", word_set[ii]);
        free(word_set[ii]);
    }
    free(word_set[word_length-1]);
}
\end{lstlisting}
\end{minipage}

Como nota, para <<barajar>> el vector de palabras lo que hago el recorrerlo
intercambiando cada palabra con una posición aleatoria. Hay otros métodos
que quizás hayas usado como generar una posición aleatoria del vector y copiarlo
a otro, el problema de esto es que si lo que haces es generar un índice nuevo
cuando encuentras que ya has copiado ese, el número de veces que ejecutas
el aleatorio es, lógicamente, impredecible. Tal y como lo he escrito yo el
algoritmo siempre tardará lo mismo generando resultados moderadamente
aleatorios.

\item Haz una función que lea dos archivos e \textbf{intercambie} su contenido,
escribe dicho programa de tal modo que no sea necesario alojar ninguno de los
dos archivos en memoria completamente.

\newpage
\begin{lstlisting}[ style=C,
                    label=lst:solution16,
                    caption={Solución al ejercicio 16}]
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char const *argv[]) {
    FILE *file_1 = NULL, *file_2 = NULL, *file_aux = NULL;
    const int BLOCK_SIZE = 1024;
    int read             = 0;
    char buffer[BLOCK_SIZE], aux_file_path[] = "/tmp/auxFile.txt";
    if (argc < 3) {
        printf("Uso: main.exe <archivo1> <archivo2>\n");
        return EXIT_FAILURE;
    }

    file_1 = fopen(argv[1], "r+");
    if (NULL == file_1) {
        printf("ERROR: El primer archivo no existe.\n");
        return EXIT_FAILURE;
    }

    file_2 = fopen(argv[2], "r+");
    if (NULL == file_2) {
        printf("ERROR: El segundo archivo no existe.\n");
        fclose(file_1);
        return EXIT_FAILURE;
    }

    file_aux = fopen(aux_file_path, "w+");
    if (NULL == file_aux) {
        fclose(file_1);
        fclose(file_2);
        return EXIT_FAILURE;
    }

    // copy file 1 to aux
    while (read = fread(buffer, sizeof(char), BLOCK_SIZE, file_1)) {
        fwrite(buffer, sizeof(char), read, file_aux);
    }
    fclose(file_1);
    file_1 = fopen(argv[1], "w+");
    if (NULL == file_1) {
        printf("Error, el primer archivo no se ha podido reabrir\n");
    }

    // copy file 2 to 1
    while (read = fread(buffer, sizeof(char), BLOCK_SIZE, file_2)) {
        fwrite(buffer, sizeof(char), read, file_1);
    }

    fclose(file_2);
    file_2 = fopen(argv[2], "w+");
    if (NULL == file_2) {
        printf("Error, el segundo archivo no se ha podido reabrir\n");
    }

    // copy aux file to file 2, we need to go back to begin of file aux
    fseek(file_aux, 0, SEEK_SET);
    while (read = fread(buffer, sizeof(char), BLOCK_SIZE, file_aux)) {
        fwrite(buffer, sizeof(char), read, file_2);
    }

    fclose(file_1);
    fclose(file_2);
    fclose(file_aux);
    remove(aux_file_path);
}
\end{lstlisting}

\item Escribe una función que reciba una palabra como argumento e indique
en qué posición (en bytes) dentro del archivo se encuentra la palabra. Sólo
tienes que dar la primera ocurrencia, si la palabra no se encuentra, devuelve
un número negativo. Haz un programa que, con esa función, reciba una ruta a un
archivo y una palabra e imprima el resultado de buscar la palabra en el archivo.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Solución al ejercicio 17},
label={lst:solution17}]
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int find_in_file(const char *path, const char *word) {
    FILE *file = NULL;
    char *buffer;
    int word_length = 0, read = 0, pos = -1;

    file = fopen(path, "r+");
    if (NULL == file) {
        printf("ERROR: El archivo no existe.\n");
        return -1;
    }
    word_length = strlen(word);
    buffer      = malloc(sizeof(char) * word_length * 2);

    while (read = fread(buffer, sizeof(char), word_length * 2, file)) {
        fseek(file, word_length - read, SEEK_CUR);
        for (int ii = 0; ii < word_length; ++ii) {
            char local_word[word_length + 1];
            memcpy(local_word, buffer + ii, word_length);
            local_word[word_length] = 0;
            if (!strcmp(local_word, word)) {
                pos = ftell(file) + ii - word_length;
                goto end;
            }
        }
    }
end:
    free(buffer);
    fclose(file);
    return pos;
}

int main(int argc, char const *argv[]) {

    int pos = find_in_file(argv[1], argv[2]);
    printf("La palabra %s está en la posición %d en el archivo %s\n",
           argv[2], pos, argv[1]);
}
\end{lstlisting}
\end{minipage}

Aquí puedes ver un uso típico de la instrucción \verb!goto!, como necesitamos
hacer lo mismo encontremos la palabra o no, lo que hacemos es establecer
una etiqueta y saltar allí para liberar recursos y devolver el resultado.

\item Reescribe el ejercicio 15 prescindiendo del array estático de punteros
a \verb!char!. (Usa \verb!realloc! y \verb!strdup!.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Solución al ejercicio 18},
label={lst:solution18}]
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

int main(int argc, char const *argv[]) {
    char word[1024];
    char **word_set = NULL;
    int word_length = 0;
    do {
        word_set = realloc(word_set, ++word_length * sizeof(char *));
        scanf("%s", word);
        word_set[word_length - 1] = strdup(word);
    } while (strcmp(word, "!!"));

    srand(time(NULL));
    for (int ii = 0; ii < word_length - 1; ++ii) {
        char *aux            = word_set[ii];
        int rand_index       = rand() % (word_length - 1);
        word_set[ii]         = word_set[rand_index];
        word_set[rand_index] = aux;
    }
    for (int ii = 0; ii < word_length - 1; ++ii) {
        printf("%s\n", word_set[ii]);
    }
    for (int ii = 0; ii < word_length; ++ii) {
        free(word_set[ii]);
    }
    free(word_set);
}
\end{lstlisting}
\end{minipage}


\item Escribe un programa que reciba un número indeterminado de palabras como
argumentos y los ordene alfabéticamente y que, después, los imprima.


\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Solución al ejercicio 19},
label={lst:solution19}]
void generic_swap(void *one, void *other, size_t type_size) {
//...

void generic_bubble_sort(void *array, size_t array_size,
//...

int compare_strings(const void *one, const void *two) {
//...

int compare_strings(const void* one, const void* two) {
//...

int main(int argc, char const *argv[]) {

    generic_bubble_sort(argv + 1, argc - 1, sizeof(char *),
                        compare_strings);

    for (int ii = 1; ii < argc; ++ii) {
        printf("%s\n", argv[ii]);
    }
}
\end{lstlisting}
\end{minipage}

He usado las funciones de ejemplo para ordenar, así que omito su contenido,
simplemente tenemos que utilizar el comparador adecuado y tener en cuenta que
el primer argumento es el nombre de programa, que no queremos ordenar. Además,
puedes ver que podemos modificar el orden de los argumentos, pero no su
contenido, al haber declarado \texttt{argv} como \verb!char const*argv[]! que
quiere decir un array (puntero) no constante a \verb!char! constante. Es decir,
como ya vimos en la figura \ref{img:constcharpointerpointer}.


\item Haz un programa que reciba como argumento una palabra y un número. Si el
número es cero, debe convertir la palabra a minúscula, si el número es distinto
de cero, debe convertirla a mayúscula.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Solución al ejercicio 20},
label={lst:solution20}]
#include <stdio.h>
#include <stdlib.h>

char char_to_upper_case(char c) {
    if (c < 123 && c > 96) {
        return c - 32;
    }
    return c;
}

char char_to_lower_case(char c) {
    if (c < 91 && c > 64) {
        return c + 32;
    }
    return c;
}

char string_to_upper_case(char *message) {
    int length = strlen(message);
    for (int ii = 0; ii < length; ++ii) {
        message[ii] = char_to_upper_case(message[ii]);
    }
}

char string_to_lower_case(char *message) {
    int length = strlen(message);
    for (int ii = 0; ii < length; ++ii) {
        message[ii] = char_to_lower_case(message[ii]);
    }
}

int main(int argc, char const *argv[]) {

    char *message = strdup(argv[1]);
    int code = atoi(argv[2]);
    if(code){
        string_to_upper_case(message);
    }else{
        string_to_lower_case(message);
    }
    printf("%s\n", message);
    free(message);
}
\end{lstlisting}
\end{minipage}

Aquí hemos utilizado dos funciones diferentes para poner a mayúscula y
minúscula, otra opción sería utilizar un parámetro lógico (o incluso un
enumerado) para indicar qué tipo de letras se quiere y llamar a una función
que reciba ese parámetro y actúe en consecuencia. Puedes implementarlo así
como ejercicio extra.

\item Crea un programa que dado un número como argumento imprima una pirámide
como esta de tantos pisos como el número indicado.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Solución al ejercicio 21},
label={lst:solution21}]
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

char **make_pyramid(int steps) {
    char **result = malloc(sizeof(*result) * steps);
    for (int ii = 0; ii < steps; ++ii) {
        result[ii] = malloc(sizeof(**result) * (steps * 2));
        memset(result[ii], ' ', steps * 2 - 1);
        memset(result[ii] + ii, '%', (steps * 2 - 1) - 2 * ii);
        result[ii][(steps - 1) * 2 + 1] = 0;
    }
    return result;
}

void free_pyramid(char **pyramid, int steps) {
    for (int ii = 0; ii < steps; ++ii) {
        free(pyramid[ii]);
    }
    free(pyramid);
}

int main(int argc, char const *argv[]) {
    int steps      = atoi(argv[1]);
    char **pyramid = make_pyramid(steps);
    for (int ii = 0; ii < steps; ++ii) {
        printf("%s\n", pyramid[ii]);
    }
    free_pyramid(pyramid, steps);
}
\end{lstlisting}
\end{minipage}




\item Escribe un programa que reciba una serie de puntos y de nombres para
cada uno y después los imprima en orden de su distancia al origen de menor a
mayor.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Solución al ejercicio 23 -- \texttt{tagged\_point.h}},
label={lst:solution23}]
#ifndef TAGGED_POINT_H
#define TAGGED_POINT_H
typedef struct tagged_point_s tagged_point_t;

tagged_point_t *tagged_point_create(const char *tag, double x,
                                    double y);

void tagged_point_set_tag(const char *tag, tagged_point_t *tp);

void tagged_point_set_x(double x, tagged_point_t *tp);

void tagged_point_set_y(double y, tagged_point_t *tp);

const char *tagged_point_get_tag(const tagged_point_t *tp);

double tagged_point_get_x(const tagged_point_t *tp);

double tagged_point_get_y(const tagged_point_t *tp);

void tagged_point_destroy(tagged_point_t *tp);

double tagged_point_distance(const tagged_point_t *a,
                             const tagged_point_t *b);
#endif
\end{lstlisting}
\end{minipage}

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Solución al ejercicio 22 -- \texttt{tagged\_point.c}},
label={lst:solution22}]
#include "tagged_point.h"
#include <math.h>
#include <stdlib.h>
#include <string.h>

struct tagged_point_s {
    char *tag;
    double x, y;
};

tagged_point_t *tagged_point_create(const char *tag, double x,
                                    double y) {
    tagged_point_t *res = malloc(sizeof(tagged_point_t));
    res->x              = x;
    res->y              = y;
    res->tag            = strdup(tag);
}

void tagged_point_set_tag(const char *tag, tagged_point_t *tp) {
    free(tp->tag);
    tp->tag = strdup(tag);
}

void tagged_point_set_x(double x, tagged_point_t *tp) { tp->x = x; }

void tagged_point_set_y(double y, tagged_point_t *tp) { tp->y = y; }

const char *tagged_point_get_tag(const tagged_point_t *tp) {
    return tp->tag;
}

double tagged_point_get_x(const tagged_point_t *tp) { return tp->x; }

double tagged_point_get_y(const tagged_point_t *tp) { return tp->y; }

void tagged_point_destroy(tagged_point_t *tp) {
    free(tp->tag);
    free(tp);
}

double tagged_point_distance(const tagged_point_t *a,
                             const tagged_point_t *b) {
    tagged_point_t origin = {"origin", 0.0, 0.0};
    if (NULL == a) {
        a = &origin;
    }
    if (NULL == b) {
        b = &origin;
    }
    return sqrt((a->x - b->x) * (a->x - b->x) +
                (a->y - b->y) * (a->y - b->y));
}
\end{lstlisting}
\end{minipage}

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Solución al ejercicio 22 -- \texttt{main.c}},
label={lst:solution22}]
#include "tagged_point.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef int(comparator_t)(const void *, const void *);

void generic_swap(void *one, void *other, size_t type_size) {
// ...

void generic_bubble_sort(void *array, size_t array_size,
// ...

int compare_distance(const void *a, const void *b) {
    tagged_point_t *p1 = *(tagged_point_t **)a;
    tagged_point_t *p2 = *(tagged_point_t **)b;
    return tagged_point_distance(NULL, p1) <
           tagged_point_distance(NULL, p2);
}

int main(int argc, char const *argv[]) {

    int point_lenght = 0;
    if ((argc - 1) % 3 != 0) {
        printf("Algo parece estar mal.");
        return EXIT_FAILURE;
    }
    point_lenght = (argc - 1) / 3;
    tagged_point_t *points[point_lenght];
    for (int ii = 0; ii < point_lenght; ++ii) {
        double x        = atof(argv[1 + ii * 3 + 0]);
        double y        = atof(argv[1 + ii * 3 + 1]);
        const char *tag = argv[1 + ii * 3 + 2];
        points[ii]      = tagged_point_create(tag, x, y);
    }

    generic_bubble_sort(points, point_lenght, sizeof(tagged_point_t *),
                        compare_distance);

    for (int ii = 0; ii < point_lenght; ++ii) {
        printf("%f %f %s\n", tagged_point_get_x(points[ii]),
               tagged_point_get_y(points[ii]),
               tagged_point_get_tag(points[ii]));
        tagged_point_destroy(points[ii]);
    }
}
\end{lstlisting}
\end{minipage}










\end{exercises}

\end{document}




