\documentclass[a4paper]{article}
\widowpenalties 1 10000
\usepackage{parskip}
\usepackage{newcent}
\usepackage[scaled=.95]{helvet}
\usepackage{nimbusmononarrow}
\renewcommand{\familydefault}{\sfdefault}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{titlesec}
\usepackage{babel}
\usepackage{eurosym}
\usepackage{graphicx}
\usepackage{float}
\usepackage{hyperref}
\hypersetup{
   linkbordercolor={1 1 1},
   pdfborderstyle={/S/U/W 1}
}
\usepackage{fancyhdr}
\usepackage{lastpage}
\usepackage[backend=biber, style=apa, citestyle=apa]{biblatex}
\addbibresource{bibliography/sources.bib}
\usepackage[]{geometry}
\geometry{
    a4paper,
    left=30mm,
    right=30mm,
    bottom=35mm,
    headheight=25mm
}

\usepackage{amsfonts}
\usepackage{subcaption}
\usepackage{listings}
\usepackage[dvipsnames,table]{xcolor}
    \definecolor{gray}{rgb}{0.5,0.5,0.5}
    \definecolor{lightYellow}{RGB}{251, 255, 212}
    \definecolor{lightBlue}{RGB}{56,184,255}
    \definecolor{backgroundColor}{RGB}{248,248,248}
    \definecolor{keywordColor}{RGB}{0,0,255}
    \definecolor{stringColor}{RGB}{163,21,21}
    \definecolor{commentColor}{RGB}{0,128,0}
    \definecolor{textColor}{RGB}{25,25,25}
\usepackage{cancel}
\usepackage{multirow}
\usepackage{array}
\usepackage{rotating}
\usepackage{newfloat}
\usepackage{caption}
\DeclareFloatingEnvironment[fileext=ecc,
                            placement={H},
                            name=Ecuación,
                            listname={Índice de ecuaciones}]
                            {ecuacion}
\captionsetup[ecuacion]{labelfont=normal}
\usepackage{multicol}
\usepackage{pdfpages}
\usepackage{tabularx}
\renewcommand{\tabularxcolumn}[1]{m{#1}}
\newcolumntype{Y}{>{\centering\arraybackslash}X}
\newcolumntype{R}{>{\raggedleft\arraybackslash}X}
\usepackage{tikz}
\usepackage{enumitem}
\newlist{exercises}{enumerate}{1}
\setlist[exercises]{label=\textbf{Ej. \arabic*:}, wide}
\newlist{stack}{enumerate}{6}
\setlist[stack]{leftmargin=*, label=\arabic*.}
\lstdefinestyle{C}{
    language=C,
    basicstyle=\ttfamily\color{textColor},
    numberstyle=\ttfamily,
    frame=none, % draw a frame at the top and bottom of the code block
    tabsize=4, % tab space width
    showstringspaces=false, % don't mark spaces in strings
    numbers=left, % display line numbers on the left
    commentstyle=\color{commentColor}, % comment color
    keywordstyle=\color{keywordColor}, % keyword color
    stringstyle=\color{stringColor}, % string color
    backgroundcolor=\color{backgroundColor},
    captionpos=b,
    morekeywords={bool},
    breaklines=true,
    literate=
            {Á}{{\'{A}}}1
            {É}{{\'{E}}}1
            {Í}{{\'{I}}}1
            {Ó}{{\'{O}}}1
            {Ú}{{\'{U}}}1
            {á}{{\'{a}}}1
            {é}{{\'{e}}}1
            {í}{{\'{i}}}1
            {ó}{{\'{o}}}1
            {ú}{{\'{u}}}1
            {ñ}{{\~{n}}}1
            {Ñ}{{\~{N}}}1
            {ü}{{\"{u}}}1
            {Ü}{{\"{U}}}1
            {¡}{{\char189}}1
            {¿}{{\char190}}1
            {\\\$}{{\$}}1
}
\lstdefinestyle{pseudoCode}{
    language= ,
    basicstyle=\normalfont \rm,
    frame=tb,
    numbers=none,
    commentstyle=\color{lightBlue}, % comment color
    keywordstyle= \bfseries \itshape, % keyword color
    stringstyle=\color{red}, % string color
    backgroundcolor=\color{white},
    captionpos=b,
    morekeywords={si,mientras,retornar,para,desde,hasta,en,otro,caso,FALSO,CIERTO,algoritmo,es,igual,no,menor,mayor,que},
    breaklines=true,
    literate=
            {Á}{{\'{A}}}1
            {É}{{\'{E}}}1
            {Í}{{\'{I}}}1
            {Ó}{{\'{O}}}1
            {Ú}{{\'{U}}}1
            {á}{{\'{a}}}1
            {é}{{\'{e}}}1
            {í}{{\'{i}}}1
            {ó}{{\'{o}}}1
            {ú}{{\'{u}}}1
            {ñ}{{\~{n}}}1
            {Ñ}{{\~{N}}}1
            {ü}{{\"{u}}}1
            {Ü}{{\"{U}}}1
            {¡}{{\char189}}1
            {¿}{{\char190}}1
            {\\\$}{{\$}}1
}
\definecolor{terminalRuler}{RGB}{231,234,237}
\lstdefinestyle{terminalStyle}{
    frame=none,
    numbers=none,
    rulecolor=\color{terminalRuler},
    language={},
    basicstyle=\ttfamily\color{textColor},
    numberstyle=\ttfamily,
    tabsize=4, % tab space width
    showstringspaces=false, % don't mark spaces in strings
    commentstyle=\color{lightBlue}, % comment color
    keywordstyle=\color{green}, % keyword color
    stringstyle=\color{red}, % string color
    backgroundcolor=\color{backgroundColor},
    captionpos=b,
    breaklines=true,
    literate=
            {Á}{{\'{A}}}1
            {É}{{\'{E}}}1
            {Í}{{\'{I}}}1
            {Ó}{{\'{O}}}1
            {Ú}{{\'{U}}}1
            {á}{{\'{a}}}1
            {é}{{\'{e}}}1
            {í}{{\'{i}}}1
            {ó}{{\'{o}}}1
            {ú}{{\'{u}}}1
            {ñ}{{\~{n}}}1
            {Ñ}{{\~{N}}}1
            {ü}{{\"{u}}}1
            {Ü}{{\"{U}}}1
            {¡}{{\char189}}1
            {¿}{{\char190}}1
            {\\\$}{{\$}}1
}
\renewcommand{\lstlistingname}{Program}
\renewcommand{\lstlistlistingname}{List of Programs}
\newcommand{\mod}{\mathop{\mathrm{m\acute{o}d}}}
\newcommand{\division}[1]{\begin{array}{|l}#1\\\hline\end{array}}
\newcommand{\padding}{\phantom{0}}
\newcommand{\centigrade}{°C}
\setcounter{secnumdepth}{5}
\setcounter{tocdepth}{3}
\newcommand{\sectionbreak}{\newpage}
\titleformat{\section}[hang]{\Large \rm \bfseries}{\thesection .}{1em}{}[]
\titleformat{\subsection}{\large \rm \bfseries }{\thesubsection .}{.75em}{}
\titleformat{\subsubsection}{\rm \bfseries }{\thesubsubsection .}{.5em}{}
\titleformat{\paragraph}{\bfseries\rm}{\theparagraph .}{1em}{}
\titlespacing*{\paragraph}{0pt}{3.25ex plus 1ex minus .2ex}{1.5ex plus .2ex}
\titleformat{\subparagraph}{\bfseries\rm}{\thesubparagraph .}{1em}{}
\titlespacing*{\subparagraph}{0pt}{3.25ex plus 1ex minus .2ex}{1.5ex plus .2ex}
\graphicspath{{img/}}
\def \autor{Francisco Rodríguez Melgar}
\def \titulo{Easy manual for C}
\def \organizacion{Computer engineer}
\title{\rm \textbf{\Huge{\titulo}}\normalfont }
\author{\LARGE{\autor}\\ \\ \Large{\organizacion}}
\begin{document}
\pagenumbering{gobble}
\maketitle
\begin{figure}[H]
    \center
    \includegraphics[width=.5\linewidth]{c_icon}
\end{figure}
\newpage
\cleardoublepage
\begin{flushright}
    \textit{<<Since it is more what you ignore than what you know, do not speak too much.>>}

    \textit{--Raimundo Lulio, scholar and saint from the island of Mallorca, Spain}
\end{flushright}
\cleardoublepage
\pagestyle{fancy}
\fancyhf{}
\fancyhead[C]{
\textrm{\Large\titulo\normalsize}\\
\rule[1mm]{0.3\hsize}{.5pt}\\
\textrm{ÍNDICES}
}
\fancyhead[R]{\includegraphics[height=2cm]{c_icon}}
\rfoot{\textrm{page \textsc{\thepage{}} of \textsc{\pageref*{startSectionContent}}}}
\fancyfoot[L]{\textrm{\today}}
\renewcommand{\footrulewidth}{0.5pt}
\pagenumbering{roman}
\tableofcontents
\newpage
\listoffigures
\newpage
\listoftables
\newpage
\lstlistoflistings
\label{startSectionContent}
\newpage
\hypersetup{
   linkbordercolor=black,
   urlbordercolor=black,
   pdfborderstyle={/S/U/W 1}
}
\pagenumbering{arabic}
\pagestyle{fancy}
\fancyhf{}
\fancyhead[C]{
\Large\rm\titulo\normalsize\normalfont\\
\rule[1mm]{0.3\hsize}{.5pt}\\
\textrm{\leftmark}
}
\fancyhead[R]{\includegraphics[height=2cm]{c_icon}}
% El único cambio es que aquí referencio la última página del documento.
\fancyfoot[R]{\textrm{page \thepage{} of \pageref*{LastPage}}}
\fancyfoot[L]{\textrm{\today}}
\renewcommand{\footrulewidth}{0.5pt}

\section{Introduction}
In this document I hope to be able to explain, at least, the basic fundamentals
of the C programming language. Also, I hope to offer reasons to learn it and
I will try to communicate to the reader part of the beauty I find in it.
Under this first header I will explain what is programming, which kinds
of languages do exist and offer an explanation about how we will structure this
document.

\label{section:queEsLaProgramacion}
\subsection{What is programming?}
Since this is a not very advanced manual, it is possible you have never had any
experience programming. If this is the case, I will explain shallowly what
``programming'' is. Programming is, according to the Oxford dictionary: ``the
process of writting and testing computer programs''. I am a simple guy and
have not put a foot in Oxford University but, perhaps naively, I expected a more
enlightening definition. It allows us to start, though, programming is to write
programs, therefore, to know what programming is, we need to know what a program
is.

A program is the set of instructions that a computer follows to perform a
concrete task. As an example, if you were a computer, and we made a program to
make you buy a coffee in a vending machine, the program that you as living
computer would follow would be something like this:

\begin{enumerate}
    \item Get up, if you're sit
    \item Walk to the coffe machine
    \item Choose the coffe you'd like to have
    \item Read the price of the coffee
    \item Put coins up to the price in the slot for coins
    \item Push the button of the desired variety of coffee
    \item Wait until it's done
    \item Pick up the coffee, and be careful no to scorch yourself!
\end{enumerate}

Put that way, it would be wonderful to tell to your computer, or to any
computer, something like ``solve this differential equation'' or ``predict the
weather of tomorrow.'' Sadly, this is where the craftiness of the programmer
comes in. Computers do not understand the language of humans. They do not know
what weather is nor what a coffe is. Computers only understand mathematical
operations (and not a lot) and logic operations. If you do not know what logic
is, as a science, do not worry, we will talk about it later.
The programmer must be able to turn a complex
task into a set of instructions a computer understands.

Finally, we could say that programming is ``articulate complex tasks in human
language in terms of simple tasks that a computer understands''.

\subsection{How does one program?}
Now we know \textbf{what} programming is, let's see how it is done, in
general terms. Following the methaphor I used before, a ``program'', as we
understand it, is a text file (or several) where those instruction the computer
needs to do something are. As I said before, computers understand a somewhat
small number of instructions, and, as a matter of fact, they only understand
binary code. A computer stores in its memory (what is commonly known
as RAM memory) the instructions that it must execute. That memory only stores
bits, digits in a numeric system that contains only two figures: zero and one.

If we apply the definition of the last chapter, to program, we must write
programs in zeroes and ones. To understand the magnitude of this, the program
Firefox, the web browser, occupies around 500~KB, or, what is the same, half a
million of bytes. A byte is eight bits. This means that the programmer that,
supposedly, wrote Firefox would have had to write a continous file of four
millions of zeroes and ones. It is only logical to think this is not the case.

Since the earliest times of computer science and software development
people have come up with \textbf{formal languages} that explain in a
comprehensible way to the human being how a program must be, but that allow us
to make a program composed of those zeroes and ones. This is where the different
languages you may have heard of come in: C, C++, C\#, Java, Rust...
All those languages differ in that they're different ways (each one with its
pros and cons) to compose a program that, after a process, the computer is able
to understand. This process is \textbf{compilation}. To compile a program is
turning it from that language humans can understand (and that you are going to
learn to write, I hope with my help) into a pure computers' language. The code
writen in those languages is called \textbf{source code} because it is the
source from which we will obtain (compile) our programs. In general, I am not
going to make a distinction between the program (compiled program) and the
source code. We will tell them apart by the conext.

So, if we add this information to what we had before, we could say that
programming is: ``to write a file in a programming language that can be
compiled into a program the computer can execute directly''.

\section{Environment set up}
Maybe you're already impatient, or perhaps you stopped reading a long time
ago, But I think that introduction was needed, at least for those that do not
know what programming is at the most basic level. Now we are going to talk about
how to prepare an \textbf{environment} to program. The environment is the set of
tools we are going to use to write and compile our programs.
The problem of C is that it's a language very ``close to the computer'', what
does this mean? That it is more difficult to understand and write for people,
therefore the preparation you will need to do to program in C is a little bit
more complex that if you used other languages. So let's go little by little.

\subsection{Operating system}
If you're reading this manual, or this part, I understand you didn't explore
programming before. Let's start by the beginning. Since C is a language
computers understand more easily, we must know which operating system we have.
If you haven't altered your computer in any way, the most probable thing is
that you have a computer with Windows. Ideally you should install Linux, or
create a virtual machine with it, or use the Windows subsystem for
Linux.

Since explaining all the alternatives would make this manual very long and also
would force me to make distinctions in each one of the following sections, I am
going to suppose you are using the Windows subsystem for Linux, or WSL. The
first step is to install the Windows characteristic that allows us to
do that. Hit the Windows key and the letter R. Write in the little window that
pops up \verb!optionalfeatures! and hit enter. A window will pop up
where you should look for the element ``Windows subsystem for Linux'', check the
box in the left of the option and push accept. Restart when it is asked for it.
After it, you will go to the Microsoft Store app and will look for ``Ubuntu''.
Go to the first result and install it. After that, go to the start menu and
open the app (Ubuntu). It will take a moment to install. After it completes,
it will ask you to input an username and a password. Just a note: when you start
writting the password you will not see anything, don't worry, it's supposed to
be like that, just write the password, it will ask you to input it twice, if
you did it differently, it will tell you to do it again. Be sure to remember
the username and password. When you are done, you will looking at a black screen
with a text that will read \verb!{user}@{machine_name}:~$!. Congratulations,
you have installed a Linux you can use in Windows.

This black window that only contains letters is called a terminal, and it is
a way to interact with the computer that has been in use since decades ago.
Instead of clicking icons, you will write commands in the terminal and you
will hit enter. I am going to give you a series of basic commands and
concepts so you can use it. In a terminal, at any given moment you are in a
\textbf{work directory}, for example, if you write \verb!pwd! and you hit enter,
it will tell you in which directory you are in. Directory is just a fancy word
computer people use to say what we call folder when using computers, a place
where other files and folders may be put.
I will show you an example of how it would look.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=terminalStyle]
john@DESKTOP-U8OA808:~\$ pwd
/home/john
\end{lstlisting}
\end{minipage}

With the command \verb!cd! you move your work directory. Every directory has two
special directories inside, the dot directory (\verb!.!) and dot-dot
(\verb!..!). The first one is the same directory, that is: if you perform
\verb!cd .! you will stay in the same directory. The second is the parent
directory, for example:

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=terminalStyle]
john@DESKTOP-U8OA808:~\$ pwd
/home/john
john@DESKTOP-U8OA808:~\$ cd ..
john@DESKTOP-U8OA808:/home\$ pwd
/home
john@DESKTOP-U8OA808:/home\$
\end{lstlisting}
\end{minipage}

In order to give you a better idea of what a filesystem is, I am going to
explain it to you more thoroughly. In Windows, all your files and directories
are in drives, which have letters assigned and end with a colon (\verb!:!).
For example, the most common path for the desktop is
\verb!C:\users\userName\Desktop! (userName being the name of the user whose
dekstop we're talking about, let's say John). On the contrary, in Linux this is
not this way, all directories come from the root directory (\verb!/!). Note: if
you haven't noticed yet, in Windows directory paths are written with backslashes
(\verb!\!) and in Linux with forward slashes (\verb!/!). Each drive in Windows
tends to be a physical drive: a memory stick, a hard disk, an SSD... In Linux,
when you insert a drive or disk, it will simply \textbf{mount} in a directory
like any other. That is: the files and directories of the new disk will be put
in one point of the directory tree we already had.

These directories work like a series of dots joined by connections. Each
directory or file is a dot, connected to the directory it hangs from, and
having all the directories it has inside hanging from it. This may be drawn
like I'm going to show you now:

\begin{figure}[H]
    \includegraphics[width=\linewidth]{filesystems}
    \caption{Example of a filesystem}
    \label{img:extensions}
\end{figure}

In this figure, each directory has linked to it those inside it, and all of them
show where the directory \verb!..! which is inside them goes. As you can see, to
reach a path like \verb!/usr/games! we only have to ``hop'' from a directory to
the next. If we wanted to come back, we can use the fictional directories that
point to the father of the directory we're in (\verb!..!).

The case of the root
directory is special, because its parent directory is the same directory. In
Windows the system is similar, but there is not only one root, there are
several. Those being the different storage drives we have. Also, we do not need
to be all the time hoping in one level jumps, we can use complete paths to
navigate from a place to the other. If you haven't figured it out yet by the
context, a path is simply the succession of directories that go from one to
another. There are two types of paths:
\begin{enumerate}
    \item Absolute paths: Those are the ones that start by slash, and they
    indicate a path from the root directory to a concrete directory or file.
    For example: \verb!/home/john/music/Beethoven_symphony.mp4! would be and
    absolute path.
    \item Relative paths: they are those that do not start from the root
    directory, but from the work directory. For example:
    \verb!music/Beethoven_symphony.mp4! is relative path that will point to
    an existing file only if inside the current work directory there is a
    directory called \verb!music! and, inside it, a file named
    \verb!Beethoven_symphony.mp4!.
\end{enumerate}

The text it shows up everytime you hit enter is called a prompt and, in general,
it shows you your username, the machine where you are and after that, your
working directory, if it fits in the screen. I am going to substitute the prompt
just for a dollar sign in the examples I show you, so it fits better in the
page. When you first started your terminal it showed a tilde (\verb!~!) because
that's an alias of your home directory, which is a route in Linux systems where
the user stores his personal files. Generally speaking, that route is in
\verb!/home/<username>! for example \verb!/home/john!.

Now we are going to learn to see what is inside a directory, the command that
allows us to do so is \verb!ls!, if you type it and hit enter you'd see...
nothing. That's because we have not created any file in our home directory,
the command to create files is called \verb"touch". Write \verb!touch test.txt!
and hit enter, if you now perform \verb!ls!, you would see it will show up.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=terminalStyle]
\$ touch test.txt
\$ ls
test.txt
\$
\end{lstlisting}
\end{minipage}

\verb!ls! has a lot of options, options of Linux commands are set with a dash
infront of them, so, if you're told ``\verb!ls! with the options a and l'' you
must write \verb!ls -l -a! or, joining all them in the same dash: \verb!ls -la!
Something like this should appear on the screen.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=terminalStyle]
\$ ls -la
total 8
drwxr-xr-x 1 john john  512 Jul  8 19:05 .
drwxr-xr-x 1 root root  512 Jul  7 22:37 ..
-rw-r--r-- 1 john john  220 Jul  7 22:37 .bash_logout
-rw-r--r-- 1 john john 3771 Jul  7 22:37 .bashrc
drwxr-xr-x 1 john john  512 Jul  7 22:37 .landscape
-rw-rw-rw- 1 john john    0 Jul  8 18:25 .motd_shown
-rw-r--r-- 1 john john  807 Jul  7 22:37 .profile
-rw-rw-rw- 1 john john    0 Jul  8 19:05 test.txt
\end{lstlisting}
\end{minipage}

As you can see, there are many files you have not created. This is because the
\verb!a! option makes \verb!ls! to show us \textbf{all the files}, including the
hidden ones, which are hidden because their name starts with a dot. The option
\verb!l! makes the command to show the files in a list, with more information
about them. If this is a bit intimidating to you, it is normal, and I have good
news. WSL sees the directories you have in you Windows system, so you can create
a folder in your desktop and work with the Windows explorer, to create or delete
files.

\subsection{Installing the compiler}
Now we already have a Linux installed in the computer, let's install the
compiler. To do that, we are going to execute the commands the are shown next.
If while executing any of them you are asked if you want to go ahead, answer
yes.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=terminalStyle]
$ sudo apt update
#Lots of text will be shown here, don't mind it.
$ sudo apt install build-essential
........
After this operation, 189 MB of additional disk space will be used.
Do you want to continue? [Y/n] y
........
\end{lstlisting}
\end{minipage}

Now you should have the compiler installed, it is called GCC, it is an achronym
meaning GNU Compiler Collection. To see if that is the case, type the following
command. And check the output is similar to the one shown here.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=terminalStyle]
\$ gcc -v
Using built-in specs.
COLLECT_GCC=gcc
COLLECT_LTO_WRAPPER=/usr/lib/gcc/x86_64-linux-gnu/9/lto-wrapper
OFFLOAD_TARGET_NAMES=nvptx-none:hsa
OFFLOAD_TARGET_DEFAULT=1
Target: x86_64-linux-gnu
Configured with: ../src/configure -v --with-pkgversion='Ubuntu 9.3.0-17ubuntu1~20.04' --with-bugurl=file:///usr/share/doc/gcc-9/README.Bugs --enable-languages=c,ada,c++,go,brig,d,fortran,objc,obj-c++,gm2 --prefix=/usr --with-gcc-major-version-only --program-suffix=-9 --program-prefix=x86_64-linux-gnu- --enable-shared --enable-linker-build-id --libexecdir=/usr/lib --without-included-gettext --enable-threads=posix --libdir=/usr/lib --enable-nls --enable-clocale=gnu --enable-libstdcxx-debug --enable-libstdcxx-time=yes --with-default-libstdcxx-abi=new --enable-gnu-unique-object --disable-vtable-verify --enable-plugin --enable-default-pie --with-system-zlib --with-target-system-zlib=auto --enable-objc-gc=auto --enable-multiarch --disable-werror --with-arch-32=i686 --with-abi=m64 --with-multilib-list=m32,m64,mx32 --enable-multilib --with-tune=generic --enable-offload-targets=nvptx-none=/build/gcc-9-HskZEa/gcc-9-9.3.0/debian/tmp-nvptx/usr,hsa --without-cuda-driver --enable-checking=release --build=x86_64-linux-gnu --host=x86_64-linux-gnu --target=x86_64-linux-gnu
Thread model: posix
gcc version 9.3.0 (Ubuntu 9.3.0-17ubuntu1~20.04)
\end{lstlisting}
\end{minipage}

If you get a similar text, congratulations, you have installed the C compiler.
Now we are going to, finally, start learning the concepts of the language.

\section{Your first program; say hello to the world!}

Let's navigate into that folder you have in the desktop. Units of your Windows
computer (the drives C, D, E...) are presented in the WSL as directories inside
the path \verb!/mnt!. So, \verb!C:! will be under \verb!/mnt/c!. I leave next an
example on how to navigate to a folder called \verb!hello_world! in your Windows
desktop. You can create it as you're used to now.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=terminalStyle]
\$ cd /mnt/c/Users/John/Desktop/
\$ cd hello_word
\$ pwd
/mnt/c/Users/John/Desktop/hello_world
\$
\end{lstlisting}
\end{minipage}

Now you are already in the folder, open it in the file explorer, because we
have the last configuration left. In the Windows file explorer, in the top of
the window, click on the View tab and check the box next to ``show extensions
of known file types''. Next there is a picture of how it looks.

\begin{figure}[H]
    \includegraphics[width=\linewidth]{extensions_en}
    \caption{Configure how to see the extensions of known file types}
    \label{img:extensions}
\end{figure}

Now, in the way you like the most (the terminal or the mouse), create a file
in that folder called \verb!hello_world.c!. Open it with the Windows Notepad,
and I mean the Notepad, I do not mean WordPad, or Word. In that document we are
going to write the following.

\begin{figure}[H]
\begin{verbatim}
#include <stdio.h>

int main(void)
{
    printf("Hello, world!\n");
}
\end{verbatim}
\end{figure}

I want to clarify that the line that is displaced to the right is so because it
has spaces in the left side. You can write two, four or eight, I recommend four
as a general rule. Save the file, and go back to the terminal. You should have
the file in the directory. Make \verb!ls! to check it is in. Also, remember you
need to navigate to the folder if you closed the terminal or changed work
directory. Now we are going to compile our first program. To do that, we will
invoke GCC. I will list the commands and their expected output next.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=terminalStyle]
\$ ls
hello_world.c
\$ gcc -o hello_world.elf hello_world.c
\end{lstlisting}
\end{minipage}

When doing this, a new file will appear in the directory, called
\verb!hello_world.elf!. Congratulations! that is your first program in C. What
does it do? It prints ``Hello, world!''. If you make double click on it, you
will see that Windows does not know how to open it. That is because it is a
Linux executable. Because of that, in the terminal, write
\verb!./hello_world.elf!. If you remember what I told you before, a path that
does not start with the root directory is a relative path, and the directory
dot \verb!.! is a relative path. When the terminal gets a command from the user,
it looks for a program with that name in a series of directories that are
configured in your operating system. If you want to execute any other program
(or other things you can execute, but I won't get tangled on them now) you must
indicate a path, relative or absolute. To make the terminal understand we are
introducing a path and not a command, we start it by dot, that is, this very
directory. When you hit enter, you should see something like this:

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=terminalStyle]
\$ ./hello_world.elf
Hello, world!
\end{lstlisting}
\end{minipage}

You you have compiled your first program, may be you are a bit disappointed,
since you do not understand what it does, or how it does it. Hence it is the
moment we adquire a compromise with each other. That is, if you do not
understand something that appears in the programs we are going to see together,
you will trust I will clarify eventually when the moment arrives, from my side,
my compromise is that I will do it the earliest I can, so you have to put the
least amount of effort in ignoring things you don't know.

For now, I will explain what the command we have issued before is, gcc is, as
I said before, the C compiler, the option \verb!o! (remember that I explain
what options were when I explained you how to use \verb!ls!) indicates that the
next thing we are going to write is the name of the program we want to create
and, finally, the name of our source code file. If you put \verb!main.elf! the
resulting file would be called that, or anything you wanted, I'll be compiling
my programs as to files called \verb!main.exe! mainly.

\subsection{Text editor}
You edited your first program with the notepad, but editing code in that way
if a bit unbearable. Partially this is so because it is usual to use specialized
editors that colorize the words that are important in the concrete programming
language you are using and help you with things like knowing where the braces
that close the one your looking at now. I am going to leave here a list of
some common editors used with C code. I will not assume you are using any
concrete one, so choose the one you like. I use the first one, but may be for
your first steps you may stick to Notepad++, which is simpler, and jump
to another one when you feel more comfortable writting more complex programs.
\begin{enumerate}
    \item Visual Studio Code.
    \item Atom.
    \item Sublime text
    \item Notepad++
\end{enumerate}

\section{First steps}

Now you already know what a source code file is I am going to show you how we
are going to include code fragments in the manual. Let's revisit the program
\verb!hello_world.c!.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C, caption={Hello World in C},
label={lst:helloWorld}]
#include <stdio.h>
int main(void)
{
    printf("Hello, world!\n");
}
\end{lstlisting}
\end{minipage}

As you can see, the lines are numbered, and there are words in blue, and others
in red. The blue word are the ones called key words, for now, remember that
all your programs must contain the lines 1, 2, 3 and 5 and that, between the
lines 3 and and 5 you will write the instructions that will make up your source
code files.

\subsection{Variables}

We are getting into business, at last! One of the first things that are needed
in a program are \textbf{variables}, a variable is an abstraction to designate a
space in the memory of the computer in which we store things. When we create a
variable we say to the computer: ``save this space in your memory to store
data''. C is a language of the kind we call typed, that is, each variable has a
type and cannot change that type after it is created. In C there is a set of
basic types that I will show you in a handy table.

\begin{table}[H]
    \centering
    \begin{tabularx}{\linewidth}{|c|c|c|Y|}
        \hline
        \textbf{Name} &\textbf{Size} (in bytes)&\textbf{Range}&\textbf{Ussage} \\\hline
        \texttt{char} & 1 & $[-128, 127]\vphantom{\matrix{1\cr1\cr1\cr}}$ & One text character or a byte\\\hline
        \texttt{short}& 2 & $[-32\,768, 32\,767]\vphantom{\matrix{1\cr1\cr1\cr}}$& Number in that range (generally network ports)\\\hline
        \texttt{int}&   4  & $[-2\,147\,483\,648, 2\,147\,483\,647]\vphantom{\matrix{1\cr1\cr1\cr}}$&General type for integer numbers\\\hline
        \texttt{float}& 4 & $[\pm3.4\cdot{}10^{-38}, \pm3.4\cdot{}10^{38}]\vphantom{\matrix{1\cr1\cr1\cr}}$ & Simple precision decimal numbers\\\hline
        \texttt{double}&8 &$[\pm1.79\cdot{}10^{-308}, \pm1.79\cdot{}10^{308}] \vphantom{\matrix{1\cr1\cr1\cr}}$ & Double precision decimal numbers\\\hline
    \end{tabularx}
    \caption{Basic types of C}
    \label{tab:basicTypes}
\end{table}

A table like that one may be intimidating at first, but it is simple. When we
declare (create) a variable, we must say what type it has. I like to say that
variables are like boxes and that, according to their type, inside that box
some things fit and some others do not. To declare a variable, you write its
type and a name, and do not forget to end the line with a semicolon (;)! Apart
from declaring them, we must learn to give them a value. That is called ``assign
a value'', and it is done with the equal sign (\verb!=!). To give it a value you
write the name of the variable, the equal sign and the value, let's see some
examples and I'll get into some caveats.

Regarding the name: the name of a variable is made out of letters, numbers and
underscores. The name of a variable must not be writen all in uppercase, but
it can contain some. It cannot start by a number, and \textbf{you should not start
it with an underscore}. In general, you can use two notations to write variable
names in C (and in any programming language):
\begin{enumerate}
    \item \textbf{Camel case}: if a name contains several words, they must be
    writen together, with the first letter of each word in uppercase,
    excluding the first. For example: \verb!betterValue! or \verb!targetNumber!.
    It is called like this
    because the uppercase letters remind of the humps of a camel.
    \item \textbf{Snake Case}: The words are separated by underscores, all in
    lowercase, for example:  \texttt{better\_value} or \texttt{target\_number}. It is
    called like that because the shape of the names writen in this fashion
    remind of a snake that has eaten animals and has bulges in its body.
\end{enumerate}

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C, caption={Declaration and assignment of variables},
label={lst:variableAsignation}]
#include <stdio.h>
int main(void)
{
    char letter = 'a';
    char byte = 120;
    short shorty = 5520;
    int money_i_want;
    float money_i_have = 3.22F;
    double money_you_have = 52.55;

    money_i_want = 450000;
    shorty = 11111;
}
\end{lstlisting}
\end{minipage}

Computers do not understand about letters, only numbers, therefore, when you
tell the computer that \verb!letter! is equal to \verb!'a'!, you tell it it's
equal to the number that letter has assigned. Mind that to assign the value
of a \verb!char! you must use simple straight quotes. The correspondency between
letters and numbers is writen in the ASCII table, if you want to read it, I
leave this \href{https://www.ascii-code.com/}{link} to a site where u can
check it up. If you look there, you will see that the letter a has the value
97. After that, we assign to other char a numeric value, in line 7 you can see
we declare a variable without assigning a value to it. That is totally okay, but
beware!, \textbf{a variable to which you have not assigned a value has a random
value}. This is why many teachers would advice you that everytime you declare a
variable you should give it a value immediately. This process (giving value to
a variable for the first time) is called ``initialize'' a variable.

In lines 11 and 12 we give value to variables that we have declared before,
and I want to take some time talking about line 12. At first, it could seem
that when writing \verb!shorty = 5520;! we are enunciating a mathematical
equality, that that is always going to be the same, but in C we do not work with
``laws'', but with instructions, so you shall not read that line as ``the value
of shorty is 5520'' but ``I have assigned the value 5520 to shorty''. That is:
you have put into the ``box'' a 5520, but nothing avoids you to pull that
value out and put another one in as we do in line 12.

The values a programmer writes in the source code are called ``literals''. I
think that the name is pretty much self explanatory. Each literal has a type,
in the same way variables have. Later we will see why that's important. For now,
remember that literal is the name of values the programmer writes
explicitly in the code. That would be, numbers (like 5520) or letters,
(like \verb!'a'!). Apart from literals, we can assign to a variable the
value of an \textbf{expression}, a expression is any text writen in the C
language that has a value. For now, we are going to limit ourselves to assign
one variable to other variables.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C, caption={Assigning variables to other variables},
label={lst:variableAsignationBetween}]
#include <stdio.h>
int main(void)
{
    int a = 3;
    int b = 2;

    a = b;
}
\end{lstlisting}
\end{minipage}

In line 7 we can see how I assign to the variable \verb"a" the value of the
variable \verb!b!, therefore, it will have a value of 2, now. Since seeing this
is difficult, I am going to include in the next example a series of lines with
the word \verb!printf! in them, you may remember it from our first program.
Later on, I will teach you to use it, but, at the moment, simply copy this
program in your file of source code and compile it as we did before. (Copying
things from a PDF tends to be problematic, therefore type it yourself, also, it
will serve as typing practice.)

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C, caption={Final example of variable using},
label={lst:variableFinalExample}]
#include <stdio.h>
int main(void)
{
    int a = 3;
    int b = 10;
    printf("a is equal to: %d\n", a);
    a = b;
    printf("b is equal to: %d and a is the same, that is: %d\n", b, a);
    b = 22;
    printf("b is equal to: %d, a still is %d\n", b, a);
}
\end{lstlisting}
\end{minipage}

If you type this program, compile it and execute it, you should see something
like this:

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=terminalStyle]
\$ ./main.exe
a is equal to: 3
b is equal to: 10 and a is the same, that is: 10
b is equal to: 22, a still is 10
\end{lstlisting}
\end{minipage}

As you can see, when \verb!a = b! is writen, \textbf{the values of a and b are
not linked together}. Nevertheless, when assigning any value to a variable, you
must be careful. Going back to the methaphor of the boxes, in a box you can fit
things of a certain set of shapes and sizes. If a data is, for instance, a
decimal number (wether it is a float or a double) if it is assigned to an
integer variable it will lose its decimal part. But there is more, if you apply
this logic, what would happen if you assign a number such as 1203 to a
\verb!char!? If you go to the table \ref{tab:basicTypes}:
\nameref{tab:basicTypes}, you will see that 1203 is outside the range of
\verb!char!. What happens is... you do not know what happens. The elegant way of
saying this is: ``undefined behaviour''. The next program is an example of that.


\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C, caption={Erroneous assignments},
label={lst:invalidAssignations}]
#include <stdio.h>
int main(void)
{
    char c = 1500;
    short s = 5555555;
    float f = 3.8e105;

    printf("c: %d\n", c);
    printf("s: %hd\n", s);
    printf("f: %f\n", f);
}
\end{lstlisting}
\end{minipage}

If you compile it, the compiler will throw a series of messages called warnings.
Those warnings warn you that, while something is correct, it seems it contains
some error. For example, if you wrote ``I did not know your Belgian'' the
sentence would be technically correct, it would mean you didn't know a Belgian
person related in some way to the person you're talking to, regardless, more
probably, you wanted to say  ``I did not know you're Belgian ''. If we compile
and execute, something like the following should appear in the terminal.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=terminalStyle]
\$ gcc -o main.exe main.c
main.c: In function 'main':
main.c:86:14: warning: overflow in conversion from 'int' to 'char' changes value from '1500' to '-36' [-Woverflow]
   86 |     char c = 1500;
      |              ^~~~
main.c:87:15: warning: overflow in conversion from 'int' to 'short int' changes value from '5555555' to '-15005' [-Woverflow]
   87 |     short s = 5555555;
      |               ^~~~~~~
\$ ./main.exe
c: -36
s: -15005
f: inf
\end{lstlisting}
\end{minipage}

As you can see, neither the \texttt{char} is equal to 1,500 nor the
\texttt{short} is 5,555,555, because they cannot be. The compiler does not say
anything about the \texttt{float} or the \texttt{double}, the reason is that
both data types have a special value called infinity, which symbolizes infinity.
This is because, as we will see later on, they do not represent numbers in a
totally correct way, and that's why they can be positive and negative infinity.

Let's take some time for the problem of decimal numbers. If you know how binary
code works, you would know that a binary number of $n$ bits you can represent
$2^n$ numbers. In the case of decimal numbers, we use one complex system called
IEEE 754. I am not going to go into detail here, but the main problem of this
way of representing numbers is that it is not only not exact (for example,
the number 0.1 cannot be represented exactly), but its precission is not
constant. What does this mean? That if near the zero the float may distinguish
between 1.10 and 1.11, it is possible they cannot distinguish 10000000.10 from
10000000.11. Be careful about that when you use decimal numbers.

As you have seen here, there are allowed assignments and forbidden ones. The
allowed ones (those the compiler does not see as something bad), are called
implicit conversions, their names comes from the fact you do not need to do
anything to make them happen, for example, assigning a char value to an integer
variable. Later on I will teach you to perform conversions between data types
explicitly.

\subsection{Printing things}
Programmers call ``print'' to write things into files and, specially, in the
screen, like your first program that wrote ``Hello, world!''. I do not want to
get ahead of myself, because there are several concepts behind what we use to
print things on the screen, nevertheless, I need you to be able to show things
on the screen to be able to test your own programs.

To print things on the screen you must use the word \texttt{printf}. With a
syntax (syntax just means the way things are suppossed to be writen) a little
bit difficult. You must write \texttt{printf}, an opening parenthesis and a thing
called ``format'' which is the text that is going to be printed, surrounded by
double straight quotes (\texttt{"}). To include variables in that printing, you
must put ``specifiers'', which are special texts that signal \textbf{the type}
of the variables you want to print. After the format, we will write the
variables we are going to print, separated by commas, in the order we wrote
their specifiers. Also, there are some special characters you must write in a
special manner: the new lines and the tabulators. This is a bit confusing, so
I will show you two tables where you can see the specifiers and the special
characters.

\begin{table}[H]
\centering
\begin{tabularx}{\linewidth}{|c|Y|}
\hline
\textbf{Specifier} & \textbf{Type it prints}                                                    \\ \hline
\texttt{\%d}& Integers (\texttt{int})                                                           \\ \hline
\texttt{\%f}& \texttt{float}                                                                    \\ \hline
\texttt{\%lf}& \texttt{double}                                                                  \\ \hline
\texttt{\%hd}& \texttt{short}                                                                   \\ \hline
\texttt{\%c}& \texttt{char} as characters (no numbers)                                          \\ \hline
\texttt{\%s}& Text, writen as \texttt{\textquotedbl A text\textquotedbl}, quotes included.      \\ \hline
\texttt{\%p}& Pointers, they are an advanced feature of the language, I will explain them later \\ \hline
\end{tabularx}
\caption{Format specifiers}
\label{tab:formatSpecifierC}
\end{table}

On the other hand, the special characters are these, and are written with a
backwards slash (\textbackslash{}) infront of them. In the table I already
included the backward slash. Also, since the specifiers are written starting with
percentage symbol (\verb!%!), if you want to print it, you need to put it twice.

\begin{table}[H]
\centering
\begin{tabularx}{\linewidth}{|c|Y|}
\hline
\textbf{Sequence} & \textbf{Printed character}                       \\\hline
\texttt{\textbackslash{}\textbackslash{}} & Backwards slash          \\\hline
\texttt{\textbackslash{}n}& New line                                 \\\hline
\texttt{\textbackslash{}t}& Tabulator (prints spaces until the next character is aligned with four character column in the terminal) \\\hline
\texttt{\%\%}& Will print just one percentage symbol.                \\\hline
\end{tabularx}
\caption{Sequences to print special characters}
\label{tab:specialCharsC}
\end{table}

This is a bit dry, let's see an example.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C, caption={Ejemplo de impresión.},
label={lst:decimalvsintergerDivision}]
#include <stdio.h>
int main(void)
{
    int integer = 654654;
    short shorty = 25254;
    char charty = 'a';
    double decimal = 2.3;
    printf("The integer is:\t%d\nThe short is:\t%hd\nThe char is the letter:\t%c\nThe decimal number is:\t%f\n", integer, shorty, charty, decimal);
}
\end{lstlisting}
\end{minipage}

The line is very long and in this page is it written as many, but you should
write it as a single line. If you look closely, there is only one line number,
that indicates that it's the same line but it is broken so it fits in the page.
The program, once compiled and executed, should print something like this.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=terminalStyle]
\$ ./main.exe
The integer is: 654654
The short is:   25254
The char is the letter: a
The decimal number is:  2.300000
\end{lstlisting}
\end{minipage}

As a bottom line: \texttt{printf} does not add anything you do not put in it,
like new lines, so if you want to print the next thing in a new line, remember
to write \verb!\n! at the end of the format. Also, it is good that your program
prints a new line character as the last thing, if not, it could leave things
unprinted. That's because the terminal forces itself to print everything you
have ordered it to print when it finds a new line.

\subsection{Operators}
Playing a shell game with the values of the variables you declare in a program
is boring, I know, therefore we are going to learn to perform operations with
them. In C (and in any other programming language) there are the so called
\textbf{operators}. They are symbols that allow us to perform calculations.
Operators are a mathematical concept, and are applied to a set of arguments, or
better put, operands. In math, the symbols $+$, $-$, $\times$ and $\div$ are
mathematical operators for addition, substraction, multiplication and division,
respectively. In the same way we have done with the basic types, I will present
the operators in a table and later on we will see examples on how to use them.

\begin{table}[H]
\centering
\begin{tabularx}{\linewidth}{|c|Y|}
\hline
\bf Operator & \bf Description \\ \hline
\tt + & Addition. Adds integers and decimals together and between them. \\\hline
\tt - & Substraction. Substracts from the left operand the value of the right operand. \\\hline
\tt / & Division. Return the result of the division of the left operand by the right one. Note that, \textbf{if both operands are integers}, the operator performs integer operation, that is, \textbf{without decimals}. \\\hline
\tt * & Multiply. Asterisk has many functions in C, but this is the first of them you will discover. The type of the multiplication of two integer is always a \textbf{double}.\\\hline
\tt ++ & Increment. Makes a number (either integer or decimal) go up one unit, it can be prefix (before the operand) or postfix (after the operand).\\\hline
\tt -{}- & Decrement. Works as the increment, but it makes the number to go down one unit. \\\hline
\tt \% & Module. Is an operator that return the residue of the division of the left operand by the right operand. \\\hline
\end{tabularx}
\caption{Basic math operators in C}
\label{tab:mathOperators}
\end{table}

In the last section I told you that we could assign a value to a variable.
I also told you that an expression is a fragment of C code with a value, and
that the name of a variable alone is an expression. Now we have operators, we
can write more complex expressions, for example \verb!a+b! would be an
expression whose value would be the addition of a and b.
We can make calculations now!

You must be careful, though, because, as I said before, all expression in C has
a \textbf{type} and, as we saw in the last section, assigning a value of
incorrect type to a variable is error prone. For example, the operator division
behaves differently if the operands (the numbers we're dividing) are integer or
decimal. Let's see and example.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C, caption={Integer division vs decimal division},
label={lst:decimalvsintergerDivision}]
#include <stdio.h>
int main(void)
{
    double d1 = 1/3;
    printf("d1: %f\n", d1);

    double d2 = 1.0/3;
    printf("d2: %f\n", d2);
}
\end{lstlisting}
\end{minipage}

If you compile and execute the problem you will see this result:

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=terminalStyle]
\$ ./main.exe
d1: 0.000000
d2: 0.333333
\end{lstlisting}
\end{minipage}

What would look like the same operation gave totally different results, and this
is because the \textbf{type} of the operands was different. In C, a literal
integer number value is an \texttt{int}, and the division operator when it
is operating on two integers, has an integer type. Nevertheless, when
\textbf{any of the two} operands is decimal, the operator performs the decimal
division, and its type is \texttt{double}.

Operators \verb!++! and \verb!--! are special, because they are unary operators.
An unary operator is an operator that is applied only to one operand. For
example, in math you have the operator square root, whose symbol is
$\sqrt{\phantom{2}}$ which, applied to just one number, gives us the number
(or numbers) that squared give us the operand. The operators increment and
decrement are unary and, also, can be writen infront or behind the operand.
These are special operantors that do not only give us a value, but also
\textbf{affect the value of the operand they act on}. Simply: if \verb!a! is
equal to three and we make \verb!a++!, \verb!a! will be four, but if we assign
the value of the operation to other variable, that other variable will have
a different value depending on if we write it in the postfix or prefix way,
let's see it in the code.


\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C, caption={Increment and decrement operators},
label={lst:prefixAndPostfixOperators}]
#include <stdio.h>
int main(void)
{
    int a = 3;
    int b = ++a;
    printf("a: %d; b: %d\n", a, b);
    a = 3;
    int c = a++;
    printf("a: %d; c: %d\n", a, c);
}
\end{lstlisting}
\end{minipage}

If you execute it, you'll see the following.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=terminalStyle]
\$ ./main.exe
a: 4; b: 4
a: 4; c: 3
\end{lstlisting}
\end{minipage}

I want you to understand precisely what is happening here: everytime we apply
the operand increment to a variable, that variable will increment
its value in one unit. Nevertheless; depending on if we write it as prefix
(infront the variable) or postfix (after it) the expression itself will have one
value or another. If we do it prefix, the value
of the expression of the operation
would be the value of \verb!a! \textbf{after} it increments its value, if we
do it as a postfix operator, the value will be \textbf{without the increment}.

Following the line of increment and decrement operators, there are also
operators that put together the assignment with other mathematical operations,
that is, substituting for example \lstinline[style=C]!a = a * 3;! by
\lstinline[style=C]!a *= 3;!. The same style of operators exists for
substraction, addition, division and module.

Finally, we simply must tell that the \textbf{priority} of the operations
is the same than in mathematics: the first expressions to be evaluated are those
inside parenthesis, after them division and multiplication, both have
the same priority, so in case you have several mixed, you will execute them
from left to right. After that, addition and substraction that are, again,
executed from left to right.

\subsubsection{Casting: explicit conversions}
It is usual that one needs to convert one type into another, for example, in the
case we saw before with the division, if you wanted a decimal division, you
would need to make one of them decimal to get the result you want. It is also
common than a variable that is an \texttt{int} gets assigned to a \texttt{char}
because you know its result is inside the range of values a \texttt{char} can
hold. Casting is a word that means the process of putting molten metals inside
a shaped container what will make the metal to retain that shape when it
solidifies. Nevertheless, it has its limits, laws of logic still apply, and you
cannot make a \texttt{char} to hold more than 127, for example, regardless of
casting.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C, caption={Casting example},
label={lst:castingExample}]
#include <stdio.h>
int main(void)
{
    int a = 3;
    int b = 2;
    double result = (double)a / b;
}
\end{lstlisting}
\end{minipage}

In line 6 we need one of the operands to be decimal (either \texttt{float} or
\texttt{double}). We perform cast to that type on the first operand. The syntax
is easy, but I am going to explain it in detail. You must write the name
of the type you want to convert the value to between parenthesis and next to it
the expression you want to cast. I'll leave you a couple examples:
\begin{enumerate}
\item \lstinline[style=C]!(int) (decimal_number / other_decimal)!: here we are
casting to an integer type the result of a division, as you can see, we need
to enclose the whole division in parenthesis so the casting is not applied only
to the first element.
\item \lstinline[style=C]!(char) (number % 128)!: Here you can see one of the
instances in which casting some integer type to a smaller one is ok. If
\texttt{number} is an integer, by casting it to \verb!char! there could be
problems but since we have performed module on 128, the result of the expression
is going to be between 0 and 127, therefore we know it is going to be in range
of the \texttt{char}.
\end{enumerate}
Following there is a table that will tell you which conversions are allowed and which
are not possible.

\begin{table}[H]
\begin{tabularx}{\linewidth}{|c|c|Y|Y|Y|Y|Y|}
\cline{3-7}
\multicolumn{2}{c|}{}&\multicolumn{5}{c|}{\textbf{Destiny type}}\\\cline{3-7}
\multicolumn{2}{c|}{}& \texttt{char}&\texttt{short}&\texttt{int}&\texttt{float}&\texttt{double} \\\cline{1-7}
\multirow{5}{*}[-5em]{\begin{sideways}\textbf{Source type}\end{sideways}}&\texttt{char} &OK&OK &OK &OK &OK \\\cline{2-7}
&\texttt{short} &Casting (overflow)&OK&OK&OK&OK \\\cline{2-7}
&\texttt{int} &Casting (overflow) &Casting (overflow)& OK&OK (precission) & OK (precission)\\\cline{2-7}
&\texttt{float} &Casting (rounding, overflow)& Casting (rounding, overflow)& Casting (rounding, overflow)& OK& OK \\\cline{2-7}
&\texttt{double} &Casting (rounding, overflow)& Casting (rounding, overflow)& Casting (rounding, overflow)& Casting (rounding, overflow)&OK \\\cline{1-7}
\end{tabularx}
\caption{Type conversions in C}
\label{tab:conversions}
\end{table}

Where I write ``ok'' I mean that there is an implicit conversion, but you must
be careful, the range of the integer is big and you may find that the precission
of a \texttt{float} is not good enough in the bigger values to have
problems distinguishing one unit from the next. I am going to be sincere with
you, this does not happen, the \texttt{float} is precise enough in the limits
of the integer to tell whole units apart, but I write it in the table to remind
you that you may look at the precission of the integers. Where I write casting
and I precise there can be an overflow I mean you're performing cast from
a bigger type to a smaller one, so that is not generally acceptable unless you
check yourself that the value of the casted expression fits into the new type.

\subsubsection{Final example of a program with operators}
At this point, we can make our first program that does ``something'', I am
going to give you an example that calculates the solution to a system of
linear equations, that is:

$$
\left\{\matrix{ax+by = c \cr
               dx+ey = f}
\right.
$$

With a system like that, we can apply substitution:
$$
(1)\; ax+by=c \to x= \frac{c-by}{a}
$$
$$
(2)\; dx+ey=f \to x=\frac{f-ey}{d}
$$
$$
(1) \;\mathrm{and} \; (2) \to \frac{c-by}{a} = \frac{f-ey}{d} \to
y=\frac{af-dc}{ae-db} \to x=\frac{f-e\cdot\frac{af-dc}{ae-db}}{d}
$$

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C, caption={Linear equation system solving},
label={lst:linealEquation}]
#include <stdio.h>
int main(void)
{
    int a = 1;
    int b = 3;
    int c = 8;
    int d = 2;
    int e = 7;
    int f = 12;

    double y = (a * f - d * c) / (a * e - d * b);
    double x = (f - e * y) / (d);

    printf("%dx+%dy=%d\n", a, b, c);
    printf("%dx+%dy=%d\n", d, e, f);
    printf("x = %f; y = %f\n", x, y);
}
\end{lstlisting}
\end{minipage}

If you copy this program, compile and execute it, you would see that I have
explained about variables and expressions. Nevertheless, the program has a
problem: it only solves one system of equations, to change the system, we need
to change the source code and recompile. This is not practical, and real
programs do not work in this way. For now most of our programs would be like
this one, because I want to explain more fundamental things first. Up until
now our programs have been very boring, they are limited to execute a series of
instructions one after the other. In real life, though, programs execute
one set of instructions or other depending on conditions, or they repeat
certain instructions several times, etc.

Other problem of this program is that we cannot change the behaviour of it
in certain conditions. If you change the value of the numbers in the
program in a way you make the system irresolvable the program will fail.
Test it, change the values of \texttt{a}, \texttt{b} and \texttt{c} to 1 and
\texttt{d}, \texttt{e} and \texttt{f} to 2. This system has infinite solutions
and will make the program to fail. If you compile and execute with the new
values, you should get something like the following:

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=terminalStyle]
\$ ./main.exe
1x+1y=1
2x+2y=2
x = -nan; y = -nan
\end{lstlisting}
\end{minipage}

What in tarnation is a nan? It is one of the special values that decimal numbers
in C can hold (remember IEEE 754). It means ``Not and Number''.
So, the result of that operation is not a number. How is that
possible? Because we have divided by zero. If you know a little about calculus
you'd know that a number divided by zero is an indetermination, that is, we do
not know what it is. That's how C deals with that. And we are lucky, if instead
of a decimal division it were an integer division, the program would simply
close abruptly. It would be interesting to check if the system has a solution,
and, if it had, then calculate it. This is done with control structures, which
will be explained in the next chapter.

\section{Changing the normal flow of the program}
As I introduced in the last section, it is convenient to be able to make the
program do one thing or the other according to a condition. Also, it is possible
(as a matter of fact it's essential) to repeat instructions according to
conditions. This is called altering the flow of the program, because instead
of execute one line after he next, the computer can jump to a place to another,
either forwards or backwards.

\subsection{Conditional sentences}
Conditional sentences are the ones that allow us to make the program flow
to \textbf{diverge}. You are going to understand it easily with the next
diagram.

\begin{figure}[H]
\centering
% generated by Plantuml 1.2022.7
\definecolor{plantucolor0000}{RGB}{34,34,34}
\definecolor{plantucolor0001}{RGB}{241,241,241}
\definecolor{plantucolor0002}{RGB}{24,24,24}
\definecolor{plantucolor0003}{RGB}{0,0,0}
\definecolor{plantucolor0004}{RGB}{17,17,17}
\begin{tikzpicture}[yscale=-1
,pstyle1/.style={color=plantucolor0002,fill=plantucolor0001,line width=0.5pt}
,pstyle4/.style={color=plantucolor0002,line width=1.0pt}
,pstyle5/.style={color=plantucolor0002,fill=plantucolor0002,line width=1.0pt}
]
\draw[color=plantucolor0000,fill=plantucolor0000,line width=1.0pt] (191.176pt,20pt) ellipse (10pt and 10pt);
\draw[pstyle1] (143.9784pt,50pt) -- (238.3736pt,50pt) -- (250.3736pt,62pt) -- (238.3736pt,74pt) -- (143.9784pt,74pt) -- (131.9784pt,62pt) -- (143.9784pt,50pt) -- cycle;
\node at (143.9784pt,55.0283pt)[below right,color=black]{(a * e - d * b) is 0};
\node at (113.0451pt,48.0566pt)[below right,color=black]{true};
\node at (250.3736pt,48.0566pt)[below right,color=black]{false};
\draw[pstyle1] (11pt,101.6055pt) arc (180:270:17.6055pt) -- (28.6055pt,84pt) -- (147.5078pt,84pt) arc (270:360:17.6055pt) -- (165.1133pt,101.6055pt) -- (165.1133pt,101.6055pt) arc (0:90:17.6055pt) -- (147.5078pt,119.2109pt) -- (28.6055pt,119.2109pt) arc (90:180:17.6055pt) -- (11pt,101.6055pt) -- cycle;
\node at (21pt,94pt)[below right,color=black]{Print: it has no solution};
\draw[pstyle1] (185.1133pt,101.6055pt) arc (180:270:17.6055pt) -- (202.7187pt,84pt) -- (385.8719pt,84pt) arc (270:360:17.6055pt) -- (403.4773pt,101.6055pt) -- (403.4773pt,101.6055pt) arc (0:90:17.6055pt) -- (385.8719pt,119.2109pt) -- (202.7187pt,119.2109pt) arc (90:180:17.6055pt) -- (185.1133pt,101.6055pt) -- cycle;
\node at (195.1133pt,94pt)[below right,color=black]{y = ( a * f - d * c ) / ( a * e - d * b )};
\draw[pstyle1] (225.1377pt,156.8164pt) arc (180:270:17.6055pt) -- (242.7432pt,139.2109pt) -- (345.8474pt,139.2109pt) arc (270:360:17.6055pt) -- (363.4529pt,156.8164pt) -- (363.4529pt,156.8164pt) arc (0:90:17.6055pt) -- (345.8474pt,174.4219pt) -- (242.7432pt,174.4219pt) arc (90:180:17.6055pt) -- (225.1377pt,156.8164pt) -- cycle;
\node at (235.1377pt,149.2109pt)[below right,color=black]{x = ( f - e * y ) / ( d )};
\draw[pstyle1] (191.176pt,180.4219pt) -- (203.176pt,192.4219pt) -- (191.176pt,204.4219pt) -- (179.176pt,192.4219pt) -- (191.176pt,180.4219pt) -- cycle;
\draw[color=plantucolor0000,line width=1.0pt] (191.176pt,235.4219pt) ellipse (11pt and 11pt);
\draw[color=plantucolor0004,fill=plantucolor0000,line width=1.0pt] (191.176pt,235.4219pt) ellipse (6pt and 6pt);
\draw[pstyle4] (294.2953pt,119.2109pt) -- (294.2953pt,139.2109pt);
\draw[pstyle5] (290.2953pt,129.2109pt) -- (294.2953pt,139.2109pt) -- (298.2953pt,129.2109pt) -- (294.2953pt,133.2109pt) -- cycle;
\draw[pstyle4] (131.9784pt,62pt) -- (88.0566pt,62pt);
\draw[pstyle4] (88.0566pt,62pt) -- (88.0566pt,84pt);
\draw[pstyle5] (84.0566pt,74pt) -- (88.0566pt,84pt) -- (92.0566pt,74pt) -- (88.0566pt,78pt) -- cycle;
\draw[pstyle4] (250.3736pt,62pt) -- (294.2953pt,62pt);
\draw[pstyle4] (294.2953pt,62pt) -- (294.2953pt,84pt);
\draw[pstyle5] (290.2953pt,74pt) -- (294.2953pt,84pt) -- (298.2953pt,74pt) -- (294.2953pt,78pt) -- cycle;
\draw[pstyle4] (88.0566pt,119.2109pt) -- (88.0566pt,192.4219pt);
\draw[pstyle4] (88.0566pt,192.4219pt) -- (179.176pt,192.4219pt);
\draw[pstyle5] (169.176pt,188.4219pt) -- (179.176pt,192.4219pt) -- (169.176pt,196.4219pt) -- (173.176pt,192.4219pt) -- cycle;
\draw[pstyle4] (294.2953pt,174.4219pt) -- (294.2953pt,192.4219pt);
\draw[pstyle4] (294.2953pt,192.4219pt) -- (203.176pt,192.4219pt);
\draw[pstyle5] (213.176pt,188.4219pt) -- (203.176pt,192.4219pt) -- (213.176pt,196.4219pt) -- (209.176pt,192.4219pt) -- cycle;
\draw[pstyle4] (191.176pt,30pt) -- (191.176pt,50pt);
\draw[pstyle5] (187.176pt,40pt) -- (191.176pt,50pt) -- (195.176pt,40pt) -- (191.176pt,44pt) -- cycle;
\draw[pstyle4] (191.176pt,204.4219pt) -- (191.176pt,224.4219pt);
\draw[pstyle5] (187.176pt,214.4219pt) -- (191.176pt,224.4219pt) -- (195.176pt,214.4219pt) -- (191.176pt,218.4219pt) -- cycle;
\end{tikzpicture}

\caption{Flow diagram: solving an equation system with a conditional}
\label{img:fluxIgEq}
\end{figure}

What you're seeing is called a flow diagram, despise the fancy name, it is very
easy to read. You start in the black dot in the top of the diagram,
and you follow the arrow, a diamond means a \textbf{decision}, according to what
is inside the decision (a condition), one branch or the other will be taken.
If you read the text of the condition inside the diamond, I have writen there
what makes our system \textbf{irresolvable}. If you read the text next to the
arrows that come out from the diamond, you will see that if $ae-db=0$, we will
print that the system is not solvable and exit normally. If it is not zero,
we will continue doing what we were doing before.

\subsubsection{Logic operations}

This drawing is nice, but let's see how we do that in C. Now I have to present
to you another set of operators, called boolean operators or logic operators.
In the section \ref{section:queEsLaProgramacion} I mentioned logic as a science.
Concretely we are going to apply propositional logic, or first order logic.
In this logic we have \textbf{facts} that can be only \textbf{true} or
\textbf{false}, and they relate with each other with three operators. Let's see
and example, and then we will hop to the theory.

Imagine a fire extinguishing system that works in this manner: ``If the
temperature is greater than 50\centigrade, the fire sprinklers will start
working, if the temperature is lower, but there is smoke detected, the sprinklers
will start working anyway''. Since this is a science, let's write it in a formal
manner. Each sentence that is conceptually different is a \textbf{proposition},
and they're generally named by letters of the alphabet from p onwards. Let's
see which propositions we have:

\begin{enumerate}
    \item Temperature is greater than 50\centigrade, let's call it $p$.
    \item Smoke is detected, let's call it $q$.
    \item The sprinklers go off, let's call it $r$.
\end{enumerate}


\begin{table}[H]
\begin{tabularx}{\linewidth}{|c|c|Y|}
\hline
$T>50\;{}^{\circ}\mathrm{C}(\mathbf{p})$&Smoke$(\mathbf{q})$&Sprinklers go off$(\mathbf{r})$\\\hline
True  & True  & True  \\\hline
True  & False & True  \\\hline
False & True  & True  \\\hline
False & False & False \\\hline
\end{tabularx}
\caption{Example of logic operations}
\label{tab:logicOperationExample}%
\end{table}

In logic, there are thee basic operators:
\begin{enumerate}
\item Conjunction, commonly known as ``and''. It is writen with the symbol $\land$.
\item Disjunction, common knows as ``or''. It is writen with the symbol $\lor$.
\item Negation, commonly knows as ``not''. It is writen with several symbols,
for example $\sim$ and $\lnot$, but it is writen also putting a bar over the
negated expression, for example $\overline{p}$.
\end{enumerate}

\begin{table}[H]
    \centering
    \begin{subfigure}{0.33333\linewidth}
        \centering
        \begin{tabular}{|c|c|c|}
        \hline
        $\mathbf{p}$&$\mathbf{q}$&$\mathbf{p\land q}$\\\hline
        False & False  & False \\\hline
        False & True & False \\\hline
        True& False  & False \\\hline
        True& True & True\\\hline
        \end{tabular}
    \end{subfigure}%
    \begin{subfigure}{0.33333\linewidth}
        \centering
        \begin{tabular}{|c|c|c|}
        \hline
        $\mathbf{p}$&$\mathbf{q}$&$\mathbf{p \lor q}$\\\hline
        False & False  & False \\\hline
        False & True & True\\\hline
        True& False  & True\\\hline
        True& True & True\\\hline
        \end{tabular}
    \end{subfigure}%
    \begin{subfigure}{0.33333\linewidth}
        \centering
        \begin{tabular}{|c|c|}
        \hline
        $\mathbf{p}$&$\mathbf{\sim\!p}, \mathbf{\lnot p}, \mathbf{\overline{p}}$\\\hline
        True & False  \\\hline
        False & True \\\hline
        \multicolumn{2}{c}{\color{white}CIERTOFALSO\normalcolor}\\\arrayrulecolor{white}\hline
        \multicolumn{2}{c}{\color{white}CIERTOFALSO\normalcolor}\\\arrayrulecolor{white}\hline
        \end{tabular}
    \end{subfigure}
\caption{Tables of truth of the basic logic operations}
\label{tab:andTruthTable}
\end{table}

The conceptual meaning of the operations are intuitive, but I will explain it
here to tell some details. The conjunctios is true only when \textbf{both}
of the operand are true, and is like joining two propositions with ``and'' in
English. ``It is raining and it's cold'' is true only if at the same time it's
raining and it's cold. On the other hand, disjunction is when you join two
propositions with ``or''. ``I have twisted my anckle or I have broken it'', but
there is a caveat here, if you look at the truth table you will se that when
\textbf{both members}  are true, the disjunction is true also. It is something
that is not aligned with the spoken language, and you need to keep it in mind.
Finally, negation is when you put ``not'' before the expression or preposition,
``it is not raining'' is true only if ``it is raining'' is false.

And, after this logical detour that would make Aristotle proud, what?
We're almost there, in C the logic operators are writen in this way:
\begin{enumerate}
    \item Conjunction is writen: \verb!&&!.
    \item Disjunction is writen: \verb!||!. (This symbols is called a pipe
    symbol, in the American keyboard you ir get pushing the key over the enter
    and shift.)
    \item Negation is written: \verb"!".
\end{enumerate}

If we go back to the example of the fire sprinklers, let's make a program that
``simulates'' the system, I will write it now.
Up until now I have talked about true and false values, in C that is represented
with an integer type (any of those available). Zero is the false value, and
\textbf{all the other values} are true. Generally the result of a logic
operation will be one if it's true, but you cannot assume that when using
an integer type to store logic values.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={First program with logic operations},
label={lst:firstLogicProgram}]
#include <stdio.h>
int main(void)
{
    int temperature:greater_than_50 = 1;
    int smoke = 0;
    int aspersores = temperatura_mayor_50 || smoke;
}
\end{lstlisting}
\end{minipage}

Yes, it looks like the boring programs we were doing up until now, do not worry,
the matter is: if you go back to \ref{tab:logicOperationExample}:
\nameref{tab:logicOperationExample} you're going to see that the program is just
a disjunction, if there is smoke, or the temperature is high, or both, the
sprinklers will go off. Nevertheless, this program is still a bit useless. We
cannot check is the temperature is greater or lower than 50 \centigrade, we have
had to make it up. This leads me to present another set of operators to you,
the comparison operators. This is easy, in C we can check is one variable
(or expression) is equals, greater or less than another. I will write the
table and let's improve the program we had before.
\begin{table}[H]
\centering
\begin{tabularx}{\linewidth}{|c|Y|}
\hline
\bf Operator & \bf Description \\ \hline
\tt < &   True is the left operand is less than the right one, false otherwise.\\\hline
\tt > &   True is the left operand is greater than the right one, false otherwise.\\\hline
\tt <= &  True is the left operand is less than or equal to the right one, false otherwise. \\\hline
\tt >= &  True is the left operand is greater than or equal to the right one, false otherwise. \\\hline
\tt == &  True is both operands are equal, false otherwise. \\\hline
\tt != &   True is both operands are different, false otherwise. \\\hline
\end{tabularx}
\caption{Comparison operators}
\label{tab:logicOperators}
\end{table}

Now you know comparison operators, let's make a program that checks is a given
value is in the interval $\left(a, b\right]$, that is, between $a$ and $b$,
including $b$, without including $a$.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Primer programa con operaciones de comparación},
label={lst:firstComparingProgram}]
#include <stdio.h>
int main(void)
{
    int number = 5;
    int a = 0;
    int b = 10;

    int is_in_interval = number > a && number <= b;

    printf("%d is in (%d, %d] is equal to: %d\n",
               number, a, b, is_in_interval);
}
\end{lstlisting}
\end{minipage}

As you can see, there is no need for parenthesis, comparations are executed
before logic operations. I'll take advantage of the fact that I have already
presented three set of operands (mathematical, logical and comparison) to tell
you that there is nothing wrong with declaring variables along the program
to hold partial values of what you want to calculate, specially if a given
expression becomes too big. I would even advise you to do that when you feel
like it and then remove the intermediate variables as an exercise, at least in
your first programs.

\subsubsection{Diverging the flow: the \texttt{if}}
Now we know how to create logic conditions (propositions) that can be either
true or false, we can create our first conditional sentence. In C, a conditional
sentence is made with the key word \lstinline[style=C]!if!. I will present to
you now the basic structure of an \texttt{if}, but this is \textbf{not} a
valid C program.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Basic structure of \texttt{if} sentence},
label={lst:ifStructure}]
if(/*condition*/)
{
    //Executes only if condition is true.
}
else
{
    //Executes only if condition is false.
}
\end{lstlisting}
\end{minipage}

Now we can improve our first program that simulates the sprinkler system!
Let's add the comparison and logical operators.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Fire sprinkler program with logic and comparison operators},
label={lst:sprinklerLogicComp}]
#include <stdio.h>
int main(void)
{
    int temperature = 25;
    int smoke = 0;

    if (temperature > 50 || smoke)
    {
        printf("Sprinklers activated.\n");
    }
    else
    {
        printf("Sprinklers deactivated.\n");
    }
}
\end{lstlisting}
\end{minipage}

As we have been suffering before, each time you change any value you will have
to recompile and execute. Change the values of the variable \texttt{smoke} and
\texttt{temperature} to make the result of the conditional change. Finally,
we can improve our program of resolution of linear equations, before performing
any of the calculations we will check if the system has a solution. To do that,
we need to check that the divider is not zero. To do that we simply declare more
variables and then divide by them.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Linear equation resolution program with conditional},
label={lst:linealSystemConditional}]
#include <stdio.h>
int main(void)
{
    int a = 1;
    int b = 1;
    int c = 1;
    int d = 2;
    int e = 2;
    int f = 2;

    double divider = (a * e - d * b);

    if (divider == 0 || d == 0)
    {
        printf("The system is irresolvable.\n");
    }
    else
    {
        double y = (a * f - d * c) / divider;
        double x = (f - e * y) / (d);
        printf(" %dx+ %dy= %d\n", a, b, c);
        printf(" %dx+ %dy= %d\n", d, e, f);
        printf("x = %f; y = %f\n", x, y);
    }
}
\end{lstlisting}
\end{minipage}

This is more alike to a ``real'' program, we could say that we are already
hands down on the matter. But the conditional has more things to it. You can
chain them. Sometimes we want to check a chain of conditions one after the
other and execute the instructions related to the first true condition. Imagine
a program that receives the temperature and, depending on what it is, throws a
message about the weather.
\begin{enumerate}
\item If it's 40\centigrade{} or more, print ``It's hot.''
\item If it's 35\centigrade{} or more, print ``It's warm.''
\item If it's 25\centigrade{} or more, print ``It's a nice day.''
\item If it's 10\centigrade{} or more, print ``It's a little bit chilly here.''
\item If it's less than 10\centigrade{}, print ``It's very cold.''
\end{enumerate}

I have writen the sentences in that way purposely so you realize that, even when
forty degrees is more than ten, we don't want to print that it's hot, it's a
nice day and it's a little bit chilly here, only the condition that arrives
first. To do so C gives us the \texttt{if-else} sentence, in which we ``chain''
an \texttt{if} statement to the \texttt{else} of the other conditional. In
that way, only if the condition before was false, the next one will be checked
and, if it is true, the instructions inside that \texttt{if-else} will be
executed, let's see it with an example.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Example program for \texttt{if-else}},
label={lst:ifelse}]
#include <stdio.h>
int main(void)
{
    int temp = 10;
    if (temp >= 40) {
        printf("It's hot.\n");
    }
    else if (temp >= 35) {
        printf("It's warm.\n");
    }
    else if (temp >= 25) {
        printf("It's a nice day.\n");
    }
    else if (temp >= 10) {
        printf("It's a little bit chilly here.\n");
    }
    else {
        printf("It's very cold.\n");
    }
}
\end{lstlisting}
\end{minipage}

As you can see, we have finished the chain of \texttt{if-else} with an
\texttt{else}, this means that in case no condition is true in the chain,
the instructions inside the else will be executed. In this case, print
``It's very cold''.

Now we have seen conditionals, we can revisit our program that solves linear
equation systems. If you remember, in the last revision
(\nameref{lst:linealSystemConditional}) we deemed the problem as insolvable if
$d=0$. Nevertheless, if you remember a little of algebra from high school and
you come back to the equation, you will see that $d$ being equal to zero does
not mean the problem has no solution, but that we should solve for $y$ in both
equations and not $x$. That is:

\begin{figure}[H]
$$
(1)\; ax+by=c \to y = \frac{c-ax}{b}
$$
$$
(2)\; dx+ey=f \to y = \frac{f-dx}{e}
$$
$$
(1) \;\mathrm{and} \; (2) \to \frac{c-ax}{b}=\frac{f-dx}{e}\to
ec - eax = bf-bdx \to x = \frac{bf-ec}{bd-ea}\to y=\frac{c-a\cdot{}\frac{bf-ec}{bd-ea}}{b}
$$
\end{figure}

In case this is not possible, it means that nor $x$ or $y$ are in both
equations, that is, we have one equation that solves for $x$ and other for $y$.
Either we have$\left\{\matrix{ax=c\cr ey=f}\right.$ or we have
$\left\{\matrix{by=c\cr dx=f}\right.$. Simply checking if $a=0$ we will know in
which case we are. Finally, we could be in the case that we had just one
equation, if the terms that multiply $x$ or $y$ in any of them were zero, but
in this case this is not a system and it is not possible to give values to
$x$ and $y$. If we write the code, let's see how it would look.

\newpage
\begin{lstlisting}[style=C,
caption={Program solving a linear equations system with conditionals},
label={lst:linealSystemFinal}]
#include <stdio.h>
int main(void)
{
    int a = 12, b = 2, c = 10, d = 50, e = 11, f = 17;
    int irresolvable = 0;
    double divider, x, y;
    if (a != 0 && d != 0) {
        divider = (a * e - d * b);
        if (divider == 0)
        {
            printf("The system is irresolvable.\n");
            irresolvable = 1;
        }
        else
        {
            y = (a * f - d * c) / divider;
            x = (f - e * y) / (d);
        }
    }
    else if (b != 0 && e != 0) {
        divider = (b * d - e * a);
        if (divider == 0) {
            printf("The system is irresolvable.\n");
            irresolvable = 1;
        }
        else {
            x = (b * f - e * c) / divider;
            y = (c - a * x) / b;
        }
    }
    else if (a == 0 && b == 0 || d == 0 && e == 0) {
        printf("This is not a system.\n");
        irresolvable = 1;
    }
    else {
        if (a != 0) {
            x = (double)c / a;
            y = (double)f / e;
        }
        else {
            x = (double)f / d;
            y = (double)c / b;
        }
    }
    if (!irresolvable) {
        printf(" %dx+ %dy= %d\n", a, b, c);
        printf(" %dx+ %dy= %d\n", d, e, f);
        printf("x = %f; y = %f\n", x, y);
    }
}
\end{lstlisting}

This program is a little long, but I am going to go conditional by conditional.
First of all, let's circle back and rethink which possibilities we have
according to the system. We can be in one of these four cases:
\begin{itemize}
\item $x$ is present in both equations, therefore, we can solve for it in both
equations as we did the first time we solved the problem. In this case, if
the divider we calculated is zero, the problem is not solvable.
\item $y$ is present in both equations, we can solve for it as we did just
before showing this version of the program.
\item In one of the equations, both $x$ and $y$ are multiplied by zero,
therefore this is not a system, and we cannot solve it.
\item We can be in the case we can't solve both equations for one unknown,
because one of them is present in the first equation, and the other in the
second one.
\end{itemize}

In the first lines of the problem I am declaring a bunch of variables, I am
sorry because I didn't teach you to do it in this abbreviated way, but I wanted
the program to fit in one page. We will explain it later. I just declare
the same values as before, and a logic variable called irresolvable, that will
allow me to know if I have solved the problem at the end of it to
print the solutions.
The cases listed before are  present in my program, in the first \texttt{if}
we check if the coefficients that multiply $x$ in both equations are different
from zero. In this case, we try the first solving method: calculate the value
of the divider and applying it. Inside this condition, if the divider is zero,
the system is not solvable, else, we simply solve the system with it.
As you can see, you can put conditionals inside conditionals.

In the next \texttt{if-else} we are checking if the can solve for $y$ in both
equations. This case is basically the same than the other, but applying the
other set of formulas. We calculate the divider of the value of $x$ in this
case, if it is zero, we cannot solve it.
The next conditional checks if in any of the equations the coefficients of
both unknowns are zero. In this case, as we said, this is not a system and we
cannot solve it.
Finally, if we are not in any of the aforementioned cases, that means we're in
the last one: $x$ is in one equation and $y$ in the other. We check if $a$ is
zero, if it is not, we know the first equation gives us the value of $x$ and
the second the value of $y$.

At the end, we simply check the variable irresolvable, that tells us if we have
marked the program as so. If we haven't it means we have solutions, so we just
print them.

\subsection{Code blocks and scopes}
Now you know the first control structure, I must talk to you about \textbf{code
blocks}, a code block is the piece of code that is between two braces (\{...\}).
The main implication of enclosing code between braces in a block is that the
variables declared inside it are not visible outside, but those declared outside
are visible inside the block.
If you remember the basic structure of the conditional, you will see it includes
braces, also, in the first program that I presented to you I told you you will
always have to write a series of lines, those include a single code block.
Inside that block we have put all the instructions in all our programs. Now
we have conditionals, we have nested blocks (blocks inside blocks).

All variable declared in C has a \textbf{scope}, that is the portion of the code
in which the variable can be seen, the scope of a variable is the block in which
it's been declared and all those blocks inside that one.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Example of scope of declared variables},
label={lst:scopeVar}]
#include <stdio.h>
int main(void)
{
    int exterior = 0;
    if (exterior == 0) {
        double inner = 1.3;
        exterior = 120; // OK: variable from an outter block
    }
    inner = 10.3; // Error: variable not defined
}
\end{lstlisting}
\end{minipage}

If you try to compile the code I just shown, you will se the compiler says the
variable \texttt{inner} is not declared, even when you declared it ``before''.
Another of the side effects of blocks is that you can define variables that
already existed in outter blocks. Let's see an example.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Example of redefinition of variable},
label={lst:varRedefinition}]
#include <stdio.h>
int main(void)
{
    int number = 0;
    int exterior = 3;
    if (number == 0) {
        int exterior = 10;
        printf("%d\n", exterior);
    }
    printf("%d\n", exterior);
}
\end{lstlisting}
\end{minipage}

If you compile an execute this program, you'll see it prints firstly 10 and
later 3. This is because there are two variables with the same name. How is this
possible? How does C to which variable are you referencing? Simply those
variables that are local (those declared in the block you're in) have priority
over those declared in more external blocks. This means you cannot access
external variables if you have declared any with the same name in an inner
block.

Now that you know that the scope is, let's explain some things of those I
couldn't explain before. Firstly I want to tell you that outside the braces of
our first program we can write things. Concretely, we can declare variables,
which are called \textbf{global variables}. They are called like that because
they have a ``global'' scope. That is: any other instruction in your program
has access to them (unless they declared a variable with the same name). I am
not going to take much time in them, at the moment, they're not useful to us,
but I am going to show you an example of how a program with them would look.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Example of a program with a global variable},
label={lst:globalVar}]
#include <stdio.h>

int globalVariable = 20;

int main(void)
{
    printf("%d\n", globalVariable);
}
\end{lstlisting}
\end{minipage}

The rule is that variables must be declared at the start of the block. This is
not mandatory, but it is a good practice. I leave it to your election but I
would encourage it.
Also, you must declare them in the most inner block in which you can, for
example in the program \ref{lst:linealSystemConditional} we have declared
the variables \texttt{x} and \texttt{y} in the only block we needed them, we
could have declared them at the start of the program, or as global variables,
but, since it was not necessary, we didn't do it.

\subsection{Other jump onstructions: \texttt{switch} and \texttt{goto}}
You know the most important way to make the flow of the program diverge, but
there are other two that still have some utility, I have already named them in
the title: \texttt{switch} and \texttt{goto}. The first one behaves like a
distributor of the flow of the program, given a variable it examines the value
and compares it with a series of cases, according to the case, it jumps to that
line. We could imagine the \texttt{switch} like a factory worker that classifies
products that go out an assembly line, according to the state of the product it
does a thing or another.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Example of a program with a \texttt{switch}},
label={lst:switchExample}]
#include <stdio.h>

int main(void)
{
    int day = 3;

    switch (day) {
        case 0:
        printf("Todays is: Monday\n");
        break;
        case 1:
        printf("Todays is: Tuesday\n");
        break;
        case 2:
        printf("Todays is: Wednesday\n");
        break;
        case 3:
        printf("Todays is: Thursday\n");
        break;
        case 4:
        printf("Todays is: Friday\n");
        break;
        case 5:
        printf("Todays is: Saturday\n");
        break;
        case 6:
        printf("Todays is: Sunday\n");
        break;
        default:
        printf("That number is not any day!\n");
        break;
    }
}
\end{lstlisting}
\end{minipage}

If you look the example program, a \texttt{switch} starts in a similar way to
a \verb!if!, but inside the parenthesis there is not a condition, but always a
variable. That variable must be an integer type. After that, in the body
of the \texttt{switch} there is a set of lines that start with \verb!case!,
after that word you must write a literal value (it cannot be a variable) and
then the lines you want to execute in case the the variable in the switch has
the value of this case. That set of instructions can end or not with an special
instruction called \lstinline[style=C]!break;!. This instruction makes the
flow of the program to exit the switch. We need this because if we didn't put
it, the instructions in the following cases would execute also. If you execute
the program as it is writen, it will print only the message of the Thursday, but
if you remove the breaks and recompile, it will print all days from Thursday on.

You would see there is a line that is not a \texttt{case}, but has been created
with the instruction \texttt{default}. This is because this keyword allows us
to tell what would happen if the value does not match any other case. In this
example we will print the number is not assigned to any day. You may have
noticed, or not, that a \texttt{switch} with \texttt{break} in all the cases
is basically a chain of \texttt{if-else}. This is true, a \texttt{switch} can be
always replaced with a chain of \texttt{if-else} (if it has break in every
line). In this case, the code associated with the default would be the code
in the \texttt{else} at the end of the chain.

The \texttt{switch} is an example of jumping to a label. A label is something
special because it stablishes a point in the to which you can jump with or
without a condition. The other instruction to jump to a label is \texttt{goto},
let's see a simple example and, later, I will explain its most common use case.
The code example for that case will be introduced in a later section, because
it will be difficult to understand without advancing more in the contents of
the language.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Example of a program with \texttt{goto}},
label={lst:gotoExample}]
#include <stdio.h>

int main(void)
{
    printf("Hello, this is the start of the program.\n");

    goto final;

    printf("I am a line that should not be printed.\n");

    final:
    printf("We have ended the program.\n");

}
\end{lstlisting}
\end{minipage}
If you compile the program and execute it, you would see that it prints the
first and last line, but not the second. This is so because we have used the
\texttt{goto} instruction to jump to a later point in the program. The use
of \texttt{goto} is very dangerous, in the sense that it shows you haven't
thought properly your program or you lack tools to make it in a better way.
Therefore, until we haven't gone through other sections of this manual, I
would discourage its ussage. I advise you to save gotos as a novelty more
than a common-use tool.

\subsection{Repeat instructions: loops}
At the start of this section I expalined to you that making the computer to
repeat instructions is necessary to make programs work, and here we're going
to learn how: with \textbf{loops}. There two main kinds of loops:
\lstinline[style=C]!while! and \lstinline[style=C]!for!.
In the same fashion we did with the conditional, we will see firstly the flow
diagram of the structure, later how it is writen in C and finally an example on
how to use the loops in some programs.

\subsubsection{The \texttt{while} loop}
This is the most basic kind of loop, and that's why we're going to explain it
firstly, it sets a series of instructions that will be executed as long
(while) a condition is true. Imagine you wanted to print all numbers from
one to 100. You could write 100 lines that print every number or you could
tell the computer to print a variable, add one to it, and then print it again
while it is less than 100.

\begin{figure}[H]
\centering
% generated by Plantuml 1.2022.7
\definecolor{plantucolor0000}{RGB}{34,34,34}
\definecolor{plantucolor0001}{RGB}{241,241,241}
\definecolor{plantucolor0002}{RGB}{24,24,24}
\definecolor{plantucolor0003}{RGB}{0,0,0}
\definecolor{plantucolor0004}{RGB}{17,17,17}
\begin{tikzpicture}[yscale=-1
,pstyle1/.style={color=plantucolor0002,fill=plantucolor0001,line width=0.5pt}
,pstyle4/.style={color=plantucolor0002,line width=1.0pt}
,pstyle5/.style={color=plantucolor0002,fill=plantucolor0002,line width=1.0pt}
]
\draw[color=plantucolor0000,fill=plantucolor0000,line width=1.0pt] (99.7556pt,20pt) ellipse (10pt and 10pt);
\draw[pstyle1] (56.6556pt,67.6055pt) arc (180:270:17.6055pt) -- (74.261pt,50pt) -- (125.2501pt,50pt) arc (270:360:17.6055pt) -- (142.8556pt,67.6055pt) -- (142.8556pt,67.6055pt) arc (0:90:17.6055pt) -- (125.2501pt,85.2109pt) -- (74.261pt,85.2109pt) arc (90:180:17.6055pt) -- (56.6556pt,67.6055pt) -- cycle;
\node at (66.6556pt,60pt)[below right,color=black]{variable = 0};
\draw[pstyle1] (60.0967pt,184.7598pt) arc (180:270:17.6055pt) -- (77.7022pt,167.1543pt) -- (121.8089pt,167.1543pt) arc (270:360:17.6055pt) -- (139.4144pt,184.7598pt) -- (139.4144pt,184.7598pt) arc (0:90:17.6055pt) -- (121.8089pt,202.3652pt) -- (77.7022pt,202.3652pt) arc (90:180:17.6055pt) -- (60.0967pt,184.7598pt) -- cycle;
\node at (70.0967pt,177.1543pt)[below right,color=black]{variable++};
\draw[pstyle1] (47pt,248.499pt) arc (180:270:17.6055pt) -- (64.6055pt,230.8936pt) -- (134.9056pt,230.8936pt) arc (270:360:17.6055pt) -- (152.5111pt,248.499pt) -- (152.5111pt,248.499pt) arc (0:90:17.6055pt) -- (134.9056pt,266.1045pt) -- (64.6055pt,266.1045pt) arc (90:180:17.6055pt) -- (47pt,248.499pt) -- cycle;
\node at (57pt,240.8936pt)[below right,color=black]{print (variable)};
\draw[pstyle1] (62.5798pt,105.2109pt) -- (136.9313pt,105.2109pt) -- (148.9313pt,117.2109pt) -- (136.9313pt,129.2109pt) -- (62.5798pt,129.2109pt) -- (50.5798pt,117.2109pt) -- (62.5798pt,105.2109pt) -- cycle;
\node at (103.7556pt,129.2109pt)[below right,color=black]{true};
\node at (62.5798pt,110.2393pt)[below right,color=black]{variable \textless  100};
\node at (29.1893pt,103.2676pt)[below right,color=black]{false};
\draw[color=plantucolor0000,line width=1.0pt] (24pt,164.2109pt) ellipse (11pt and 11pt);
\draw[color=plantucolor0004,fill=plantucolor0000,line width=1.0pt] (24pt,164.2109pt) ellipse (6pt and 6pt);
\draw[pstyle4] (99.7556pt,30pt) -- (99.7556pt,50pt);
\draw[pstyle5] (95.7556pt,40pt) -- (99.7556pt,50pt) -- (103.7556pt,40pt) -- (99.7556pt,44pt) -- cycle;
\draw[pstyle4] (99.7556pt,202.3652pt) -- (99.7556pt,230.8936pt);
\draw[pstyle5] (95.7556pt,220.8936pt) -- (99.7556pt,230.8936pt) -- (103.7556pt,220.8936pt) -- (99.7556pt,224.8936pt) -- cycle;
\draw[pstyle4] (99.7556pt,129.2109pt) -- (99.7556pt,167.1543pt);
\draw[pstyle5] (95.7556pt,157.1543pt) -- (99.7556pt,167.1543pt) -- (103.7556pt,157.1543pt) -- (99.7556pt,161.1543pt) -- cycle;
\draw[pstyle4] (99.7556pt,266.1045pt) -- (99.7556pt,276.1045pt);
\draw[pstyle4] (99.7556pt,276.1045pt) -- (164.5111pt,276.1045pt);
\draw[pstyle5] (160.5111pt,210.8936pt) -- (164.5111pt,200.8936pt) -- (168.5111pt,210.8936pt) -- (164.5111pt,206.8936pt) -- cycle;
\draw[pstyle4] (164.5111pt,117.2109pt) -- (164.5111pt,276.1045pt);
\draw[pstyle4] (164.5111pt,117.2109pt) -- (148.9313pt,117.2109pt);
\draw[pstyle5] (158.9313pt,113.2109pt) -- (148.9313pt,117.2109pt) -- (158.9313pt,121.2109pt) -- (154.9313pt,117.2109pt) -- cycle;
\draw[pstyle4] (50.5798pt,117.2109pt) -- (24pt,117.2109pt);
\draw[pstyle4] (24pt,117.2109pt) -- (24pt,153.2109pt);
\draw[pstyle5] (20pt,143.2109pt) -- (24pt,153.2109pt) -- (28pt,143.2109pt) -- (24pt,147.2109pt) -- cycle;
\draw[pstyle4] (99.7556pt,85.2109pt) -- (99.7556pt,105.2109pt);
\draw[pstyle5] (95.7556pt,95.2109pt) -- (99.7556pt,105.2109pt) -- (103.7556pt,95.2109pt) -- (99.7556pt,99.2109pt) -- cycle;
\end{tikzpicture}
\caption{Flow diagram: program that prints the numbers from 1 to 100}
\label{img:whileFlux}
\end{figure}

As always, I leave you the code that would produce this result.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Example with a \texttt{while} loop},
label={lst:whilePrint}]
#include <stdio.h>
int main(void)
{
    int variable = 0;

    while (variable < 100) {
        variable++;
        printf("%d\n", variable);
    }
}
\end{lstlisting}
\end{minipage}

The \texttt{while} loop is the simplest of them, as you can see. The
instructions that are in the loop are executed only in the condition is true.
This has two implications: is the condition is \textbf{not} true when you arrive
to the \texttt{while} instruction, the loop will never be executed, not even
once. The other is that if there is nothing that changes the value of the
condition of the loop inside it, the loop will execute forever. For example in
this loop we change the value of variable so it reaches 100 and the loop ends.

There is a special kind of loop \texttt{while} that will execute the
instructions always \texttt{at least once}, because the first execution will be
done before evaluating the condition. Let's see an example.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Ejemplo de programa con un bucle \texttt{do-while}},
label={lst:doWhile}]
#include <stdio.h>
int main(void)
{
    int variable;

    do{
        variable = rand();
        printf("Variable aleatoria = %d\n", variable);
    }while(variable != 10);
}
\end{lstlisting}
\end{minipage}

This program generates a random number (you must believe it until I explain more
concepts) and prints it, then, if the number is not 10, prints it again and
changes the variable value to another random value. Why would we need to use
\texttt{do-while}? because with it we don't need to initialize the variable
outside the loop, and all the ocurrences of the use a \texttt{rand} will be
inside. This loop is much less used than \texttt{while} and shares with the
switch that is it something that doesn't get used much, but when it does,
it makes things much easier.

\subsubsection{The \texttt{for} loop}

The \texttt{for} loop is a loop that works like the while loop, but that does
two things more: it executes an instruction \textbf{before executing anything
inside the loop} and other \textbf{at the end of each repetition}. Let's see
the flow diagram and how it's writen.
\begin{figure}[H]
\centering
% generated by Plantuml 1.2022.7
\definecolor{plantucolor0000}{RGB}{34,34,34}
\definecolor{plantucolor0001}{RGB}{241,241,241}
\definecolor{plantucolor0002}{RGB}{24,24,24}
\definecolor{plantucolor0003}{RGB}{0,0,0}
\definecolor{plantucolor0004}{RGB}{17,17,17}
\begin{tikzpicture}[yscale=-1
,pstyle1/.style={color=plantucolor0002,fill=plantucolor0001,line width=0.5pt}
,pstyle4/.style={color=plantucolor0002,line width=1.0pt}
,pstyle5/.style={color=plantucolor0002,fill=plantucolor0002,line width=1.0pt}
]
\draw[color=plantucolor0000,fill=plantucolor0000,line width=1.0pt] (133.4242pt,20pt) ellipse (10pt and 10pt);
\draw[pstyle1] (92.379pt,67.6055pt) arc (180:270:17.6055pt) -- (109.9844pt,50pt) -- (156.8641pt,50pt) arc (270:360:17.6055pt) -- (174.4695pt,67.6055pt) -- (174.4695pt,67.6055pt) arc (0:90:17.6055pt) -- (156.8641pt,85.2109pt) -- (109.9844pt,85.2109pt) arc (90:180:17.6055pt) -- (92.379pt,67.6055pt) -- cycle;
\node at (102.379pt,60pt)[below right,color=black]{assignment};
\draw[pstyle1] (90.2769pt,166.8164pt) arc (180:270:17.6055pt) -- (107.8823pt,149.2109pt) -- (158.9661pt,149.2109pt) arc (270:360:17.6055pt) -- (176.5716pt,166.8164pt) -- (176.5716pt,166.8164pt) arc (0:90:17.6055pt) -- (158.9661pt,184.4219pt) -- (107.8823pt,184.4219pt) arc (90:180:17.6055pt) -- (90.2769pt,166.8164pt) -- cycle;
\node at (100.2769pt,159.2109pt)[below right,color=black]{instructions};
\draw[pstyle1] (69.066pt,237.0273pt) arc (180:270:17.6055pt) -- (86.6715pt,219.4219pt) -- (180.177pt,219.4219pt) arc (270:360:17.6055pt) -- (197.7825pt,237.0273pt) -- (197.7825pt,237.0273pt) arc (0:90:17.6055pt) -- (180.177pt,254.6328pt) -- (86.6715pt,254.6328pt) arc (90:180:17.6055pt) -- (69.066pt,237.0273pt) -- cycle;
\node at (79.066pt,229.4219pt)[below right,color=black]{end of the iteration};
\draw[pstyle1] (108.9333pt,105.2109pt) -- (157.9152pt,105.2109pt) -- (169.9152pt,117.2109pt) -- (157.9152pt,129.2109pt) -- (108.9333pt,129.2109pt) -- (96.9333pt,117.2109pt) -- (108.9333pt,105.2109pt) -- cycle;
\node at (108.9333pt,110.2393pt)[below right,color=black]{condition};
\node at (10pt,103.2676pt)[below right,color=black]{condition is false};
\draw[color=plantucolor0000,line width=1.0pt] (46.066pt,160.2109pt) ellipse (11pt and 11pt);
\draw[color=plantucolor0004,fill=plantucolor0000,line width=1.0pt] (46.066pt,160.2109pt) ellipse (6pt and 6pt);
\draw[pstyle4] (133.4242pt,30pt) -- (133.4242pt,50pt);
\draw[pstyle5] (129.4242pt,40pt) -- (133.4242pt,50pt) -- (137.4242pt,40pt) -- (133.4242pt,44pt) -- cycle;
\draw[pstyle4] (133.4242pt,184.4219pt) -- (133.4242pt,219.4219pt);
\draw[pstyle5] (129.4242pt,209.4219pt) -- (133.4242pt,219.4219pt) -- (137.4242pt,209.4219pt) -- (133.4242pt,213.4219pt) -- cycle;
\draw[pstyle4] (133.4242pt,129.2109pt) -- (133.4242pt,149.2109pt);
\draw[pstyle5] (129.4242pt,139.2109pt) -- (133.4242pt,149.2109pt) -- (137.4242pt,139.2109pt) -- (133.4242pt,143.2109pt) -- cycle;
\draw[pstyle4] (133.4242pt,254.6328pt) -- (133.4242pt,264.6328pt);
\draw[pstyle4] (133.4242pt,264.6328pt) -- (209.7825pt,264.6328pt);
\draw[pstyle5] (205.7825pt,199.9219pt) -- (209.7825pt,189.9219pt) -- (213.7825pt,199.9219pt) -- (209.7825pt,195.9219pt) -- cycle;
\draw[pstyle4] (209.7825pt,117.2109pt) -- (209.7825pt,264.6328pt);
\draw[pstyle4] (209.7825pt,117.2109pt) -- (169.9152pt,117.2109pt);
\draw[pstyle5] (179.9152pt,113.2109pt) -- (169.9152pt,117.2109pt) -- (179.9152pt,121.2109pt) -- (175.9152pt,117.2109pt) -- cycle;
\draw[pstyle4] (96.9333pt,117.2109pt) -- (46.066pt,117.2109pt);
\draw[pstyle4] (46.066pt,117.2109pt) -- (46.066pt,149.2109pt);
\draw[pstyle5] (42.066pt,139.2109pt) -- (46.066pt,149.2109pt) -- (50.066pt,139.2109pt) -- (46.066pt,143.2109pt) -- cycle;
\draw[pstyle4] (133.4242pt,85.2109pt) -- (133.4242pt,105.2109pt);
\draw[pstyle5] (129.4242pt,95.2109pt) -- (133.4242pt,105.2109pt) -- (137.4242pt,95.2109pt) -- (133.4242pt,99.2109pt) -- cycle;
\end{tikzpicture}
\caption{Flow diagram of a \texttt{for} loop}
\label{img:forLoop}
\end{figure}

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Structure of a \texttt{for} loop},
label={lst:doWhile}]
#include <stdio.h>
int main(void)
{
    for (/*Assignment*/;/*Condition*/;/*End of iteration*/) {
        /*Instructions*/
    }
}
\end{lstlisting}
\end{minipage}

Where I write assignment is because in that part of the loop you must write
an assignment to a variable, or an assignment and declaration in the same
place. Where I write condition you must write the condition that will control
when the loop will stop executing (or if it executes at all). At the end of
every repetition of the loop (formally we call iterations to the repetitions of
the loop) the instruction you wrote where I wrote end of iteration will be
executed. It's much clearer in the example.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Example of a program with a \texttt{for} loop},
label={lst:forStructure}]
#include <stdio.h>
int main(void)
{
    for (int ii = 1; ii <= 100; ++ii) {
        printf("%d\n", ii);
    }
}
\end{lstlisting}
\end{minipage}

This program performs the same task that we did with the \texttt{while} loop.
As you can see, we declare and initialize a variable called \texttt{ii}, with
value one, execute the body of the loop (the body is the block of code that
will repeat itself) and, at the end to every iteration the variable will be
incremented in one. This kind of loop tends to be very used along something
called arrays, which we will see later.

\subsection{Loop interruption}
Sometimes we want to end an execution of a loop in the middle of an iteration,
in this case we are going to write a program that calculates the power of two
that is greater or equal than a target.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Example of interruption of a loop with an auxiliary variable},
label={lst:loopInterruption}]
#include <stdio.h>
int main(void) {
    int steps     = 0;
    int max_steps = 20;
    int number    = 1;
    int target    = 1024;

    while (steps < max_steps && number < target) {
        steps++;
        number *= 2;
    }
    printf("2 to the %d is greater or equal than %d\n", steps, target);
}
\end{lstlisting}
\end{minipage}

This program calculates the lowest power of 2 that is equal or greater than a
target. We also make sure not to calculate any longer than the max number of
steps that we want.
The variables we need are: the counter of the steps we have done
(\texttt{steps}) (the power we
are testing), the maximun number of steps we are allowed to test
(\texttt{max\_steps}), then a
variable called \texttt{number} that allows us to keep multiplying it by two
and, finally, the \texttt{target} we want to check.
So, basically we have a \texttt{while} with this condition:
as long as the steps we have done are less than the max, and number is less than
our target, we multiply number by two and increase the counter of steps.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Interrupción de un bucle con la instrucción \texttt{break}},
label={lst:breakExample}]
#include <stdio.h>
int main(void) {
    int steps     = 0;
    int max_steps = 20;
    int number    = 1;
    int target    = 1025;

    while (steps < max_steps) {
        steps++;
        number *= 2;
        if (number >= target) {
            break;
        }
    }
    printf("2 to the %d is greater or equal than %d\n", steps, target);
}
\end{lstlisting}
\end{minipage}

In this case we have moved half of our condition to a conditional inside the
loop, that checks if the number is greater or equal than the target.
Mind that we have had to \textbf{invert} the condition. Before, we checked if
number was strictly less than target, because it was the condition to
\textbf{keep computing}, here we are checking the opposite, if number is greater
or equal than the target, because this new condition \textbf{ends} the
computation.
If the breaking condition is true,
we execute a \texttt{break}, exiting from the loop, printing the result
and ending the program.

This way of writting loops is discouraged, ideally all
the conditions that affect a loop termination should be in the loop, or in a
variable that gets cheked in the loop itself. Hence this is not a good practice
in programming, but this is not a manual about that, but to learn the language,
I put this example to allow you to understand this if you see code where it
appears.

Also: \texttt{break} has its counterpart, which is \texttt{continue}. This
instruction omits \textbf{what is left of this iteration} and jumps directly to
the next. Imagine, for example, we want to print if the years from 1 to 2021 are
leap years or not. A year is a leap year given these conditions.
\begin{enumerate}
    \item It is divisible by four.
    \item It is not divisible by one hundred.
    \item It is, in any case, if it is divisible by four hundred.
\end{enumerate}

If one of those conditions is not true, there is no reason to check any other
one, let's see how it will be writen without \texttt{continue}.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Example of algorithm of leap year},
label={lst:lapExample}]
#include <stdio.h>
int main(void)
{
    for(int ii = 0; ii < 2021; ++ii){
        int bisiesto = ii % 400 == 0 ||
                          (ii % 4 == 0 && !(ii % 100 == 0));
        if(bisiesto){
            printf("The year %d is a leap year.\n", ii);
        }
    }
}
\end{lstlisting}
\end{minipage}

A somewhat complex condition pops up, but if we write it with \texttt{continue}:

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Example of algorithm with continue},
label={lst:continueExample}]
#include <stdio.h>

int main(void)
{
    for(int ii = 0; ii < 2021; ++ii){
        if(ii % 4 != 0){
            continue;
        }
        if(ii % 100 == 0 && ii % 400 != 0){
            continue;
        }
        printf("El año %d es bisiesto\n", ii);
    }


}
\end{lstlisting}
\end{minipage}

It uses more lines, but some people may argue it is easier to read, you could
read it as ``if it is not divisible by four, go to the next number, if it is
divisible by one hundred but not by four hundred, go to the next too''.
Also, the printing order is not in a conditional, because if we reach the line,
we already know the number is a leap year.

As it happened with \texttt{break}, this is not a better way to write a program,
but I needed to invent some example with the limited content I have shown up
until now. Again, take \texttt{continue} as a novelty more than something that
will be used often.
\section{Data structures}
Data structures are one of the most important things in programming and
in computer science, until now the only structure you knew were variables, each
one of a type and with a different name. This is the simplest structure, but
very often we need more complex structures, in this section we will see two
simple data structures that C provides to the programmer: the array and
the struct, or structure. Structure has a generic meaning as the one I used in
the title, and the sepecific one of being the artifact of the C language I am
going to show you. I will try to say structure when I mean any generic data
structure and struct when I mean the C language feature specifically.

\subsection{The array}
Sometimes we want to pack data of the same type together, those packets are
called arrays. An array is an structure in which we declare space for several
variables, which we will reference by the name of the array and its position
inside it. That is: we reference data in the array by ``the fifth element in
array a''. Let's see how they're declared and used.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Example of declaration of an array},
label={lst:arrayDeclaration}]
#include <stdio.h>
int main(void)
{
    int list_of_numbers[10];
}
\end{lstlisting}
\end{minipage}

In the example we have declared and array with ten position of type
\texttt{int}. And here there is the first important thing: the elements in an
array do not start from one, but from zero. That means that an array like this
one with ten positions hasn't got a position number ten, but positions from
zero to nine.
To access any element in an array we must write the name of it and, between
square braces (\verb![]!), the position we want to access. Inside the braces
there may be any expresion with an integer value, variables included, which
is the most common.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Example of ussage of an array},
label={lst:arrayUse}]
#include <stdio.h>
int main(void)
{
    int list_of_numbers[10];
    list_of_numbers[0] = 30;
    int a = list_of_numbers[0];

}
\end{lstlisting}
\end{minipage}

In this program we are declaring the array, assigning a value to the first
possition and then using that value to assign that possition to another
variable, the values of the first position of the array and the variable
are not linked. If you remember what I said in the last section, we will
use a lot of \texttt{for} loops alongside arrays.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Example of how to use an array},
label={lst:arrayIteration}]
#include <stdio.h>
int main(void)
{
    int list_of_numbers[10];
    for (int ii = 0; ii < 10; ++ii) {
        list_of_numbers[ii] = ii;
    }
}
\end{lstlisting}
\end{minipage}

We must make several considerations, the variable you have declared in a
\texttt{for} loop when you access an array tends to be called \texttt{i}.
It is just a personal habit of mine to call it \texttt{ii}, you can do it as
you wish, but if you want other programmers to read your code easily, I would
encourage you to use any of those two alternatives; secondly: look carefully
the loop, \texttt{ii} takes values from 0 to 9, which are the positions of
the array, and it assigns to them the values of the variable we are using
to access the array, so we wad number in it with values 0, 1... to 9.

But arrays can have more than one dimension, that is, if we now have arrays of
data, we can have matrixes, or cubes, or even structures of unlimited
dimensions. In general, human beings have problems managing more than two or
three dimensions, so I will show you an example on how to use a bi-dimensional
array.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Ejemplo de uso de array bidimensional},
label={lst:bidimensionalArray}]
#include <stdio.h>
int main(void)
{
    int matrix[5][10];
    for (int i = 0; i < 5; ++i) {
        for (int j = 0; j < 10; ++j) {
            matrix[i][j] = 1 + (i * 5 + j);
        }
    }
    for (int i = 0; i < 5; ++i) {
        for (int j = 0; j < 10; ++j) {
            printf("%2d ", matrix[i][j]);
        }
        printf("\n");
    }
}
\end{lstlisting}
\end{minipage}

The first dimension of the array, in this case 5, inficates how many rows
it will have, the second, the columns. You can think of array with two
dimensions as an ``array of arrays''. This is expandable to all the dimensions,
as we said before. You must be careful, if you try to access to an position of
the array that does not exist it is very probable that your program ends
abruptly. If you use nested loops with arrays of several dimensions, the
custom is that the variables that go in the inner loops after \texttt{i} are
called with the following letters (j, k...). This is a mathematical
reminiscence, where big operators like summations or products of series use
indexes with these letters.

\subsection{The struct}
In C a struct is a ``pack'' of data from different type that has a name. It
would be like groupping a series of variables and refer to them as a set.
Which advantage has this got? We can create new types sticking together the
basic ones. If you think about that, it's something very natural, a struct
allows us to use the basic construction blocks of the language, basic types,
and create new concepts with them. In general, we want all the parts of our code
to be able to see these new types, so we will declare them outside all code
blocks, in tye same way I told you a global variable is declared.

When we create a variable of this new type, we are \textbf{instantiating} a
struct. In computer science instantiate is creating a variable of a given type.
We could say ``instantiating an integer'' but it is only applied to composed
types, not basic ones. So, firstly we must create our new type and then
variables of said type.

Now I present you the syntax to declare a struct, to create a variable
of that type and use it.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Declaration, instantiation and use of a \textit{struct}},
label={lst:structUse}]
#include <stdio.h>
struct my_struct {
    int field1;
    char field2;
    double field3;
};

int main(void)
{
    struct my_struct my_variable;

    my_variable.field1 = 100;
    my_variable.field2 = 'b';
    my_variable.field3 = 3.3;
}
\end{lstlisting}
\end{minipage}

The data that are inside a struct are called \textbf{fields}, and they are
accessed with a dot. If you're thinking that makes the point an operator,
you're right, dot is an operator that accesses to the fields in an struct.
Notice that to declare a variables of the new struct type you need to
put the keyword \lstinline[style=C]"struct" before, not only the name you gave
to it.

Let's see an example of an use case of this. Imagine we want to make a program
that calculates the distance between two points, we could do it this way:

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Example of calculation of distance between points in a plane},
label={lst:pointNoStruct}]
#include <stdio.h>
#include <math.h>
int main(void)
{
    double point1_x = 1.1;
    double point1_y = 3.2;
    double point2_x = 2.3;
    double point2_y = 5.4;

    double diff_x = point1_x - point2_x;
    double diff_y = point1_y - point2_y;
    double distance = sqrt(diff_x*diff_x + diff_y*diff_y);

    printf("P1 : [%f, %f]\n", point1_x, point1_y);
    printf("P2 : [%f, %f]\n", point2_x, point2_y);
    printf("Distance: %f\n", distance);
}
\end{lstlisting}
\end{minipage}

As you can see, the program works and does what it is suppossed to do... but
it is quite confusing, the only thing that ``joins'' together the coordinates
of any point is the name of the variable, also, you need to declare many
variables . I think you can see that the very moment we start managing many
points in a program, this could be something very difficult to understand.
Let's see what would come out of using our new knowledge of the structures.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Calculating the distance between two points using structures},
label={lst:pointStruct}]
#include <stdio.h>
#include <math.h>

struct point_s {
    double x;
    double y;
};

int main(void)
{
    struct point_s A;
    struct point_s B;

    A.x = 1.1;
    A.y = 3.2;
    B.x = 2.3;
    B.y = 5.4;

    double diff_x = A.x - B.x;
    double diff_y = A.y - B.y;
    double distance = sqrt(diff_x * diff_x + diff_y * diff_y);

    printf("P1 : [%f, %f]\n", A.x, A.y);
    printf("P1 : [%f, %f]\n", B.x, B.y);
    printf("Distance: %f\n", distance);
}
\end{lstlisting}
\end{minipage}

As you can see, the program is much more clean. Also, I do not have to rely in
the name of the variables to signify that something is a point, but I can
rely in the tools the language offers me.

Note: These two programs use a library (we will speak about them later on)
and need to be compiled with an special option, simply add \texttt{-lm} to the
line you have been using to compile until now, it would end like:
``\texttt{gcc -o main.elf main.c -lm}'' (without the quotes).

\subsection{Initialization lists}
Both arrays an structs have a way to initialize them in a concise way. If you
remember the chapter about variables, initializing a variables is give it
value for the first time. This way of doing so to arrays and structs is the
initialization list. Let's see an example.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Initializing with braces},
label={lst:initializationLists}]
#include <stdio.h>
struct point_s {
    double x;
    double y;
};
int main(void)
{
    struct point_s punto1 = {1.1, 2.3};
    int my_array[10] = {1,2,3,4,5,6,7,8,9,10};
}
\end{lstlisting}
\end{minipage}

In the case of the struct, the members are initialized in the order we declared
when creating the new struct type. So in the example the x coordinate will be
1.1 and the second 2.3. In the case of the array we have filled all the
positions, if we put only some, the remaining will be initialized to zero.
Be careful, because the initializers with braces are good only to initialize,
if we added to the program a line such as:
\lstinline[style=C]!punto1 = {2.2, 4.6}! the
compiler wouldn't let you compile. The same would happen with the array. With
the struct we can do something, initialize only the fields we want, omitting
some, etc. This is done with a little confusing syntax. Let's use an example
with an struct that stores a date. One of its variables is logic, tells if it
is a leap year. It's something we can calculate, but it is not unusual to
store data calculated of an struct on itself so you don't have to do it
all the time.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Initializing a struct with braces and field selection},
label={lst:dateStruct}]
#include <stdio.h>
struct date_s {
    int isLapYear;
    char day;
    char month;
    short year;
};
int main(void)
{
    struct date_s moonLanding = {.month=7, .year=1969, .day = 20};
    moonLanding.isLapYear = moonLanding.year % 4 == 0;
}
\end{lstlisting}
\end{minipage}

As you can see, firstly we have initialized the fields we wanted and later we
calculated what was remaining. Since we have said whose fields we wanted to
assign values to in the initialization list, we didn't even have to worry about
the order. As we saw before the rule to know if a year is a leap year is more
complex but this is just an example.

I want to add as a conclusion that it is posible (and common) to declare arrays
of struct and have struct that have arrays as fields. For example.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Combinación \textit{struct} con array},
label={lst:exampleArrayStruct}]
#include <stdio.h>
struct point_s {
    double x;
    double y;
};
struct triangle_s{
    struct point_s points[3];
};
int main(void)
{
    struct point_s points[2] = {{1.1, 2.3}, {4.5, 6.6}};
    struct triangle_s triangly = {{{1.1, 2.2},{3.3, 4.4}, {5.5, 6.6}}};
    triangly.points[0].x = 1.6;
    triangly.points[0].y = 3.4;
}
\end{lstlisting}
\end{minipage}

Pay attention to the initialization list in line 12, in it the most external
braces indicate that we are initializing the struct \texttt{triangly}, after it,
there is another level of braces because we're initializing the member
\verb"points", which is an array and, finally, for each element of that array
we use an initialization list for each point. A clearer but longer way to write
it would be:

\noindent
\begin{minipage}[H]{\linewidth}
\begin{lstlisting}[style=C]
struct triangle_s triangly = { .points = {{.x = 1.1, .y = 2.2},
                                          {.x = 3.3, .y = 4.4},
                                          {.x = 5.5, .y = 6.6}} };
\end{lstlisting}
\end{minipage}

I have to warn you about one thing, when you initialize an array with an
initialization list you cannot define its size with a variable, that is:
you must do it with a literal value. This has a very clear reason: if you
initialize an array with a variable as its size, for example:
\verb!int array[var] = {1,2};!, the list will indicate that the array is at
least, two positions long, but the compiler does not know how much var will be.
If it's two or more, it is ok, but if it's less, what would the compiler do?
Make an array of that length indicated by \verb"var" and drop values from the
list or ignore \verb!var! and use the elements on the list? Mind you that
the compiler cannot predict the value of a variable until the program is
executed. You may think that in simple programs it may do it, and yes, it could,
but even then, it would be very chaotic to have a rule about how to create
arrays that applies only in certain conditions that are not clear. So, keep this
in mind, if you want an array with a concrete size, determined by a variable,
do not initialize it with an initialization list. In any case, the compiler
would tell you that it's wrong.

\subsection{Exercises of the section}
Now you already have significant knowledge I will propose some exercises to you
to check you understood the concepts presented so far.
\begin{exercises}
\item Write a program that declares a struct that defines a circle in two
dimensions (center and radious). Make a program that declares a variable of
that type and calculates its area.
\item Write a program that, using the struct point presented in the example,
declares an initializes an array of them and prints the directions you must
follow from a point to the next, for example, if the points were:
$(1, 2), (3, 4), (2, 5), (2, 1)$ this will be printed:
\begin{verbatim}
Right, Up
Left, Up
Still, Down
\end{verbatim}

\item Make a program that declares a bidimensional array and prints the
sum of its rows and columns in this way:

\begin{verbatim}
1 2 3 = 6
1 4 2 = 7
5 3 4 = 12
-----
7 9 9

\end{verbatim}

If you put numbers with a different length the columns will be
misaligned, you must not worry about this.

\item Write a program that does the following for the number from one to 100,
both included: if the number is divisible between two, you must print ``fizz'',
if it is divisible by five, ``buzz'', and if its divisible between the two:
``fizzbuzz'', it shall not print anything otherwise.
I leave here an example with the first ten numbers.
\begin{verbatim}
fizz
fizz
buzz
fizz
fizz
fizzbuzz
\end{verbatim}
\end{exercises}

\section{Functions}
\label{funciones}
We are arriving to one of the most important parts of the manual. As you have
have read in the title of the section, we are going to talk about functions.
In programming, a function is almost a direct translation of what a function
is in mathematics. Let's start there, in mathematics a function is an object
that receives a series of arguments from certian domains and gives a result
that is in some codomain. In other words, it receives a set of mathematical
objects each one from a type (numbers, vectors, matrixes...) and gives you a
result of some type of mathematical items.
$$
f(x) : \mathbb{R} \longrightarrow \mathbb{R}_{\ge 0}
$$
$$
x \to x^2
$$

That thing up there is basically a very formal way of writting $f(x) = x^2$
and $x$ is a real number. We have defined the domain (the real numbers) and the
codomain (the \textbf{possitive} real numbers) and the transformation you need
to make to the arguments to get the result. A function in C is the same, it is
a piece of code that receives a series of arguments and ``returns'' a result.
I am going to explain it in yet another way: a function is like a ``black box''
that receives ingredients and gives us a result, without the need to know what
is inside.

After that introduction, let's see how they are declared, defined and used.
The declaration is writen as it follows:
\begin{enumerate}
\item Data type of return of the function, that is, the codomain, el data type
the function is going to give us. For example, \lstinline[style=C]{double}.
\item Name of the function, in the same fashion than variables, functions have
to have a name. For example: \verb!power!
\item Opening parenthesis (\texttt{(})
\item List of parameters (arguments) of the function, with their type, separated
by a comma each one. In this case as example, two integers: \verb!base! and
\verb!exponent!.
\item Closing parenthesis (\texttt{(})
\item As always, end the line with semicolon.
\end{enumerate}

Following the examples we set before, it would be like:

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C, label={lst:functionDeclaration},
caption={Function declaration in C}]
double power(int base, int power);
\end{lstlisting}
\end{minipage}

But this function cannot be used, because we haven't defined it. Define a
function is in a way like initializing a variable. And it is saying
\textbf{what the function actually does}. To do that, we copy the definition of
the function (without the semicolon) and we write a block of code. Which would
look like this:

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C, label={lst:functionDefinition},
caption={Definition of a function in C}]
double power(int base, int exponent)
{
    //Here you would put instructions
}
\end{lstlisting}
\end{minipage}

If you have been paying atention, you may have seen a similarity between that
last fragment of code and the first program we wrote. This is not by chance,
when you wrote \verb!int main(void)!... what you were doing was \textbf{declare
and define} a function called \verb!main!. What you may be wondering now is why.
This is because in the Linux operating system and in most operating systems
the way programs start is by the operating system calling their \texttt!main!
function. That is why I had to make you write all those lines without telling
you what they were. Finally, the ``shape'' of a function (return type and
type of arguments) is called signature of a function.

Let's come back to the function \verb!power!, now we have it ready to be written,
we can define its behaviour. In a function, the block of code that goes after
the argument list is called \textbf{body}. Inside the body the arguments can
be used as local variables. With this you can calculate the value you want the
function to \textbf{return} and make C do so with the
\lstinline[style=C]{return} (makes sense, doesn't it?). When you use this word,
the function ends executing (you go out of it). Let's see how we can implement
the function of the example that, if you didn't guess it by the name, calculates
the power \verb!base! to \verb!exponent!. It would end up like this:

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C, label={lst:functionExample},
caption={Example of a function in C}]
double power(int base, int exponent)
{
    double res = 1;
    int ii = 0;
    while (ii != exponent) {
        if (exponent < 0) {
            res /= base;
            ii--;
        }
        else {
            res *= base;
            ii++;
        }
    }
    return res;
}
\end{lstlisting}
\end{minipage}

The function does this: declares a variable called \verb!res! which will be
where we will save the power we calculate. After that, we will use a
\verb!while! loop to multiply of divide (according to if the exponent is
possitive or negative) as many times as it's needed. At the end, we will return
the result.

All right, now we have defined the function let's see how you use it. To use
a function you will ``invoke'' it. To do so we will simply write its name and
the arguments it needs. Let's see an example, if before in our program we
have defined the function, this fragment of code will print several powers.
If you think about this, using a function in a programming language is like
writting the concrete value of a function in mathematics, if $f(x) = x^2$
then you know writing $f(3)$ is the name as writting a nine.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C, label={lst:functionInvocation},
caption={Invocación de función en C}]
#include <stdio.h>
// Paste here definition of power
int main(void)
{
    double powers[3];
    powers[0] = power(2, 10);
    powers[1] = power(2, 0);
    powers[2] = power(10, -3);
    for(int ii = 0; ii < 3; ++ii){
        printf("%f\n", powers[ii]);
    }
}
\end{lstlisting}
\end{minipage}

As you can see, the values returned by functions are used as those returned by
operators, you can save them in arrays or assign them to variables. And, now
we're here, let's expalin another thing, as you may have already guessed,
\verb!printf! is a function. What is particular about it is that it's an special
function, its first argument (the format) is a pointer, which a new type I
haven't explained to you before. At this level, all the functions we write will
have a fixed number of arguments, which is the more common thing.

And, lastly, the keyword \lstinline[style=C]{void}. Void means and empty space.
This is the word we use when we want to indicate that a function doesn't need
any argument, for example, \verb!main!, or that it does not return any value.
One second, what is a function that doesn't return anything good for? Well,
while functions in C are very much like mathematical functions, they're not
exactly the same, because functions in C can manipulate other thing the are not
their arguments, the global variables. The most common example is \verb!printf!,
that does a thing which is not returning anything, but manipulate the terminal,
which is symbolized as a global variable of a concrete type. I told you when I
mentioned them that they weren't useful for us ``yet''. When you have several
functions, sometimes you need to use global variables because they will be
available in all the functions, but, as I told you, it is not the best thing to
do.

Finally, one precission: I have said to you that inside the body of the function
the arguments behave like local variables, and that may have led you to this
question: if you change the value of any argument, is that variable changed
outside the function? No, the arguments of a function are \textbf{copies} of
those that were given to them when invoking it. Let's see it with an example:

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C, label={lst:functionByValue},
caption={Demostración de que una función recibe copias de sus argumentos}]
#include <stdio.h>

void doble(int a){
    a = a * 2;
}
int main(void)
{
    int number = 3;
    printf("%d\n", number);
    doble(number);
    printf("%d\n", number);
}
\end{lstlisting}
\end{minipage}

If you compile and execute this you'd see that both times the program prints
a three. This is because, as I said, the arguments are copies of the ones
you passed them.

\subsection{Separation between declaration and definition}
% Te he explicado cómo declarar y cómo definir una función por separado, pero
% en los ejemplos siempre he incluido únicamente la definición. Esto es porque en
% la definición incluimos la declaración. Hay dos motivos por los que puedes
% separar ambas cosas, el primero es que quieras separar tu código en varios
% archivos, cosa que te explicaré más adelante, pero el segundo es que necesites
% definir todas las funciones porque se usan unas a otras, veamos un ejemplo
% de dos funciones, cuyo objetivo es imprimir siempre <<Temporada de patos>> y
% <<Temporada de conejos>>, dependiendo de a cuál llames primero, el orden será
% uno u otro. El código sería el siguiente:

I have already explained to you how to declare and define a function
separatedly, but in all the example I have always included only the definition.
This is because in the definition we include the declaration. There are to
reasons to do both things separatedly, the first one is that you want to
separate your code in several files, thing we will do later on, but the second
is that you need to define all the functions because they use each other, let's
see and example of two functions, whose target is to print always
``Duck season'', and ``Rabbit season'', depending on which was called first,
the order will be one or the other. The code would be something like this:


\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C, label={lst:cyclicFunctions},
caption={Declaration not separated from definition}]
#include <stdio.h>

void ducks(void){
    printf("Duck season!\n");
    rabbits();
}

void rabbits(void){
    printf("Rabbit season!\n");
    ducks();
}

int main(void)
{
    ducks();
}
\end{lstlisting}
\end{minipage}

But if you try to compile this, the compiler will say that the function
\verb!rabbits! is not declared when you use it inside the function \verb!ducks!,
and, as you can see, it is not, because it is defined below that point. The
program, nevertheless, works, but it is not, again, sensible, using functions
without defining them before.
How could we solve this? Putting the declaration of both functions
\textbf{before} of their definitions. That is:


\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C, label={lst:cyclicFunctions},
caption={Declaration separated of definition}]
#include <stdio.h>

void ducks(void);
void rabbits(void);

void ducks(void){
    printf("Duck season!\n");
    rabbits();
}

void rabbits(void){
    printf("Rabbit season!\n");
    ducks();
}

int main(void)
{
    ducks();
}
\end{lstlisting}
\end{minipage}

If you execute this, your program will be executing forever, so hit control key
and C at the same time to end it.

\subsection{The functions and the arrays}
The arrays are a special question when they're mixed with functions for two
reasons: when you pass an array as an argument to a function, \textbf{you can
modify the contents of it}. This is because arrays that are passed to a function
turn into \textbf{pointers}. As you can see, I have mentioned them several
times. They're one of the most central elements of the language and where its
power is, hence I will explain them later on, but its presence is felt
in an invisible way all we are learning up until now, as you will see when we
reach that point. At the moment, just remember that when an array is an argument
of a function, you can modify its elements. Let's see an example of two
functions, one modifies the elements of an array passed ar argument and the
other does not.


\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C, label={lst:arraysAndFunctions},
caption={Array use with functions}]
#include <stdio.h>

void print_array(int array[], int array_size) {
    for(int ii = 0; ii < array_size; ++ii){
        printf("%d ", array[ii]);
    }
    printf("\n");
}

void add_one_to_each(int array[], int array_size){
    for(int ii = 0; ii < array_size; ++ii){
        array[ii]++;
    }
}

int main(void)
{
    int my_array[] = {1,2,3,4,5,6,7,8};
    print_array(my_array, 8);
    add_one_to_each(my_array, 8);
    print_array(my_array, 8);
}
\end{lstlisting}
\end{minipage}

As you can see, if you execute this, you would print first the original array
and later the array with its elements incremented in one. This shows you that
elements in an array can be modified by functions. May be you wonder if you can
modify structures. \textbf{No}, you cannot modify struct fields when you pass
them as arguments. I also want you to see that when you pass an array to a
function in the list of arguments you must write: \verb!type name[]!, for
example in both functions shown before: \verb!int array[]!. Also, a function
\textbf{cannot return an array}, this is for reasons I will explain when we go
deeply into topics of pointers. Finally, functions cannot receive bisimensional
pointer, for similar reasons.


\subsection{Exercises of the section}
% En esta sección te pediré que escribas varias funciones, cabe mencionar que
% aunque no se pide, es recomendable, para comprobar que lo has hecho bien, que
% \textbf{pruebes} estas funciones llamándolas en tu función \verb!main! con
% valores  imprimiendo los resultados si fuera necesario.
In this section I will ask you to write several functions, needed to say that,
even when it is not asked for in every exercise, you should check
you have done it right, \textbf{testing} the functions calling them in your
function \verb!main! with values printing the results.

\begin{exercises}[resume*]
\item Write a functions that tells if a number is prime or composed. Note: a
number is prime only if it is divisible only by itself and the unit (1). One
itself is not composed nor prime.

\item Write a function that calculates the distance between two point structures
in the last section. To calculate the square root of a number you must use
the function \verb!sqrt!, to be able to use it you should include at the
begining of your program (just right under the line that says:
\verb!#include zstdio.h>!) the line \verb!#include <math.h>! and all \verb!-lm!
to the command to compile the programs, that would be:
\verb!gcc -o main.elf main.c -lm!
\item Write a function that receives an array of integers and a separator char
that will print the elements in the array separated by that char, for example,
to the array \verb!{1,2,3,4}! and the char \verb!'\n'!, it will print:

\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{verbatim}
1
2
3
4
\end{verbatim}
\end{minipage}

\item Write a function that encapsulates the program
\ref{lst:linealSystemFinal}: \nameref{lst:linealSystemFinal}. The function must
receive the coefficients if the equations ($a$, $b$, $c$, $d$, $e$ y $f$). It
can receive them separatedly of in an array. To return the result you can create
a struct that has two \verb"doubles".
\item Write a function that normalizes the elements of an array of
\verb!double!. Normalize is express all the elements in terms of the unit,
so to normalize it you must divide all elements by the biggest element
\end{exercises}

\section{The Memory}
This is one of the most important sections of the manual. Even when this is a
manual about C programming, it is very difficult, if not impossible, to program
in C in a sophisticated way without understanding, at least partially, the
memory of a computer. Up until now I have said that the variables that you
declare, both of basic types and arrays or structs are stores in ``memory'',
but, what is exactly a computers memory? Well, let's start from the most
evident thing, how does it look?
\begin{figure}[H]
    \includegraphics[width=\linewidth]{ram}
    \caption{RAM memory module}
    \label{img:ram}
\end{figure}

Here you can see a module of memory of a computer. This module is a circuit
board soldered to it. The chips are the black rentangles. In them it is stored
the information in binaty code. A memory is a system from which you ask fro a
portion of information and it deposits the value in a set of ``cables'' that
are in the computer, from which the values travel to the CPU, the processor,
the memory is \textbf{addressed}. This means that each portion of the memory
is referenced by a number.

% Utilizando una analogía, imagina que la memoria
% fuera un cuaderno con una cuadrícula, en cada cuadrado digamos que cabe una
% cifra o una letra, para poder rellenar o leer el cuaderno, lo que haremos
% es numerar las cuadrículas. Empezaremos con la cuadrícula cero, después la uno,
% y así sucesivamente.

Using an analogy, imagine that the memory is a notebook with a grid, in each
cell you can store a figure or a letter, to be able to fill or read the
cell, what we will do is assign a number to each one a number. We will start
with the number zero and after that the one, two...


\begin{table}[H]
    \centering
    \begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|}
        \hline
f&a&3&7&J&n&c&C&H&r&y&D&s&b&z\\\hline
a&y&y&4&c&B&W&D&x&S&2&2&J&j&z\\\hline
h&M&a&i&R&r&V&4&1&m&t&z&x&l&Y\\\hline
v&K&W&r&O&7&2&t&K&0&L&K&0&e&1\\\hline
z&L&O&Z&2&n&O&X&p&P&I&h&M&F&S\\\hline
v&8&k&P&0&7&U&2&0&o&0&J&9&0&x\\\hline
A&0&G&W&X&I&I&w&o&7&J&4&o&g&H\\\hline
F&Z&Q&x&w&Q&2&R&Q&0&D&R&J&K&R\\\hline
E&T&P&V&z&x&l&F&r&X&L&8&b&7&m\\\hline
t&K&L&H&I&G&h&I&h&5&J&u&W&c&F\\\hline
    \end{tabular}
    \caption{Example of a grid with values}
    \label{tab:notebookSimulation}
\end{table}

In the table you can see an emulation of this notebook, imagine that I tell
you ``tell me what is in the cell number 24''. Keeping in mind that it is
a table of 15 columns and that \textbf{we start counting from zero}, you'd have
to say ``S'', because the \textbf{address} 24 is the nineth position of the
second row. In general, computer memories are \textbf{addressed by bytes}, this
means that for each byte there is a number (an address). You may have noted that
it is absurd to draw this in a table if we are assigning simply numbers, this
should be a continous list, a table of a single columns. If you have thought
that, you're right, because that's how memory is usually represented.

% En resumen: la memoria de los ordenadores es una sucesión continua de bytes
% numerados desde el 0 en adelante, a los que podemos referenciar por ese número
% tanto para leer como para escribir en ellos.

To sum it up: the memory in computers is a continous succession of bytes
numerated from zero and on, to which we can reference by that number
both to read and write.

\subsection{Positional numerical systems: decimal, binary, hexadecimal}
\label{numericSystems}
% Como ya dijimos en la introducción, el ordenador sólo entiende código binario,
% y esto es aplicable tanto a las direcciones de la memoria como a su contenido.
% Debido a esto, me veo compelido, pues, a
% darte una pequeña clase sobre cómo funciona el código binario. El código binario
% es un sistema numérico posicional. Un sistema posicional es aquél en que los
% números se componen de cifras, cada una de las cuales tiene un valor dependiendo
% de su \textbf{posición} dentro del número. Cuanto más a la izquierda están las
% cifras en un número, más valen. Recuerda cuando aprendiste cómo funcionaban los
% números: había unidades, decenas, centenas, millares... y así sucesivamente,
% el sistema que usamos es posicional, y es decimal, porque tenemos 10 cifras para
% representar números, desde el 0 al 9. Pues en binario funciona igual, pero sólo
% disponemos de dos cifras.

As we said in the introduction, the computer only understands binary code,
and this is applicable both to the addresses of the memory and its contents.
Due to this, I am compelled to teach you how the binary code works. The binary
code is a positional numerical system. In a positional system numbers are
composed by figures, each one of those figures has a value depending on which
\textbf{position} they occupy in the number. The more to the left they are in
the number, the more they add to it. Remember when we learnt how numbers work,
you had units, tens, hundreds, thousands... and so on and so forth. The system
we use to write numebrs is, therefore, positional, and decimal, because we have
ten figures (from zero to nine). In binary it's the same, but with only two
figures.

% Un sistema numérico posicional
% funciona de este modo: si la base numérica es $n$, cada cifra de un número vale
% el valor de la misma cifra multiplicado por $n$ elevado al número de posiciones
% que queden a la derecha del número. Como siempre, veámoslo con un ejemplo: si
% escribimos el número 34.789, el cálculo que usamos para saber cuánto vale es
% el siguiente:
% (Recuerda que un número elevado a 0 es 1)
% $$
% 3\cdot10^4+4\cdot10^3+7\cdot10^2+8\cdot10^1+9\cdot10^0
% $$
% $$
% 3\cdot10000+4\cdot1000+7\cdot100+8\cdot10+9\cdot1
% $$

A positional numerical system works in this way: if the numeric base (number of
different figures available, in the case of our system, 10) is $n$, each figure
adds to the number the value of the figure multiplied by $n$ to the power of
how many figures are left to the right of this one. As always, let's see it with
and example: is we write the number 34,789, the calculation we perform to
know how much it adds up is this one (remember that any number that is not zero
powered to the zero power is one):
$$
3\cdot10^4+4\cdot10^3+7\cdot10^2+8\cdot10^1+9\cdot10^0
$$
$$
3\cdot10000+4\cdot1000+7\cdot100+8\cdot10+9\cdot1
$$

Again, we can express it like tens, hundreds, unit... which are the names
we have to those concrete powers of ten.

So, if you had a binary number, you'd make the same calculation, but instead of
unit, tens, hundreds and thousands, etc. you'd have to use units, couples,
quartets, octets and groups of 16 (there is no word for that). Given the binary
number 1110101, the calculation would be:
$$
1\cdot2^6+ 1\cdot2^5+1\cdot2^4+0\cdot2^3+1\cdot2^2+0\cdot2^1+1\cdot2^0
$$
$$
1\cdot64+ 1\cdot32+1\cdot16+0\cdot8+1\cdot4+0\cdot2+1\cdot1=117
$$

Now you already know how to read a binary numbers, you need to see how a decimal
numbers is converted to binary. To do so, you do the following:
\begin{enumerate}
\item Divide the number by two, calculating the residue.
\item If the division leaves no residue, you write a zero on the left side of
the resulting number, if it has residue (it can only be one), you write one.
\item Repeat until the \textbf{result} of the division is zero.
\end{enumerate}

Let's see an example of this, given the number 253, if you apply the procedure,
you should have something like the operations below. If you note the results of
the divisions in the direction of the arrow in the bottom of the diagram you
could compose finally the binary number: 11111101.


$$
\matrix{
253                   &\division{2}                 &&&&&& \cr
\padding5\padding     &126                          &\division{2}                 &                      &                      &                             &                             &                             &                 \cr
\padding\underline{13}&\padding0\padding            &\padding63                   &\division{2}          &                      &                             &                             &                             &                 \cr
\padding\padding1     &\padding\padding\underline{6}&\padding0\padding            &\padding31            &\division{2}          &                             &                             &                             &                 \cr
                      &\padding\padding0            &\padding\padding\underline{3}&\padding1\padding     &\padding\underline{15}&\division{2}                 &                             &                             &                 \cr
                      &                             &\padding\padding 1           &\padding\underline{11}&\padding\padding1     &\padding\padding\underline{7}&\division{2}                 &                             &                 \cr
                      &                             &                             &\padding\padding1     &                      &\padding\padding1            &\padding\padding\underline{3}&\division{2}                 &                 \cr
                      &                             &                             &                      &                      &                             & \padding\padding1           &\padding\padding\underline{1}&\division{2}     \cr
                      &                             &                             &                      &                      &                             &                             & \padding\padding1           &\padding\padding0\cr
\padding\padding1     &\padding\padding0            &\padding\padding 1           &\padding\padding1     &\padding\padding1     &\padding\padding1            & \padding\padding1           & \padding\padding1           &                 \cr
}
$$
$$
\overleftarrow{\hphantom{\matrix{
		253                   &\division{2}                 &&&&&& \cr
		\padding5\padding     &126                          &\division{2}                 &                      &                      &                             &                             &                             &                 \cr
		\padding\underline{13}&\padding0\padding            &\padding63                   &\division{2}          &                      &                             &                             &                             &                 \cr
		\padding\padding1     &\padding\padding\underline{6}&\padding0\padding            &\padding31            &\division{2}          &                             &                             &                             &                 \cr
		&\padding\padding0            &\padding\padding\underline{3}&\padding1\padding     &\padding\underline{15}&\division{2}                 &                             &                             &                 \cr
		&                             &\padding\padding 1           &\padding\underline{11}&\padding\padding1     &\padding\padding\underline{7}&\division{2}                 &                             &                 \cr
		&                             &                             &\padding\padding1     &                      &\padding\padding1            &\padding\padding\underline{3}&\division{2}                 &                 \cr
		&                             &                             &                      &                      &                             & \padding\padding1           &\padding\padding\underline{1}&\division{2}     \cr
		&                             &                             &                      &                      &                             &                             & \padding\padding1           &\padding\padding0\cr
}}}
$$

If you are an user of computers, you may have heard sentences like
``this computer has a 32 bit computer'' or ``this computer is compatible with
64 bit software''. That numbers of bits is the size of, between other things,
the memory addresses. A computer of 32 bits has 32 bit memory addresses, hence
it can address 2\textsuperscript{32} bytes. Newadays most computers are 64 bit,
so most of them can address 2\textsuperscript{64} bytes of information
theoretically. Of course, a computer will be always limited by the actual amount
of memory it has which in normal computers is usually of a handful of gigabytes.


% El problema es que 64 cifras binarias con muchas para leerse de manera
% sencilla, mira este número binario:
% 1101001001010101001010100101101010101010101110100100111010010101. Es muy
% largo. Por ello, cuando se expresan direcciones de memoria se utiliza otro
% sistema numérico (soy consciente de que esto es un gran rodeo). Este sistema
% numérico es el \textbf{hexadecimal}. Es un sistema de base 16, con cifras del 0
% a la F. Sí, a la F, has leído bien. Como los números que usamos son de base 10,
% no tenemos símbolos para representar una cifra que valga 10, 11, 12... y así
% hasta 15, así que utilizamos letras del alfabeto latino. Por lo demás, funciona
% igual que el binario o el decimal. Un número hexadecimal se suele representar
% con <<0x>> delante para indicar que es ese tipo de número. Veamos un ejemplo,
% sea el número hexadecimal 0xF2A:

The problem is that 64 binary digits are too many to be read easily, look at
this binary numbers:
1101001001010101001010100101101010101010101110100100111010010101. It's too long.
Because of that, when memory addresses are writen, they are writen in a
different numerical system. This numerical system is the \textbf{hexadecimal}.
If a system with base 16, with figures from zero to F. Yes, to F, you have read it
right. Since numbers in our normal system have base 10, we haven't got symbols
to represent a figure that has value 10, 11, 12... up to 15, so we use letter of
the latin alphabet. Otherwise, it works in the same way than binary or
decimal. A hexadecimal numbers is usually written with ``0x'' infront of it
to tell the reader that what follows is a number in that base. Let's see an
example, given the hexadecimal number 0xF2A.
$$
\mathrm{0xF2A} = 15\cdot16^2 + 2\cdot16^1 + 10\cdot16^0 = 3882
$$

To turn a decimal number into hexadecimal you must follow these steps:
\begin{enumerate}
\item Convert the number to binary
\item Divide the number in groups of four bytes \textbf{begining on the right
side}.
\item Turn each one of the groups to decimal and write the corresponding
hexadecimal digit.
\end{enumerate}

Let's go back to the example of the number we converted to binary before, 253,
in binary it is 11111101, if we wanted to convert it to hexadecimal we would
need to divide it in groups of four: 1111~1101. the number 1111 is 15, so it'd
be F, and the number 1101 is a 13, so it would be D, therefore 253 would be
equal to 0xDF. If the leftmost group is not a 4 byte group, you must put zeroes
on the left side. By the way, to convert to hexadecimal, to binary, simply take
every hexadecimal digit and convert it to binary again but, remember, each digit
is a four byte binary number, so 0x33 would be 0011~0011. no 1111, that would
be a different number entirely. You're prepared to start learning how the memory
of a computer works.

\subsection{The memory map}
One of the most common way to represent the memory of a computer is with a
\textbf{memory map}, that is a drawing in the shape of a column in which the
contents of the memory are explained, indicating on the side the relevant
addresses. Look at the following figure:

\begin{figure}[H]
    \center
    \includegraphics[width=0.5\linewidth]{emptyMemoryMap}
    \caption{Mapa de memoria vacío}
    \label{img:emptyMemoryMap}
\end{figure}
In that figure we hace drawn the whole computer memory in a column, with
the lower addresses (near zero) in the top and the higher ones (closes to
0xFF...) in the bottom. Generally I like more this representation, but in
many sources and literature you'd see the map drawn in the other direction.

If your programs were the only software that executed in the computer, you'd
have the whole map available for you and you wouldn't have to do anything to
write on memory, simply... do it. But this is not the case, because your
programs are executed thanks to the operating system. The operating system has
many functionalities: it coordinates the programs that are executed in the
machine, manages file systems, allows the CPU to understand devices such as
keyboards and controllers... but one of its most basic functions is \textbf{
memory management}. First of all: when a program is executed, its contents are
loaded from where it is stored (your hard disk mainly) to your RAM memory, and a
\textbf{process} is created. A process is the actual program running in memory,
you could see the program as the blueprints of a car and the process as an
instance of a car, concrete, that is working in the world.
The OS gives processes memory blocks on which these can
write or not, and \textbf{ensures} that they do not go out of their assigned
memory.

In the section in which I talked about array I told you that if you accessed to
a position of an array that didn't exist, your program would end abruptly, test
it. Make a program that declares an array of, for example, 10 positions and
afterwards writes something in position 2,500. You'd see how the program writes
a message like this one when executed:


\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=terminalStyle]
\$ ./main.exe
Segmentation fault (core dumped)
\end{lstlisting}
\end{minipage}

It is possible that it does not throw the message, due to how the computer
manages the memory internally. Anyway, for a C programmer, memory management
(and specially check that he does not write to or reads from memory blocks it
shouldn't) is one of the most important tasks, if not the most. In this task,
the operating system decieves our programs. To our program, you have an
available memory that is the whole map (the 2\textsuperscript{64} bytes), even
when the computer may have, for example, 8 GB which is several thousand times
less. By the way, in general terms, each level in the prefixes of multiplication
of 1,000 is not 1,000, but 2\textsuperscript{10}, 1,024, when you're talking
about bytes, if we were exhaustive,
we should write GiB, MiB and so on, which is the correct way to indicate those
prefixes that multiply by 1,024. What the operating system does is to alocate
what we ask from him in the \textbf{physical} memory and gives us addresses of
that map of memory we think we have, and translates it. This process is the
\textbf{memory virtualization}, and is one of the most important features of an
operating system. Thanks to it, the programmer doesn't need to manage where the
memory is physically allocated. Also, it allows each process to be isolated,
the programmer has no idea which other processes are doing in their memory map,
and other processes have no information about what we're doing with ours.

In this map of virtualized memory, which efectivelly the one we're going to use,
the operating system creates a set of \textbf{memory regions}, which are used to
alocate different types of information of each program executing in a computer.
Now I will show you a memory map with the most important regions, and I will
explain what they are and why we care about them.
\begin{figure}[H]
    \center
    \includegraphics[width=0.5\linewidth]{regionsMemoryMap_en}
    \caption{Regions of the memory map of a process}
    \label{img:regionsMemoryMap}
\end{figure}

The text region is easy, it is were the instructions that your program is going
to execute are stored. When I explained you what compilation was I told you we
were going to transform our instructions in a binary the computer can execute.
This is the section where it is stored. To generate a program, those
instructions in binary are stored in the disk in the executable. When they load
in memory, they go in this section. This section can't be directly read or
changed by the program itself.

The next one starts to be interesting. This sections stores the value of the
global variables, either of basic types, arrays, or structs that you write
initialized in the code (initializing the variables from a functions or other
block of code won't count). This is because the values you store in them will
exist before your program starts executing, in the very moment the process is
created. The next section stores those \textbf{global} varuables you haven't
initialized. Why only the global ones in both cases? Because the function
\verb!main! is a function and the variables declared in functions (or any other
block of code) are not stored here, but in the next section, the stack.

Look at the map, this section is at the bottom (towards the higher addresses),
but I am going to explain it now because it is one of the most important. The
varuables you declare in a block of code: functions, loops, conditionals, etc.
are stored. Why? Because in this section of memory data can go in and out, or
better said, the memory of old data can be reused to write new ones. To explain
how this is done, firstly I need to explain you how a stack (in general terms)
works.

A stack is a data structure, like arrays or structs, which works in this way:
when you put something in the stack, that element in on top, and when you pull
out something from the stack, you can only pull out the last element, the one
in the top of the stack. I am going to set a physical example: a can of the
famous Pringles\textsuperscript{®} potato chips. The only potato that you can
pull out is the top one, if you want get more, you can, but always in the
reverse order from how they were put in the can. Any stack works the same. The
way this stack is applied to C programming is this way: when the execution flow
goes into any code block, the variables declared inside it are \textbf{added}
to the stack. This includes arrays and structs. When the flow goes out of the
block, those variables are \textbf{pulled out} of the stack, that is, they're
lost because it is understood they were already used. This is the very reason
\textbf{functions cannot return arrays}. Because those array would cease
existing once the functions has returned.

Maybe you're wondering why you can declare basic types variables or structs
inside functions and return them, if they're going to be destroyed once the
function is finished executing. That is because, in the same way the arguments,
the return value when it is not an array get copied. Concretelly it left in the
top part of the pile so the \textbf{code where it called} of the function can
copy it with an assignation. With array \textbf{we cannot use the assignment
operator}, it is not how arrays are copied. As a matter of fact the compiler
would throw an error if you tried assigning an array to another.

Let's see an example of how the stackw ould look in the case of executing some
of the example programs we've writen. We're going to use the program
\ref{lst:arraysAndFunctions}: \nameref{lst:arraysAndFunctions}.
In this example you're going to see that in the pile there two names
(\verb!my_array! and \verb!array!), but remember they \textbf{point to the same
array}. They only copy the address it starts, not the elements.
\begin{table}[H]
\centering
    \begin{subfigure}{0.33333\linewidth}
        \centering
        \begin{tabularx}{.9\linewidth}{|Y|}
        \hline
        \textbf{The stack starts empty}\\\hline
         \\\hline
        \multicolumn{1}{c}{\color{white}CIERTOFALSO\normalcolor}\\ \arrayrulecolor{white}\hline
        \multicolumn{1}{c}{\color{white}CIERTOFALSO\normalcolor}\\ \arrayrulecolor{white}\hline
        \multicolumn{1}{c}{\color{white}CIERTOFALSO\normalcolor}\\ \arrayrulecolor{white}\hline
        \end{tabularx}
    \end{subfigure}%
    \begin{subfigure}{0.33333\linewidth}
        \centering
        \begin{tabularx}{.9\linewidth}{|Y|}
        \hline
        \textbf{Going into \texttt{main}}\\\hline
        my\_array\\\hline
        \multicolumn{1}{c}{\color{white}CIERTOFALSO\normalcolor}\\ \arrayrulecolor{white}\hline
        \multicolumn{1}{c}{\color{white}CIERTOFALSO\normalcolor}\\ \arrayrulecolor{white}\hline
        \multicolumn{1}{c}{\color{white}CIERTOFALSO\normalcolor}\\ \arrayrulecolor{white}\hline
        \end{tabularx}
    \end{subfigure}%
    \begin{subfigure}{0.33333\linewidth}
        \centering
        \begin{tabularx}{.9\linewidth}{|Y|}
        \hline
        \textbf{Going into \texttt{print\_array}}\\\hline
        array\\\hline
        array\_size\\\hline
        my\_array\\\hline
        \multicolumn{1}{c}{\color{white}CIERTOFALSO\normalcolor}\\ \arrayrulecolor{white}\hline
        \end{tabularx}
    \end{subfigure}%


    \begin{subfigure}{0.33333\linewidth}
        \centering
        \begin{tabularx}{.9\linewidth}{|Y|}
        \hline
        \textbf{Going into \texttt{for}}\\\hline
        ii \\\hline
        array\\\hline
        array\_size\\\hline
        my\_array\\\hline
        \multicolumn{1}{c}{\color{white}CIERTOFALSO\normalcolor}\\ \arrayrulecolor{white}\hline
        \end{tabularx}
    \end{subfigure}%
    \begin{subfigure}{0.33333\linewidth}
        \centering
        \begin{tabularx}{.9\linewidth}{|Y|}
        \hline
        \textbf{We exit the \texttt{for}}\\\hline
        array\\\hline
        array\_size\\\hline
        my\_array\\\hline
        \multicolumn{1}{c}{\color{white}CIERTOFALSO\normalcolor}\\ \arrayrulecolor{white}\hline
        \multicolumn{1}{c}{\color{white}CIERTOFALSO\normalcolor}\\ \arrayrulecolor{white}\hline
        \end{tabularx}
    \end{subfigure}%
    \begin{subfigure}{0.33333\linewidth}
        \centering
        \begin{tabularx}{.9\linewidth}{|Y|}
        \hline
        \textbf{We exit \texttt{print\_array}} \\\hline
        my\_array\\\hline
        \multicolumn{1}{c}{\color{white}CIERTOFALSO\normalcolor}\\ \arrayrulecolor{white}\hline
        \multicolumn{1}{c}{\color{white}CIERTOFALSO\normalcolor}\\ \arrayrulecolor{white}\hline
        \multicolumn{1}{c}{\color{white}CIERTOFALSO\normalcolor}\\ \arrayrulecolor{white}\hline
        \multicolumn{1}{c}{\color{white}CIERTOFALSO\normalcolor}\\ \arrayrulecolor{white}\hline
        \end{tabularx}
    \end{subfigure}%

    \begin{subfigure}{0.4\linewidth}
        \centering
        \begin{tabularx}{.9\linewidth}{|Y|}
        \hline
        \textbf{Going into \texttt{add\_one\_to\_each}} \\\hline
        array\\\hline
        array\_size\\\hline
        my\_array\\\hline
        \multicolumn{1}{c}{\color{white}CIERTOFALSO\normalcolor}\\ \arrayrulecolor{white}\hline
        \multicolumn{1}{c}{\color{white}CIERTOFALSO\normalcolor}\\ \arrayrulecolor{white}\hline
        \end{tabularx}
    \end{subfigure}%
    \begin{subfigure}{0.2\linewidth}
        \centering
        \begin{tabularx}{\linewidth}{|Y|}
        \hline
        \textbf{Going into \texttt{for}} \\\hline
        ii\\\hline
        array\\\hline
        array\_size\\\hline
        my\_array\\\hline
        \multicolumn{1}{c}{\color{white}CIERTOFALSO\normalcolor}\\ \arrayrulecolor{white}\hline
        \end{tabularx}
    \end{subfigure}%
    \begin{subfigure}{0.4\linewidth}
        \centering
        \begin{tabularx}{.9\linewidth}{|Y|}
        \hline
        \textbf{We exit the \texttt{for}}\\\hline
        array\\\hline
        array\_size\\\hline
        my\_array\\\hline
        \multicolumn{1}{c}{\color{white}CIERTOFALSO\normalcolor}\\ \arrayrulecolor{white}\hline
        \multicolumn{1}{c}{\color{white}CIERTOFALSO\normalcolor}\\ \arrayrulecolor{white}\hline
        \end{tabularx}
    \end{subfigure}%


    \begin{subfigure}{0.33333\linewidth}
        \centering
        \begin{tabularx}{.9\linewidth}{|Y|}
        \hline
        \textbf{We exit \texttt{add\_one\_to\_each}} \\\hline
        my\_array\\\hline
        \multicolumn{1}{c}{\color{white}CIERTOFALSO\normalcolor}\\ \arrayrulecolor{white}\hline
        \multicolumn{1}{c}{\color{white}CIERTOFALSO\normalcolor}\\ \arrayrulecolor{white}\hline
        \multicolumn{1}{c}{\color{white}CIERTOFALSO\normalcolor}\\ \arrayrulecolor{white}\hline
        \multicolumn{1}{c}{\color{white}CIERTOFALSO\normalcolor}\\ \arrayrulecolor{white}\hline
        \end{tabularx}
    \end{subfigure}%
    \begin{subfigure}{0.33333\linewidth}
        \centering
        \begin{tabularx}{.9\linewidth}{|Y|}
        \hline
        \textbf{Going into \texttt{print\_array}}\\\hline
        array\\\hline
        array\_size\\\hline
        my\_array\\\hline
        \multicolumn{1}{c}{\color{white}CIERTOFALSO\normalcolor}\\ \arrayrulecolor{white}\hline
        \multicolumn{1}{c}{\color{white}CIERTOFALSO\normalcolor}\\ \arrayrulecolor{white}\hline
        \end{tabularx}
    \end{subfigure}%
    \begin{subfigure}{0.33333\linewidth}
        \centering
        \begin{tabularx}{.9\linewidth}{|Y|}
        \hline
        \textbf{Going into the \texttt{for}}\\\hline
        ii \\\hline
        array\\\hline
        array\_size\\\hline
        my\_array\\\hline
        \multicolumn{1}{c}{\color{white}CIERTOFALSO\normalcolor}\\ \arrayrulecolor{white}\hline
        \end{tabularx}
    \end{subfigure}%


    \begin{subfigure}{0.33333\linewidth}
        \centering
        \begin{tabularx}{.9\linewidth}{|Y|}
        \hline
        \textbf{We exit the \texttt{for}}\\\hline
        array\\\hline
        array\_size\\\hline
        my\_array\\\hline
        \multicolumn{1}{c}{\color{white}CIERTOFALSO\normalcolor}\\ \arrayrulecolor{white}\hline
        \end{tabularx}
    \end{subfigure}%
    \begin{subfigure}{0.33333\linewidth}
        \centering
        \begin{tabularx}{.9\linewidth}{|Y|}
        \hline
        \textbf{We exit \texttt{print\_array}} \\\hline
        my\_array\\\hline
        \multicolumn{1}{c}{\color{white}CIERTOFALSO\normalcolor}\\ \arrayrulecolor{white}\hline
        \multicolumn{1}{c}{\color{white}CIERTOFALSO\normalcolor}\\ \arrayrulecolor{white}\hline
        \multicolumn{1}{c}{\color{white}CIERTOFALSO\normalcolor}\\ \arrayrulecolor{white}\hline
        \end{tabularx}
    \end{subfigure}%
    \begin{subfigure}{0.33333\linewidth}
        \centering
        \begin{tabularx}{.9\linewidth}{|Y|}
        \hline
        \textbf{We exit \texttt{main}} \\\hline
        \\\hline
        \multicolumn{1}{c}{\color{white}CIERTOFALSO\normalcolor}\\ \arrayrulecolor{white}\hline
        \multicolumn{1}{c}{\color{white}CIERTOFALSO\normalcolor}\\ \arrayrulecolor{white}\hline
        \multicolumn{1}{c}{\color{white}CIERTOFALSO\normalcolor}\\ \arrayrulecolor{white}\hline
        \end{tabularx}
    \end{subfigure}%
\caption{Example of the state of the stack in an execution}
\label{tab:stackExample}
\end{table}

Now you know how the stack works and the implications id has in the arrays
saved in it, we can see the last region and maybe the most important, the heap.
This region stores the memory you ask from the operating system with a series of
functions we're going to see. And you may be thinking: why would you do that if
you can declare an array? Easy, this memory you ask the operating system for is
always available to you \textbf{until you free them}. That mean that, contrary
to the arrays, it's your duty to worry about freeing it. Is one of the most
important tasks of a C programmer, but to do so, you need to learn first what
pointers are.

\subsection{Pointers}
Now you know that the memory is addresses by bytes, you must know how we use
addresses in the C language. We do it with a new type (for us) called pointer.
A pointer is a variable that stores a memory address, and allow us to
communicate to functions or other parts of the program \textbf{a memory block}.
You have already used pointers, but you didn't know what they were because I
have chosen to explain other things first, although I have been anticipating
its use.

I told you before that when a functions received an array as an argument it
decays to a mere pointer. This means we do not copy of the arrays functions
receive, what we do is tell the function where the elements of the array are in
memory. In this way, if it is necessary to perform a copy, we can do it, if
not, the function can chose to manipulate or read them directly.

If a pointer symbolizes a memory address, you can think only one type for memory
addresses is needed, but this is not the case. Each datatype (either basic or
struct) has its own pointer, that is, there are not only pointers, but pointers
to \texttt{double}, \verb!char!, to this or that struct... Why is that? Because
when using pointers with associated types, we know \textbf{what is} in the
memory the address points to. For example, if we hace a pointer to \verb!int!
that is 0xFB455DE, we know we must take that byte and the three next ones and
decode them as an integer. Let's see it in the code.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C, label={lst:pointers1},
caption={Pointer declaration}]
#include <stdio.h>

int main(void)
{
    int a = 2;
    int *ptr_to_a;
    ptr_to_a = &a;
    printf("a is in address %p and it is %d\n", ptr_to_a, a);
}
\end{lstlisting}
\end{minipage}

In line 7 we declare a pointer variable for the first time, this is done with
an asterisk that you see between the type of the variable and the name. This is
where it is stablished that this pointer is associated to a \texttt{int}. In
the next line we're assigning a to this pointer the value of the direction,
\verb!a! is allocated. We use the operator \verb!&!. The name of the operator
is ampersand. Said operator, infron of an expression, gives us the pointer to
its type with the address said expression is stored. Mind that, for this to
work,, this expression must be stored somewhere. That is, the temporal values
would throw an error, for example: \verb!&(a * 2)! would throw an error, because
\verb!a*2! hasn't been stored in any place. If you execute the program that uses
the pointer, the output will be something like this:

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=terminalStyle]
\$ ./main.exe
a is in address 0x7fffde738b6c and it is 2
\end{lstlisting}
\end{minipage}

Then, let's a practical case of what pointers are useful for, for example:
we have said several times that a function receives a copy of the arguments but,
what if we wanted to save that effort? If, for example, you wanted a function
that multiplies a number by other, maybe you do not want to copy it, the
function returning the result and copy that result again in the variable, simply
\textbf{leave the function work for you}. If we pass the pointer to our variable
it will be the function the one changing the value, let's see it.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C, label={lst:pointers1},
caption={Pointer ussage example}]
#include <stdio.h>
void multiply(int* ptr, int b) {
    (*ptr) *= b;
}
int main(void)
{
    int a = 2;
    int* pointer_to_a;
    pointer_to_a = &a;
    printf("a is in address %p and it is %d\n", pointer_to_a, a);
    multiply(pointer_to_a, 4);
    printf("a is in address %p and it is %d\n", pointer_to_a, a);
}
\end{lstlisting}
\end{minipage}

Here you can see you we declare a function the received a pointer to integer
(the variable we want to multiply) and an integer (the number we want it to
be multiplied for). In this function you'd see a new use of the asterisk
operator, (\verb!*!), which is the one for \textbf{dereferencing} a pointer.
What is that? It is accessing the value that pointer is referencing (hence the
name). Remember that, as a pointer, \verb!ptr! stores the memory address, so we
need a way to tell C to store in that address the multiplied number. To do so,
we use the asterisk before the pointer. After that, we use the operator
\verb!*=! to multiply and assign. In line 11 you see how we simply call the
function, without having to store what it return (in fact, we have defined it as
\verb!void! so it does not return anything) and we avoid copying the integer we
wanted to multiply.

Apart from the asterisk operator, there is another operator that is used with
pointers that you must know, this is the arrow opeator \verb!->!. It is used to
access the fields of a pointer to a struct. This may be a little confusing, but
I am going to take my time. Imagine we have the point struct we wrote in the
section about structs. If, for any reason, we were using a pointer to it and
wanted to access its fields, we should use the operator asterisk to dereference
the pointer and then the operator dot to access the field. For example, let
\verb!point_ptr! be a pointer to \verb!struct point_s!, to acces its value
\verb!x!, we had to write \verb!(*point_ptr).x!. It is not a problem, but I warn
you that it is very common to have structs with pointers to other structs and so
on... it can become pretty illegible in three or four times. That is why we have
the arrow operator, to make the code before turn into simply:
\verb!point_ptr->x!. I want to clarify that this operator access to the field,
does not gives us a pointer to said field. That is, following the example,
\verb!point_ptr->x! would be a \verb!double!, not a \verb!double*!. Later on we
will see this operator in real use.

\subsubsection{Pointer arithmetic}
Arrays are in certain aspect (but \textbf{not} all) equivalent to pointers, due
to this, pointers can be dereferenced with the square bracket operator. As a
matter of fact, you can turn an array into a pointer explicitly in your program.
As always, let's see how it is done:

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C, label={lst:pointers2},
caption={Arrays como punteros}]
#include <stdio.h>

int main(void)
{
    int my_array[10] = {0,1,2,3,4,5,6,7,8,9};
    int* pointer_like_array = my_array;
    for (int ii = 0; ii < 10; ++ii) {
        printf("array[%d] = %d\n",ii, my_array[ii]);
    }
    puts("========");
    for (int ii = 0; ii < 10; ++ii) {
        printf("array[%d] = %d\n",ii, pointer_like_array[ii]);
    }
}
\end{lstlisting}
\end{minipage}

What you see in the program \ref{lst:pointers2} is what happens without
you noticing it when a function receives an array, is turned into a pointer and
you can use it with the same operators of an array. This, nevertheless; is only
valid for one dimension array, for a reason we will see later on. Exhaustively
speaking, the square braces operator is a \emph{shortcut}. Actually what it does
is add to the pointer and use the asterisk to dereference. When you add an
integer type to a pointer, the pointer arithmetic starts to play, let's see an
example and I'll show you how it works.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C, label={lst:pointers3},
caption={Aritmética de punteros}]
#include <stdio.h>

int main(void)
{
    int my_array[10] = { 0,1,2,3,4,5,6,7,8,9 };
    int* pointer_like_array = my_array;
    for (int ii = 0; ii < 10; ++ii) {
        printf("In address %p there is a %d\n",
            pointer_like_array + ii,
            *(pointer_like_array + ii));
    }

}
\end{lstlisting}
\end{minipage}

If you execute the program you would see that the addresses are four units
apart. This is because when you add an integer to a pointer, even when said
pointer is a memory address of a memory addressed by bytes, due to being a
pointer to \textbf{integer}, that expression of adding an integer to it is
translated in adding that number multiplied by the size of an \verb!int!
(four bytes). After this, we use the asterisk operator so this pointer we have
added a pointer is dereferenced. Using pointer arithmetic is useful when
you want to pass to a function the pointer of a position of an array. For
example:

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C, label={lst:pointers4},
caption={Ejemplo práctico de aritmética de punteros}]
#include <stdio.h>
void multiply(int* number, int other) {
    *number *= other;
}

void multiply_array(int* array, int array_length, int other) {
    for (int ii = 0; ii < array_length; ++ii) {
        multiply(array + ii, other);
    }
}

void print_array(int array[], int array_size) {
    for (int ii = 0; ii < array_size; ++ii) {
        printf(" %d ", array[ii]);
    }
    printf("\n");
}

int main(void)
{
    int array[] = { 1,2,3,4,5,6,7,8,9,10 };
    print_array(array, 10);
    multiply_array(array, 10, 10);
    print_array(array, 10);
}
\end{lstlisting}
\end{minipage}

As an instance, if we use the function that multiplies a number without having
to return it, we can write a function that does the same with an array (here
you can appreciate how functions are a way to reuse code and avoid duplicating
it). We can also see how, using pointer arithmetic, you do not need to have into
account the size of each data type, the language does it for you. There is an
alternative way to do this that you may see because it is more compact, and it
is use the square braces operator to and then use the ampersand to achieve the
address, doing so, line 8 would turn into
\lstinline[style=C]{multiply(&array[ii], other);}. In those cases, using one
or the other is choice of the programmer.

\subsubsection{The \texttt{char} pointer}
Finally I am going to unveil uno of the misteries that I have been hiding from
you for the most time (against my will, for the record) about the programs we
have writen up until now. This mistery is: what are those texts between double
quotes, for example: \verb!"Hello, world!"!. I got a bit ahead of myself in the
title because I wrote the answer there, but they're an abbreviated way to write
\textbf{arrays of \texttt{char}}. You know that a \verb!char! is a letter, and
that an array is a succession of data. The logic conclusion is that, in C, texts
are \verb!char! arrays. If they're \verb!char! arrays, where is their
declaration and why are they there between quotes. To sum it up: because we
write texts in our program so often, the creators of C decided to add a
\textbf{constant expression} to be able to declare arrays of \verb!char! which
are temporal where it is needed, this expression is, putting the text in quotes.
There are expressions to declare arrys of other types, but they're not so
important so we will see them in later sections.

Nevertheless; there is a differente between a \verb!char! array (or pointer when
it is passed to a function) and an array of another data type. The function
\verb!printf!, but in any place we say the size of the array, the number of
elements on the memory the pointer points to. The functions that receive it must
have any mechanism to know how many there are. That way is that every text
chains (called strings in programming) in C are ended in a \verb!char! with
value zero. That is, when it is written \verb|"Hola, mundo!"| we are creating
in a quick way an array of \verb!char! that contains \textbf{fourteen}
\verb!char!, the letters you can see and a \verb!char! with value zero at the
end. I am going to demonstrate this is the case with a little program:

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C, label={lst:sizeofArraysPointers}, caption={Arrays de char}]
#include <stdio.h>

int main(void)
{
    char correct_string[] = "I like choccy milk.\n";
    char incorrect_string[] = {'I', ' ', 'l', 'i', 'k', 'e', ' ',
                               'c', 'h', 'o', 'c', 'c', 'y', ' ',
                               'm', 'i', 'l', 'k', '.', '\n'};
    printf(correct_string);
    printf(incorrect_string);
}
\end{lstlisting}
\end{minipage}
The first string will be printed correctly, but the second will print and,
with all probability, after it, other characters will be printed, probably
nonsense (execute the program a couple times, it may work well the first time).
This is because since the second string is not ended in a char with
value \verb!zero!, \verb!printf! doesn't know where to stop printing. Aside from
this way of working with them, \verb!char! arrays work like any other array and,
when they're turned into pointers, like any other pointer. In later sections
I will show how to manipulate text strings in more advanced ways.
\subsubsection{The null pointer}
There is an special value for all the types of pointer, which is the null
pointer, or, as it is writen in the language: \verb!NULL!. It is a \verb!void!
pointer that is equal to zero. If you remember, the memory map that address
would correspond to the text section, our program can't modify itself or read
the binary instructions, among other things because part of that sextion is not
our code, but the code of operating system which inserts itself in processes to
allow us to do certain things. Hence the designers of the language used this
value to symbolize a pointer that is in a special state.

One of the most important uses of this pointer is that it is used to express if
an operation has gone well or not. For example, when we open a file with a
function called \verb!fopen!, this returns a pointer to a struct, if the file
does not exist, or the program hasn't got permissions to open it, the pointer
will be \verb"NULL". Many functions that receive a pointer use \verb!NULL! to
express an special behaviour. For ecample, let's write a function that
encapsulates the functionality of the program \ref{lst:pointNoStruct}, this has
been an exercise, so if you didn't do it yet, do it now; but we're going to
give it a twist: instead of receiving the structs, let's receive pointer to the
structs. First, because as I said you, we save ourselves copying the structs and
we can use \verb!NULL! to indicate special values.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C, label={lst:nullPointers},
caption={Use of pointers to \texttt{NULL}}]
struct point_s {
    double x; double y;
};

double distance(struct point_s *a, struct point_s *b) {
    double res = 0.0;
    struct point_s origin = { .x = 0.0, .y = 0.0 };
    if(NULL == a){
        a = &origin;
    }
    if(NULL == b){
        b = &origin;
    }
    double diff_x = a->x - b->x;
    double diff_y = a->y - b->y;
    res = sqrt(diff_x * diff_x + diff_y * diff_y);
    return res;
}

int main(void)
{
    struct point_s a = {.x = 3, .y = 4};
    double d = distance(&a, NULL);
    printf("Distance: %f\n", d);
}
\end{lstlisting}
\end{minipage}

If you look at the function we have written, inside it we declare a point that
symbolizes the \textbf{origin of coordinates}. What we do is that if one of the
pointers to the structs is \verb!NULL!, we understand that such point is
the origin of coordinates. What we do is that we assign to our arguments (which
are pointers) the direction to this local variable we have declared. Remember:
the arguments that a functions recibes are \textbf{copies} of the values. In
this case, our argument is a pointer to a struct. Assigning to our argument
other value \textbf{we are not altering the original structure}, because we
haven't changed the value our argument points to, but the argument itself. Once
this is done, we can calculate the distance in the same way we would do if they
weren't pointers. What is the use of writing a function in this way? Finding
the distance to the origin of coordinates is a common operation, doing this in
this way, we allow to the program calling the function to do such calculation
without declaring an extra struct to symbolize the origin.

\subsection{Allocate and free memory}
Now we have learnt what a pointer is, and to manage them, we can ask the
operating sistem memory of the kind that is stored in the heap and we can
manage in a more flexible way than arrays. To do so we use two functions:
\verb!malloc! and \verb!free!. The names of the functions are very descriptive,
the first means ``memory alloc'' and the second frees the memory. When you need
to reserve memory in the heap, you call \texttt{malloc} and ask for a contiguous
memory block of $n$ bytes. The function \verb!malloc! return a \verb!void!
pointer. That same pointer should, in some time, be freed passing to
\texttt{free} as its argument.

Talking about pointers to \verb!void!, I told you that \verb!void! means that
the functions either don't receive anything or don't return anything. The mean
of a \verb!void! pointer is related to that: it is a pointer that you do not
know what it is, \verb!malloc! has no way to know what you are going to do with
the memory, therefore it returns a \verb!void! pointer. A pointer to \verb!void!
is also useful when we want to write functions os structs that are compatible
with different data types. Let's see first a simple example on how to use
\verb!malloc! and \verb!free!.

One of the advantages of dynamic memory allocation occurs when a other part of
the program performs a calculation whose result has an unknown size. For
example, imagine a function that, given an array of number, returns a vector
with an instance of every dictinct number, that is, erases repetitions, let's
call it \verb!erase_reps!. Functions cannot return arrays, that's something we
already know, but the person that calls \verb!erase_reps! could declare an array
and pass it to the function, a problem arises nevertheless: we do not know
the size that array will have. Is it true that we have an \textbf{upper bound},
if we give to this function an array of $n$ positions, the result can only have,
at most, $n$ positions. So we could declare an array of $n$ positions
and tell the function to leave there the results. But there is a problem, how do
we know which part is solution and wich part is excess? The only thing you could
so is to return from \verb!erase_packets! the size of the solution. In this case
you'd have to an array of $n$ positions of which you'd use a lesser amount.
You'd be wasting memory and, even when it does not look like a problem, it may
become one very quickly.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C, label={lst:mallocAndFree},
caption={Example of dynamic allocation}]
#include <stdio.h>
#include <stdlib.h>

int *erase_reps(int* array, int array_length, int* final_length) {
    *final_length = 0;
    int preliminary_array[array_length];
    for (int ii = 0; ii < array_length; ++ii) {
        int unique = 1;
        for (int jj = 0; jj < ii; ++jj) {
            if (array[ii] == array[jj]) {
                unique = 0;
                break;
            }
        }
        if (unique) {
            preliminary_array[*final_length] = array[ii];
            ++(*final_length);
        }
    }

    int* result = malloc(*final_length * sizeof(int));

    for (int ii = 0; ii < *final_length; ++ii) {
        result[ii] = preliminary_array[ii];
    }
    return result;
}


int main(void)
{
    int array[] = { 20,1,2,3,4,5,8,7,8,9,6,6,5,4,1,2,3,8,5,4,4,5,6};
    int length;
    int* result = erase_reps(array, 23, &length);
    for (int ii = 0; ii < length; ++ii) {
        printf("%d\n", result[ii]);
    }
    free(result);
}
\end{lstlisting}
\end{minipage}

In the line 2 of code we see how the line \verb!#include <stdlib.h>! makes its
appearance, it is needed to use \verb!malloc! and \verb!free!. After it we have
the declaration of the function, we hace made it return the pointer to the
result and receive three arguments: the array from which we're erasing
repetitions, the length of such array and a pointer to integer that will allow
us to \textbf{indicate the length of the solution}. This pattern is very used in
C programs, when you need the function to calculate a lot of things, you receive
pointers to those things and write the results there. In the body of the
function we assign 0 to \verb!final_length! to start. After it, we declare a
preliminar array to save the unique numbers, why an array? Because this is not
the result, but an array we will use to save the numbers until we know how many
there are, so we will assign to this array the upper bound I mentioned before,
the list of unique numbers in an array can't be longer than the array itself.
This is also a common pattern: using an auxiliary data structure that we will
copy to another with a more proper size and definitive.

The next loop simply check, for any element of the array, is that numbers
appears before. Pay attention to the inner loop, for each $i$ element of the
array, we look at the elements before it (elements from 0 to $i$ not including
$i$). If it is, we use the variable \verb!unique! to indicate if the number has
been found before and, therefore, is not unique, so we assign this variable
value 0. After that, once we have checked all the elements before the current
one, we increment the final length and copy this number to the preliminar array.
When the length is already calculated and all the numbers are in the preliminary
array, we can use \verb!malloc! to create the final solution.

The \verb!malloc! return, as we have said, a pointer that indicates the start of
the memory zone it has reserved for us. To do so, it receives the \textbf{tamaño
en bytes} we want. And you'll see here the \lstinline[style=C]{sizeof} operator.
Yes, I have said operator, not a function. As a matter of fact, you may have
notices that no function is in blue in the code examples, and \verb!sizeof!
does. This is it is a \textbf{unary} operator that gives us the size in bytes
of a type we write next to it between parenthesis. It is also capable of
calculating the size of complex expressions, but we will see that later on.
For now, just remember that \verb!sizeof(int)! is equal to the size in bytes of
an integer. As you can see, I simply multiply the size of the integer by the
number os positions that I know they're unique. The next loop, simply, copies
from the preliminary soluction to the definitive. Finally, we return the pointer
allocated with \verb!malloc!.

In \verb!main! function we simply declare an array with several random numbers
with repetitions, we call the function on them and show the result on the
screen. You'd see that it works as it is intended. Note the use we make of the
operator ampersand to pass to the function \verb!erase_reps! the pointer to
a normal variable.

As a note, I have been using and mixing vector and array in this section and
I didn't do it casually: a vector is a contiguous memory block that stores data,
which is susceptible or growing and shrinking and that, consequently has been
reserved dinamically. An array is that data type I explained to you on its own
section. They're alike, and they share many characteristics, as a matter of
fact, but they're not exactly the same.

And now we're talking about vectors and arrays, there is a fundamental diference
between vectors or pointers and arrays. We \textbf{can ask for the size of an
array} but not of the pointers that point to vectors. And, if we can know the
size of array, why have we been using a literal value? Because I didn't want to
show you this until we could compare arrays and vectors. Before, I told you that
\verb!sizeof! gives us the size in byte of a data type or
\textbf{an expression}. The size in bytes of an array is what one would expect:
is it contains ten integers of four bytes, the size would be 40. But the size of
a pointer \textbf{is always the same}. Furthermore, the size of a pointer to any
dataype is always the same. Let's see how to use \verb!sizeof! to get the size
of an array.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C, label={lst:sizeofArraysPointers},
caption={Difference of \texttt{sizeof} between pointers and arrays}]
#include <stdio.h>
#include <stdlib.h>

int main(void)
{
    int array[] = { 12,42,53,85,45,54,11,26,21,13 };
    int array_size = sizeof array / sizeof array[0];

    for(int ii = 0; ii < array_size; ++ii){
        printf("%d\n", array[ii]);
    }

}
\end{lstlisting}
\end{minipage}

The fact that \verb!sizeof! is a operator and not a function comes into play
here. If you look at line 7, we use the operator \verb!sizeof! to get the size
of the array and divide it by the size of the firl element. Mind you that
\verb!sizeof! doesn't need to know what is \textbf{inside} the first position,
just the type of the expression (\verb!array[0]!) which would be an \verb"int".
You could use \verb!sizeof! like this over memory that is not accessible and
it won't give you any problem, because it does not read the content but only
evaluates the type of the expression.
This way, we can
easily the number of positions. Here I have assigned it to a variable so you
can see it more clearly, but you would have put this expression directly in the
\verb!for! loop. Well, knowing this, maybe you are wondering why we always
passed the lenght of array to functions if we could know it. The answer is that
we do not know it, because you must remember that, when a function gets an array
passed as argument, this decays to be a mere pointer. The good side of vector,
nonetheless, is that since we reserve them using their size, you can assign it
to a variable before doing the allocation to use it later several times.

And I still have another trick to teach you about this operator, and it is
that allows us to write the calls to \texttt{malloc} in a way it favour some
changes in the code. Imagine this call to malloc:
\lstinline[style=C]{int *vector = malloc(length * sizeof(int));}.
It is like the one we did before, but it present a little problem, if we change
the type of the vector we must be very careful to also change the type that
is inside the \texttt{malloc}, because, if not, we would be allocating less
memory than we want. Nevertheless: let's remember that \verb!sizeof! allows us
to calculate the size of expressions, so we can change the call tome something
like this: \lstinline[style=C]{int *vector = malloc(length * sizeof *vector);}.
Pay attention to it, if \verb!vector! is a pointer to \verb!int!, \verb!*vector!
would be the first element, an integer, and \verb!sizeof! will hence give us
the size of an integer (4). The advantage of this style of call is that, if we
change the type of the vector, we do not have to remember changing anything
inside \verb!malloc!.

\subsection{Pointer composition}
Now you already know the basic mechanisms of pointers, we can see some of the
examples of more complex structures made with them. For example, one of the most
interesting cases that you may encounter when programming is the pointer to
pointer to a given data type. It is equivalent to a bidimensional array, but
with dynamic memory allocation. Let0s a program in C that creates this
structure, I encourage you to compre is with the program
\ref{lst:bidimensionalArray}: \nameref{lst:bidimensionalArray}, in which we
saw the creation and use of a bidimensional array.


\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Reserva, uso y liberación de un vector de vectores},
label={lst:bidimensionalVector}]
#include <stdio.h>
#include <stdlib.h>

int main(void)
{
    int rows = 10;
    int columns = 5;
    int** matrix = malloc(rows * sizeof(*matrix));

    for (int ii = 0; ii < rows; ++ii) {
        matrix[ii] = malloc(columns * sizeof(*matrix[ii]));
        for (int jj = 0; jj < columns; ++jj) {
            matrix[ii][jj] = ii * columns + jj + 1;
        }
    }

    for (int ii = 0; ii < rows; ++ii) {
        for (int jj = 0; jj < columns; ++jj) {
            printf("%2d\t", matrix[ii][jj]);
        }
        printf("\n");
    }

    for (int ii = 0; ii < rows; ++ii) {
        free(matrix[ii]);
    }
    free(matrix);
}
\end{lstlisting}
\end{minipage}

In line 8 of the example program you can see that we declare a pointer with two
asterisks, this is because it is a pointer to pointer to integer. The pointers
can be chained indefinitely and, actually, there is no reason for it not to be
that way. If a pointer is a memory address, nothing avoids me from making this
to point to a place in memory where another address is, and so on and so forth.
Also, you can see that we allocate memory for \verb!rows! pointers to integer.
The rule to understand pointers is that the number of asterisks in the
declaration is compensated by the number of asterisks used to dereferencing, in
this way, if we declare \verb!matrix! as an \verb!int**!, \verb!*matrix! is
an \verb!int*! (two asterisks in declaration minus one in dereferencing).
Look at the simmetry, or simply count the asterisks.

In line 10 we start a \verb!for! that allocated the memory for each row of
\verb!matrix!, later, once we have allocated the memory, we fill those positions
with a value in the loop in line 12. Here simply we're making each position to
be equal to its overall position (starting in one, for a change). As you
can see, we're using square braces to index this double pointer, with breaces
it's the same that with asterisks, to if we have \verb!matrix! that is an
\verb!int**!, doing \verb!matrix[ii][jj]! we getting an int. The two nested
loops simply print the matrix.

Finally, we must free the matirx, note that this is also simmetrical with the
allocating process, if firstly we did a \verb!malloc! of \verb!row! pointers and
then each one of those were allocated with a malloc of \verb!columns! integers,
here we liberate the pointers in the reverse order, firstly we free each row and
later the matrix itself.

Like this can be confusing the first time you see it, I am going to draw the
memory map of this situation, so you have a visual image of what is happening.
Pointers are a very abstract concept, so don't worry if you do not understand
them at the first glance.

\begin{figure}[H]
    % Lo centramos
    \center
    \includegraphics[height=225mm]{double_pointer_map}
    \caption{Mapa de memoria de un vector de vectores (doble puntero)}
    \label{img:double_pointer_map}
\end{figure}

In the figure I present the memory map, on the lest there are the names those
locations have in the program, and in the rectangle I write their contents.
Arrows on the right side of the image represent the references of the pointers
to those memory addresses. Colors simply allow you to follow the different
arrows more easily. Well, if you look at where I put the tag \verb!matrix!,
you'd see it contains a memory address, this addres reference to a
\textbf{vector of pointers}, that is, \verb!rows! pointers together. Each one of
those pointers, to a contigous memory region in which the is an antire row
saved. I have only representes the first three rows, because otherwise the image
would be too big.

Now I am going to draw the figure on how would the map be in the case of a
double array, I don't include the code bcause it would be simply:
\lstinline[style=C]!int matrix[10][5]!.

\begin{figure}[H]
    % Lo centramos
    \center
    \includegraphics[width=.5\linewidth]{double_array_map}
    \caption{Memory map of a double array}
    \label{img:double_array_map}
\end{figure}

As you can see, even when the array have been declared with two dimensions,
there is not dereferenciation. That is: there is no moment in which you follow a
second pointer. How is this possible? If you look to the map, you'd see the
array is stored in a contigous memory region. This meand that C only needs to
adquiere the start direction of the array and, later, add what the indexes
inside the squere braces tell you. It's here where a problem arises when we
try to pass a bidimensional array to a function. When the array reached the
function, C doesn't know if that pointer is an bidimensional array or a vector
of vectors, that why, if you passed this array to a function that receives a
double pointer (\verb!int**!), when performing, for example \verb!matrix[1][2]!
what id would try to do is access it like it's a pointer, and would do:
\verb!*((*(matrix + 1))+2)!. That is, it would firstly add one to the base
direction (remember pointer arithmetic) and then \textbf{it would interpret the
content as a pointer} to another vector and it would try to add 2 to that vector
to dereference it. The problem is that \verb!*(matrix+1)! \textbf{is not} a
pointer, it is directly the number.

C can do this because, in the same that I explained you how the operator
\verb!sizeof! works, we can see the C knows the size of an array as long as this
does not decay to pointer, that is, you can know the size of an array in any
scope inner to the one it was declared in.

The logic conclusion of what we have just learnt is that maximun numbers of
dimensions of array that any function can get is one, because it is the one
that behaves as a pointer without problems. The fact that an array, by being
declared in a unique order, is contiguous, makes arrays able to be accessed
always a one dimensional structure. For example, in the next code we declare and
fill up an array of two dimensions and, nevertheless, we can access it like if
it had just one dimension.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Using a bidimensional array like a one-dimension structure},
label={lst:bidimensionalArrayAsOneDimension}]
#include <stdio.h>
#include <stdlib.h>

int main(void)
{
    int rows = 10;
    int columns = 5;
    int matrix[10][5];

    printf("matrix = %p\n", matrix);

    for (int ii = 0; ii < rows; ++ii) {
        for (int jj = 0; jj < columns; ++jj) {
            matrix[ii][jj] = ii * columns + jj + 1;
        }
    }

    for (int ii = 0; ii < rows * columns; ++ii) {
        printf("%d\n", (*matrix)[ii]);
    }

}
\end{lstlisting}
\end{minipage}

As you can see, once we have reached the contiguous memory region
(\verb!(*matrix)!), we only have to iterate over it like if it were a one
dimension array.

\subsection{Section exercises}
\begin{exercises}[resume*]
\item Fill up this table with different numeric bases:
\begin{table}[H]
\begin{tabularx}{\linewidth}{|R|R|R|}
\hline
\multicolumn{1}{|Y|}{\textbf{Decimal}}& \multicolumn{1}{Y|}{\textbf{Binary}} & \multicolumn{1}{Y|}{\textbf{Hexadecimal}} \\\hline
73&  &  \\\hline
   &00100110& \\\hline
&&0x12F       \\\hline
128&&         \\\hline
\end{tabularx}
\end{table}
\item Return to the code of the 9\textsuperscript{th} exercise and reproduce
the content of the stack in all the code blocks of the program. Use a code the
solution I propose in the solution section.
\item Write a program that creates a pointer of three levels of type \verb!int!,
allocates memory for it correctly and fill it up with corrleative values
\textbf{starting in one} and later on it prints is an understandable way.
Finally, free it also in a way that the is no left unfreed memory at the end of
the program.
\item Using the last program as base, create two functions, one to create a
tridimensional matrix with dynamic memory given its three dimensions and another
one to allocate it.
\end{exercises}
\section{Type modifiers: const and sign}
\label{sec:typeModifications}
Up until now we have only used basic types, but you can add \textbf{modifiers}
to those types, which are qualities that create slightly different type based on
the original one. The first and most important is the \lstinline[style=C]!const!
modifier. This allows us to indicate that the value of a variable is
\textbf{read only}, that is, once we give it value, and we must do so when
declaring it, we couldn't modify it. This is very useful to make sure we do not
introduce errors in the code when we use data that shouldn't be changed.

For example, imagine a program that use the number $\pi$. Let's say to
calculate the area of a circle, we would need to write
\verb!surface = PI * pow(r, 2)!, but imagine we make an error and write
\verb!surface = PI *= pow(r, 2)!, this error would be difficult to catch because
the first time the surface would be correctly calculated, but \verb!PI! would
have a different value because we have unwillingly used the operator \verb!*=!,
and all the later calculations would be erroneous. If we declare \verb!PI! as
a constant, the compiler could notify us about those errors.
\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Uso de una constante numérica},
label={lst:constantUsage}]
#include <stdio.h>
#include <stdlib.h>

const double PI = 3.141592;

double surface_circle(double radius) {
    return PI * radius * radius;
}

double perimeter(double radius) {
    return 2 * PI * radius;
}

int main(void)
{
    double r = 3.5;
    printf("Un círculo con un radio de %.3f tiene un perímetro de %.2f y un área de %.2f\n", r, perimeter(r), surface_circle(r));
}
\end{lstlisting}
\end{minipage}

In line four you can see how we declare \verb!PI! as a constant of type
\verb!double!. You can see, also, we are declaring it as a global variables. If
you remember when I explained the scope and what global variables are, I told
you they would be useful once we had functions. Here you can see one of the most
common uses of them, when you define universal contants, as $\pi$, $e$ or the
gravitational constant $G$. But coming back to the constant, if you try to write
an instruction that modifies the constant, the compiler would throw an error
like this one:
\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=terminalStyle]
\$  gcc -o main.exe main.c
main.c: In function 'main':
main.c:17:8: error: assignment of read-only variable 'PI'
   17 |     PI = 1.1;
      |        ^
\end{lstlisting}
\end{minipage}

But the \verb!const! modifier is applied in other place, it is used in the
declaration of arguments of functions to indicate that those cannot be modified.
Again, arguments of functions are copies of their values, so, knowing this,
it wouldn't make any sense to say we can't modify them, the core matter about
this is that the \verb"const" modifier is applied to pointers, indicating the
their content can't be modified, and this is where it is tremendously useful
when joined with functions. For example, let's go back to the function that
calculates the distance between to points using pointers, since we do not want
the structure to be modified by the function, we can do this:

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Uso de punteros constantes como argumentos de función},
label={lst:constantArguments}]
#include <stdio.h>
#include <stdlib.h>
#include <math.h>

struct point_s {
    double x; double y;
};

double distance(const struct point_s* a, const struct point_s* b) {
    double res = 0.0;
    struct point_s origin = { .x = 0.0 , .y = 0.0 };
    if (NULL == a) {
        a = &origin;
    }
    if (NULL == b) {
        b = &origin;
    }
    double diff_x = a->x - b->x;
    double diff_y = a->y - b->y;
    res = sqrt(diff_x * diff_x + diff_y * diff_y);
    return res;
}

int main(void)
{
    struct point_s a = { .x = 3 , .y = 4 };
    double d = distance(&a, NULL);
    printf(" Distance : %f\n", d);

}
\end{lstlisting}
\end{minipage}

If you look at the program, the only difference is that in the declaration we
put \verb!const! before the data type. This avoids that we modify the content
of that pointer inside the function. If you try to perform for example:
\verb!a->x++;! the compiler will throw an error. This is very useful for the
programmer that uses the function if he hasn't writen it, because that
declaration is a way to tell him that the function does not modify the data at
all. When we reach the point of writting out programs in different source files,
we will see this in more depth.

Also, the modifier \verb!const! adds the concept of \textbf{const correctness},
this concept means the programmer needs to respect the quality of contansce of
variables and arguments. This means that you must define your functions
carefully, indicating everything you can as constant. For example, in the
case of the function that calculated the distance between two points, both
arguments must be constant. But there is more, the function \textbf{can return a
constant}. This is usegul when you create structs that you do not want the user
to modify, but only with the functions you provide for that.

We will talk about this further later on, but I am going to set a basic example:
imagine a struct that saves data of a person. In this struct we would have
several pointers to \verb!char!: the name, the first surname and the second
surname (I wrote this example for Spanish names, which have two surnames). What
we will do is to create a function that receives three texts, will allocate the
necessary memory and we are going to create functions that replace those arrays
when the user of the functions needs to do so. Let's go:

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Struct with const pointers -- Managing functions},
label={lst:structConstPointers}]
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct person_s {
    char* name;
    char* last_name_1;
    char* last_name_2;
};

struct person_s person_create(const char* name,
                              const char* last_name_1,
                              const char* last_name_2) {
    struct person_s res;

    res.name        = malloc(strlen(name) + 1);
    res.last_name_1 = malloc(strlen(last_name_1) + 1);

    for (int ii = 0; ii < strlen(name) + 1; ++ii) {
        res.name[ii] = name[ii];
    }

    for (int ii = 0; ii < strlen(last_name_1) + 1; ++ii) {
        res.last_name_1[ii] = last_name_1[ii];
    }

    if (NULL != last_name_2) {
        res.last_name_2 = malloc(strlen(last_name_2) + 1);
        for (int ii = 0; ii < strlen(last_name_2) + 1; ++ii) {
            res.last_name_2[ii] = last_name_2[ii];
        }
    }
    else {
        res.last_name_2 = NULL;
    }
    return res;
}

void person_set_name(struct person_s* person, const char* name){
    free(person->name);
    person->name = malloc(strlen(name)+1);
    for(int ii = 0; ii < strlen(name) + 1; ++ii){
        person->name[ii] = name[ii];
    }

}

void destroy_person(struct person_s *person){
    free(person->name);
    free(person->last_name_1);
    free(person->last_name_2);
}
\end{lstlisting}
\end{minipage}

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Struct with const pointers -- Functions to retreive information},
label={lst:structConstGetters}]
const char* person_get_name(const struct person_s* person) {
    return person->name;
}

const char* person_get_last_name_1(const struct person_s* person) {
    return person->last_name_1;
}

const char* person_get_last_name_2(const struct person_s* person) {
    if (NULL == person->last_name_2) {
        return "";
    }
    else {
        return person->last_name_2;
    }
}

\end{lstlisting}
\end{minipage}

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Struct with const pointers -- \texttt{main} function},
label={lst:structConstMain}]
int main(void)
{
    struct person_s myself = person_create("Francisco", "Rodríguez", "Melgar");

    printf("Esta persona es: %s %s %s\n", person_get_name(&myself),
            person_get_last_name_1(&myself),
            person_get_last_name_2(&myself));

    person_set_name(&myself, "José");

    printf("Esta persona es: %s %s %s\n", person_get_name(&myself),
           person_get_last_name_1(&myself),
           person_get_last_name_2(&myself));

    destroy_person(&myself);
}
\end{lstlisting}
\end{minipage}

In this code you can see how we ``hide'' the user how we manage these pointers.
To avoid him from chaging its concent without using our functions, the functions
that return the pointers to be able to use them, for example to print them,
return constant pointers. If you tried to do, for example:
\lstinline[style=C]!person_get_name(&myself)[3] = 'a'! the compiler would throw
and error. This is a tool to avoid the user of the struct from forgetting to
free the memory when replacing a text by other.

If you're paying attention, you may have noticed that all of this is a little
bit useless when the use can simply write something like:
\verb!myself.name[0] = 'a'! and you'd be right. In later sections we would see
ways to avoid this. But, even with this problem, doing this is a good way to
save work to the user os the struct.

Another modifier I want to present to you is the sign, or better said, the
absence of sign. The keywork \lstinline[style=C]!unsigned! allows us to
declare variables and arguments of the same types of the basic types, but that
can only contain positive integers. If you do not see at first sight why this is
useful, this resides in that making a type unsigned you get a range doubled in
the possitive side. If a \verb"char" has a range of $[-127, 128]$, an unsigned
char has a range of $[0, 255]$. Also, this allows to add meaning to your
variables.

For example, a varuable that stores the size of something, for example an array,
or a vector, shouldn't have a sign, because it can never be negative. A variable
that stores a month, shouldn't either, for instance. In the case od sizes or
vectors it is important to make the variable that store their size unsigned,
because this allows us to get vectors and arrays of double the size. There are
not types without sign for floating points numbers (\verb!float! and
\verb"double"). Let's see an example on how to use the modifier \verb!unsigned!
to declare variables, arguments and return types.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Use of unsigned types},
label={lst:unsignedTypes}]
#include <stdio.h>

unsigned int factorial(unsigned int n) {
    unsigned int res = 1;
    for (unsigned int ii = 0; ii < n; ++ii) {
        res *= n - ii;
    }
    return res;
}

int main(void)
{
    unsigned int number = 10;
    printf("%d! =%d\n", number, factorial(number));
}
\end{lstlisting}
\end{minipage}

I know it looks a bit cumbersome to write unsigned each time, later on we will
see how to solve this.
\subsection{Exercises of the section}
The most appropiate exercise is for you to revise all the exercises we have done
and rewrite having into account the const quality and the sign.

\section{Communicating your program}
At last, we're reaching the part of the manual where you can communicate your
program with things outside it, up until now, all the data we have introduced in
the program are writen as literals. This is very impractical, generally, a
program will read, either from the terminal or from a concrete file, the data
it is going to use. There three sources of external information for a program:
\begin{enumerate}
    \item Arguments from the command line.
    \item Input from the terminal.
    \item Files
\end{enumerate}

The first thing is something you do not know yet, but it's going to be very
useful. Up until now, \verb!main! function wasn't receiving any argument, but
how can it do so? If \verb!main! is the function that only acts as the entry
point for our program, who can call it with arguments? Basically these arguments
come from the command line we have executed our program with. To be able to
access them inside the program, we must declare the function \verb!main! in this
new way:

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Declaration of a \texttt{main} function that receives arguments},
label={lst:mainArguments}]
int main(int argc, const char** argv) {
// ...
\end{lstlisting}
\end{minipage}

Of these two arguments of the function, the first one is the number of arguments
the program has
received, and the second is a vector of vectors of \verb!char! that is sent to
us as a two-level pointer. The arguments that a program receives come in text
format so, if they're numbers, you must use extra functions to turn them into
those data types. Let's make a program that receives an undeterminated number
of arguments and prints them in a new line.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Ussage of the arguments or a program},
label={lst:argumentProgram}]
#include <stdio.h>

int main(int argc, char const *argv[])
{
    for (int ii = 0; ii < argc; ++ii) {
        printf("%s\n", argv[ii]);
    }
}
\end{lstlisting}
\end{minipage}

Maybe you're wondering how we can pass those arguments to the program, after the
path of the executable, you write all the arguments separated by space, por
example:
\begin{lstlisting}[style=terminalStyle]
\$./main.exe argument1 argument2 argument3
\end{lstlisting}
If you compile the program and execute with those arguments, it will print this:

\begin{lstlisting}[style=terminalStyle]
./main.exe
argument1
argument2
argument3
\end{lstlisting}

And yes, as you can see, the first argument is the command you called the
program with, and this is important because, as you may deduct, this means
that your programs always receives at least one. This first argument changes
according to the order you executed your program with, for example, if instead
of with that path you'd execute it with an absolute path, you'd get the
following.

\begin{lstlisting}[style=terminalStyle]
\$ /home/usuario/test/project/main.exe arg1 arg2 arg3
/home/usuario/test/project/main.exe
arg1
arg2
arg3
\end{lstlisting}

As a last note, if the space is the character that separates the arguments, how
do we write arguments with spaces in them? Simply surround the argument between
straigt quotes (like C strings). Let's see an example.
\begin{lstlisting}[style=terminalStyle]
\$ ./main.exe "This is a double quote: \"" \"\"\" "Sentence with spaces"
./main.exe
This is a double quote: "
"""
Sentence with spaces
\end{lstlisting}

If we need to read a number, we must use, as we said before, a function that
turns the text into a number. The basic function to do this is \verb!atoi!
(from ASCII to integer). For example, let's create a program that receives a
series of numbers and adds them up.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Program that adds its arguments},
label={lst:sumArgs}]
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char const* argv[])
{

    int total = 0;

    for (int ii = 1; ii < argc; ++ii) {
        total += atoi(argv[ii]);
    }

    printf("The addition of the arguments is: %d\n", total);
}
\end{lstlisting}
\end{minipage}

Mind that we start adding from the second argument (position one in the vector)
because the first one is not a number. This leads me to warn you that
\verb!atoi! is a very basic function and that if you pass something to it that
it not a number, it will return nonsense values, many times zero. So be careful
about this. Anyway, in other sections we will see ways to manipulate text
strings that are more complex and would allow us to check it. If would be an
intereting exercise that you made a program that checks if a text string is a
number or not. Finally, there is also \verb!atof! that does the same, but to
floating point number.

Another option is to allow the user to write things into the program once
it has started. For example, we could so a program that is a 2.0 version of our
first \textit{Hello, World}. This version would first ask the name of the user
and then say hello to him personally. You can use the function \verb!scanf!
to do so. This function is the twin of \verb!print! because it behaves in the
same way, you specify a format and pass the variable you need to it where it
will store the data. For example, let's make this \textit{Hello World 2.0}

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={\texttt{scanf} basic example},
label={lst:basicScanf}]
#include <stdio.h>
#include <stdlib.h>

#define NAME_LENGTH ((size_t)1024)

int main(int argc, char const* argv[])
{

    char name[NAME_LENGTH] = "";
    printf("Hello, what's your name?\n");
    scanf("%s", name);
    printf("Nice to meet you, %s.\n", name);
}
\end{lstlisting}
\end{minipage}

As you can see, it's easy, but you must be aware that if you read basic types
you must pass the pointers to the variable your want to store them in to
\texttt{scanf}. With this \verb!char! pointer it's less evident. Also, unless
you call other functions to change how the terminal behaves, \verb!scanf! will
only read up until the first whitespace character. That is, until the first
space. This means that if you want to read several words at the same time you
must call \verb!scanf! several times or call it with several format specifiers.
Let's see a bit more complicated example.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={\texttt{scanf} advanced example},
label={lst:scanfExample}]
#include <stdio.h>
#include <stdlib.h>

#define NAME_LENGTH ((size_t)1024)

int main(int argc, char const* argv[])
{

    char name[NAME_LENGTH] = "";
    int age = 0;
    double height = 0.0;
    printf("Hello, I want to get to know you, tell me your name, age and how tall are you in meters.\n");
    scanf("%s %d %lf", name, &age, &height);
    printf("Nice to meet you, %s. So you're %d years old and are %f m tall.\n", name, age, height);
}
\end{lstlisting}
\end{minipage}

As we said, \verb!scanf! stop reading in the first space, so your can write each
data and hit enter or write the three answers separated by spaces and hit enter
just once. Also, note that, as you want to read a \verb!double! we must the
specifier \verb!%lf!, the
compiler would warn us this is not right if we used \verb!%f!. This function
\textbf{blocks} the program until is receives \textbf{all} the arguments we're
asking for with the specifiers. Also, what is written in the terminal and does
not get used (is read with \verb!scanf!) stays there pending to be used. That
is, if instead of writting our example with just one call to \verb!scanf! we
wrote three calls, each one with one specifier and variable, the effect would be
the same. You could still write the three things separated by spaces and hit
enter. In the same way that \verb!atoi!, if the specifiers expects a number and
the input is not a number, the function will fail throwing values with little to
no sense.

Finally, the files. Programs can delete, create, write and read from files.
To do this, there several ways, some more simple than others, because some are
more standard and other depend on the operating system. In opposition to the
other methods, files have a more complex life cycle. Life cycle in this context
refers to the description of when something starts to exist, exists and ceases
to do so. For example, the life cycle of a dynamically reserved memory block
is the moment of their allocation to the moment it's freed, the one of an array
goes from the moment you go into the block of code it's declared to the moment
the program stops executing in that block. Files behave in a similar way:

Files are a concept that, again, the operating system manages, therefore we have
to use functions to open, write, read from them and, finally, close them. If you
have been paying attention, you may have seen the parallelism between this and
memory allocation. The function to open a file is \lstinline[style=C]!fopen!,
let's see its declaration.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={\texttt{fopen} function declaration},
label={lst:callocSignature}]
FILE *fopen(const char *pathname, const char *mode);
\end{lstlisting}
\end{minipage}

It return a pointer to a type called \verb!FILE!, this type is \textbf{opaque},
this a word that it is used in computer science to say that you can't know that
is inside, that is, it is the system who manages it and you only interact with
it callinf the functions it provides you. The arguments this functions receives
are two \texttt{char} pointers. The first one is the path to the file. This path
takes as origin \textbf{the working directory} of the terminal where we
executed the program. That is, if you pass to the function the path
\verb!./file.txt!, it will look for it (or create it, depending on how the
function was called), in your working directory, no in the one the program is
in, unless they're the same.

The second argument is interesting, it is, as its name says, the mode in which
we're opening the mode. In this argument you tend to write a literal that
contains a series of letters, these letters are the attributes of the way you're
going to open the file. Let's see which options we have.
\begin{enumerate}
    \item \verb!r!: Open the file just to read it, the reader head (more on this
    later) is at the
    start of the file. If the file does not exist, an error occurs and the
    function return \verb!NULL!.
    \item \verb!r+!: Same as before, but it allows to write too.
    \item \verb!w!: \textbf{Empties} the file or creates it if it doesn't exist.
    The reading head is at the start, logically.
    \item \verb!w+!: Like the last one, but allows to read too.
    \item \verb!a!: Open the file to write on it, but \textbf{it does not empty
    it}. It creates it if it doesn't exist, the head start at the end of the
    file, to \textbf{append} data to it.
    \item \verb!a+!: The file is created is it does not exist, data will be
    writen to the end of the file. It also allows reading.
\end{enumerate}

In the description of the options I talk about something called the reading or
writting head, also called read/write pointer. It is not a C pointer or anything
like that. It is a concept inherent to files. The read/w head is an abstraction
of a physical devide that is in a point of the file and writes or reads to it.
Files are just a stream of bytes, and this head would write or read from the
position it is in, and advance as many bytes as it read or wrote. The methaphor
that was used was a video tape. If you put a tape in a video player, the head
would start at the begining of the tape, if you watched let's say ten minutes
of it, you could pause it, go do something and come back, it will be where you
left it. You could rewind it, fast forward it, etc. Also, playing the video
makes the head move forwards, that is: reading makes you rewind if you want
to go back. All this being said, the read/write header is unique \textbf{per
file and process}, this means that to programs can be reading or writting from
the same file at the same moment. When you reach the end of the file you can't
read more (logically) but if you're writting, the file would grow seamlessly.

Now you already know how to open a file, let's see how to write or read to and
from it. The functions that are used to do this are these two: \verb!fwrite!
and \verb!fread!

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={\texttt{fread} function signature},
label={lst:freadSignature}]
size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);
\end{lstlisting}
\end{minipage}

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={\texttt{fwrite} function signature},
label={lst:fwriteSignature}]
size_t fwrite(const void *pt, size_t size, size_t nmemb, FILE *stream);
\end{lstlisting}
\end{minipage}

The two functions behave more or less the same, they receive a pointer, a size,
another number a finally the pointer to the struct that symbolizes the file.
The first pointer is the input to write and the output to read. It is where we
will put our data, or the memory so the function can write the content
of the file in it. It is a \verb!char! pointer, which is the kind of pointer
used when you want to manage a generic stream of bytes. Both functions are
writen with the idea of managing a number of items of a certain size in
bytes, that's why we have \verb!size! and \verb!nmemb!. The first one is the
size of the items we're writting or reading and the second the number
of said items we're reading or writing. The function returns the number of
\textbf{items} written or read, not the number of bytes, mind this when
using the functions.
More on this in the examples later on.

Finally, after doing what you want with the files you have opened, you must
close it. Closing the files makes all the changes you have done to it to be
written with the underlying storage device. This is important, if you forget to
close a file you may see the changes you've done in your program are not
in the real file. The function to close files is called \verb!fclose! and its
signature is like this:

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={\texttt{fclose} signature},
label={lst:fcloseSignature}]
int fclose(FILE *stream);
\end{lstlisting}
\end{minipage}
As you can see, it only receives the pointer to the file we can to close.

Now we have shown the functions that are needed, let's an example on how to use
files. A very usual program is one that copies a files from one directory to
another, like the command \verb!cp!, which is the one used in Linux to do so.
Let's make a program that receives two arguments, the first one would be the
file we want to copy and the second the folder we want to copy it to. The Linux
command allows the use to specify a folder as destiny, but to make things
simpler we will make this program to ask for a full path (name of the destiny
file) included.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Example of basic file management},
label={lst:fileBasic}]
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char const* argv[])
{

    FILE *origin_file  = NULL;
    FILE *destiny_file = NULL;
    char byte          = 0;

    if (argc < 3) {
        printf("Use: main.exe <origin> <destiny>\n");
        return EXIT_FAILURE;
    }

    origin_file = fopen(argv[1], "r");

    if (NULL == origin_file) {
        printf("ERROR: The origin file doesn't exist.\n");
        return EXIT_FAILURE;
    }

    destiny_file = fopen(argv[2], "w");

    if (NULL == destiny_file) {
        printf("ERROR: The destiny file doesn't exist.\n");
        fclose(origin_file);
        return EXIT_FAILURE;
    }

    while (0 != fread(&byte, sizeof(char), 1, origin_file)) {
        fwrite(&byte, sizeof(char), 1, destiny_file);
    }

    fclose(origin_file);
    fclose(destiny_file);
    return EXIT_SUCCESS;
}

\end{lstlisting}
\end{minipage}

As you can see, we have declared two variables of the pointer type to
\verb!FILE!, we initialize them to \verb"NULL" and start the program. When you
receive arguments it is adviceable to parse them first, because if they are not
correct, there is no purpose in continue with the program. After that, we try to
open the origin file, note that we open it just to read it and without emptying
it, logically. If that call fails, the value it return would be \verb!NULL! and
we check this is not the case before continuing. We do the same with the destiny
file, but this one is opened with the option \verb!r! that will empty the file if it
exists and create it if it does not. Notice that, in case of error, we need to
close the first file we
opened before exiting the program (returning from function \verb!main! ends the
program). Finally, we use a loop to read byte by byte the origin file and write
it in the destiny. As you can see, the loop condition is that it will keep
looping as long as the reading function return anything that is not zero.
This is like so because both \verb!fwrite! and \verb!fread! return the number of
items they have writen or read. In this case, when \verb!fread! returns zero it
is there is no more to read.

I am going to take some time explaining the return value of the functions, as
we said before, we pass to both \verb!fread! and \verb!fwrite! a size and a
number if items we want to read or write. This would allow us for example to
write or read a certain number os structs whose size we could know with
\verb!sizeof!. The return value is the number os \textbf{items} read, not the
number or bytes. When writting a stream of bytes directly, simply indicate that
the size is one and the \verb!nmemb! is the numbers of bytes.

You may be thinking that write a program like this that reads one byte at a time
is a bit inefficient, and you're right. Each call to a function that manages
things that are handled by the operating system is relatively costly, so it is
intelligent to minimize them. In this case, we could read all the first file in
memory and then close it and write it in the second, in just one order. The
problem with this is that if you tried to cpy a 12~GB file it's probable that
you fill all the memory in the computer, in which case it simply hangs or closes
the program. To avoid both extremes, what is done often is to read a block of
a sensible size (for example 100~MB) and write it, and repeat until the process
is done.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Example of file copying with a buffer},
label={lst:readWithBuffer}]
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char const* argv[])
{

    const size_t BLOCK_SIZE   = (size_t)(1024 * 1024);
    FILE*        origin_file  = NULL;
    FILE*        destiny_file = NULL;
    char*        buffer       = malloc(BLOCK_SIZE);
    size_t       bytes_read   = 0;

    if (argc < 3) {
        printf("Use: main.exe <origin> <destiny>\n");
        return EXIT_FAILURE;
    }

    origin_file = fopen(argv[1], "r");

    if (NULL == origin_file) {
        printf("ERROR: The origin file does not exist.\n");
        return EXIT_FAILURE;
    }

    destiny_file = fopen(argv[2], "w");

    if (NULL == destiny_file) {
        printf("ERROR: The destiny file does not exist.\n");
        fclose(origin_file);
        return EXIT_FAILURE;
    }

    while (0 != (bytes_read =
                     fread(buffer, sizeof(char), BLOCK_SIZE, origin_file))) {
        fwrite(buffer, sizeof(char), bytes_read, destiny_file);
    }

    fclose(origin_file);
    fclose(destiny_file);
    free(buffer);
    return EXIT_SUCCESS;
}
\end{lstlisting}
\end{minipage}

The only change is that instead of a single \verb!char! we declare a vector of
them with the size defined in a const variable and, later on, in the copy loop,
instead of copying always one byte, we try to read the block size and, when
writting it, we use the value returned from the read operation. I want to take a
moment in this line because it's a bit different from what we have seen up until
now. An assignment is an expression with a value. This is what allows us to do
things like: \verb!a = b = c!. Thanks to this property, you can compare the
result of an assignment to another value. In this case we could save writing the
comparison because putting a number in an if is the same that checking it is not
zero.

This is a basic use of reading and writing, but anochet thing that is done often
is \textbf{move the read/write pointer} without reading or writing. For example,
imagine that we want to print a file in reverse order. We are in the same
predicament as before, we could read all the file and then invert it, but it is
a problem again if the file is too big. We could do the same we did before, read
the file piece by piece, invert the pieces and then put them all together, also
in a reverse order. This is complicated, thanks to the fact we can move the
read/write pointer, we can read directly the blocks in reverse order.


\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Example of use of functions to move the read/write pointer},
label={lst:fseek}]
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define BLOCK_SIZE ((long) 100)

void invert_bytes(char* stream, int length)
{
    for (int ii = 0; ii < length / 2; ++ii) {
        char temp = stream[ii];
        stream[ii] = stream[length - 1 - ii];
        stream[length - 1 - ii] = temp;
    }
}
int main(int argc, char** argv)
{
    long  current_pos = 0;
    FILE* file = NULL;
    if (argc != 2) {
        printf("Uso del comando: main.exe <archivo>\n");
        return EXIT_FAILURE;
    }
    file = fopen(argv[1], "r");

    if (NULL == file) {
        return EXIT_FAILURE;
    }

    fseek(file, 0, SEEK_END);
    current_pos = ftell(file);
    while (current_pos != 0) {
        char block[BLOCK_SIZE + 1] = {};
        long next_pos = 0;
        long block_size = 0;
        if (current_pos - BLOCK_SIZE < 0) {
            next_pos = 0;
            block_size = current_pos;
        }
        else {
            next_pos = current_pos - BLOCK_SIZE;
            block_size = BLOCK_SIZE;
        }
        fseek(file, next_pos, SEEK_SET);
        fread(block, 1, block_size, file);
        fseek(file, -block_size, SEEK_CUR);
        invert_bytes(block, block_size);
        printf("%s", block);
        current_pos = ftell(file);
    }
    fclose(file);
    printf("\n");
}
\end{lstlisting}
\end{minipage}

The program is not a bit complicated, but, as always, we will explain it little
by little. The first thing we do is to define a function that can reverse the
bytes of a vector. It is not the main matter in this example, but remember the
algorithm because it is a classic. What we want to do starts right after, it is
a bit complex, but I am interested in you seeing what the functions that move
the head do. Up until line 27 the only thing we do is something you're already
used to see: we process the arguments and open the file, checking everything has
gone well. After that we use the function \verb!fseek! that allows us to
\textbf{move the read/write pointer}, concretelly, we move it to the end of the
file. Let's see how it work.

This function allows us to move the head to a point in the file with an offset.
There are three points you can use as reference for the offset.
\begin{enumerate}
\item \verb!SEEK_SET!: The start of the file.
\verb!fseek(100, SEEK_SET);! would set the head to be in the
100\textsuperscript{th} byte of the file. When using this point, you cannot use
negative offsets, logically.
\item \verb!SEEK_CUR!: It is the current position, you can use negative of
positive displacements For example: \verb!fseek(100, SEEK_CUR);! could be used
in a loop to read the bytes 100\textsuperscript{th},
the 200\textsuperscript{th}, the 300\textsuperscript{th}...
\item \verb!SEEK_END!: It is the end of the file, for example if you wanted to
go to the third byte from the end you'd perform: \verb!fseek(-3, SEEK_END);!
\end{enumerate}

In line 29 what we do it go directly to the end of the file. After that, we use
another function called \verb!ftell!. This functions give us the current
position in the file as a number. That is how we know where we are. After that
we check if there is a whole block of data left. If we can, we use that block
size, if not, we use what we can. After that, we displace the head to the
position we have calculated, and read the amount of bytes we calculated. We read
and \textbf{displace the pointer back again} as many bytes as we read. After
that we call the function that inverts the bytes we have read. After that,
we update the variable that tell us where we are. Once we arrive to the first
position of the file, we know we hace finished. You must be careful,
\verb!fseek! only works when it is possible to move the pointer to the place you
tell it to. When it is not possible, it doesn't move the pointer and gives an
error (return -1). Finally, we close the file and print a new line so the prompt
shows in the next line.

We haven't used it in the example, but you can \textbf{delete} files. To do so
we use the function \verb!remove!, whose signature is:

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={\texttt{remove} function signature},
label={lst:signatureRemove}]
int remove(const char *pathname);
\end{lstlisting}
\end{minipage}

As you can see, it simply receives a path. Let's see an example of a simple
program that makes use of it: one that receives as an argument a path and
deletes it.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Example of a program that uses \texttt{remove}},
label={lst:exampleRemove}]
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char const *argv[]) {
    if (argc != 2) {
        printf("Usage: ./main <path to the file>");
    }

    int error = remove(argv[1]);

    if (error == 0) {
        return EXIT_SUCCESS;
    } else {
        return EXIT_FAILURE;
    }
}
\end{lstlisting}
\end{minipage}

As you can see, the program is very simple, I call remove with the first
argument (after the name of the program) and check is it has gone well.

\subsection{Exercises of the section}
\begin{exercises}[resume*]
\item Write a program that receives a set of number as arguments and prints
their decomposition in prime factor, for example, if the arguments were:
10, 8, 55 y 103, the result would be:

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{verbatim}
Factors of
10: 2, 5
8: 2, 2, 2
55: 11, 5
103: 103
\end{verbatim}
\end{minipage}

It is recommended to make error control, checking the arguments are numbers
before using them, etc.
\item Write a program that reads \textbf{from terminal} a series of words and
that only stops reading when you introduce ``!!'' as a word. After that, it
must print said words in a random order. The function \verb!rand! returns a
random number between zero and the biggest possitve integer, you need it to
generate random numbers. If you want the random numbers to be different from
one execution to the other, simply put this line: \verb!srand(time(NULL));! at
the begining of your program. If you decide to do this too, you need to add
the line \verb!#include<time.h>! just after the \verb!#include<stdio.h>! line.

\item Make a function that reads two files and \textbf{swaps} their content,
write said program in such a way that there is no need to store any of the files
in memory completely. To do this you may follow these steps.
\begin{enumerate}
    \item Copy the contents of the first file to an auxiliary file in
    \verb!/tmp/!.
    \item Close the file you have copied.
    \item Open it again with a mode that deletes the contents.
    \item Copy the contents of the second file to the first.
    \item Close the second file.
    \item Open it again with a mode that deletes its content.
    \item Copy the content of the auxiliary file to the first file.
\end{enumerate}

\item Write a function that receives a word as an argument and indicates
in which position (in bytes) a word is in a file. Return just the position of
the first ocurrence, if the word does not exists, return a negative number.
Write a program that, with that function, receives a path and a word as
arguments and prints the result of searching for the word in the file.
\end{exercises}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Cómo escribir programas legibles y claros}
Todos los lenguajes de programación tienen un grado mayor o menor de
\textbf{legibilidad}. Se entiende por esto lo sencillo que es para programadores
que lean código en este lenguaje entender rápidamente qué está haciendo ese
código fuente. No es el lenguaje que se usa lo único que afecta a la
legibilidad, cómo se escriba en él afecta mucho a la legibilidad. Algunos
consejos para aumentar la legibilidad son:
\begin{enumerate}
\item Utiliza nombres de variables significativos, es decir, en vez de \verb!a!,
llama a las variables cosas como \verb!length!, \verb!days! o algo que tenga
que ver con su significado.
\item Utiliza nombres de función que expliquen lo que hace la función, del mismo
modo, utiliza nombres de argumentos que indiquen qué son.
\item Escribir el código tabulando cada bloque de código nuevo, etc.
\end{enumerate}

Además, en C hay dos herramientas de vital importancia para aumentar la
legibilidad del código que ahora te voy a presentar. Una es la palabra
reservada \lstinline[style=C]!typedef!. Esta palabra reservada nos permite
\textbf{darle nombre a un tipo de dato}. Es decir, nos permite poner otros
nombres a tipos que ya existieran. Uno de los usos más prácticos de él es que
nos permite definir un tipo con una sola palabra para referirnos a una
estructura, así nos ahorramos el hecho de escribir \verb!struct mystruct_s!,
no me dirás que no es un alivio después de tantos programas llenos de la palabra
\verb!struct!. Veamos un programa ejemplo de esto:


\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Definición de un tipo a partir de una estructura},
label={lst:structTypeDefinition}]
#include <stdio.h>

struct point_s {
    double x;
    double y;

};

typedef struct point_s point_t;

int main(void)
{
    point_t p = {.x = 3.3, .y = 1.1};
    struct point_s q = { 1,3 };
}
\end{lstlisting}
\end{minipage}

Esta sería la sintaxis más explícita para hacer esto, hay otra alternativa que
veremos ahora.
En las líneas 1 a 4 no hay nada nuevo, simplemente declaramos la estructura,
es la línea 6 la que es clave, como puedes ver, usamos la palabra
\verb!typedef! para definir que el tipo \verb!struct point_s! se va a llamar
ahora también \verb!point_t!. Nota que, como se ve en la línea 14, podemos
seguir usando el nombre antiguo de los tipos. Todo sea dicho, salvo que quieras
expresar un significado distinto, es lo mejor usar siempre el mismo nombre para los
tipos. Hay una manera más abreviada para hacer esto, de hecho, dos, puedes
combinar la sentencia \verb!typedef! en una única línea con la creación del
\verb!struct!. Al hacer esto, puedes elegir ponerle nombre a la estructura o no,
porque su nombre <<real>> será el que definas en el \verb!typedef!. Veámoslo:


\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Diferentes combinaciones de \texttt{struct} con \texttt{typedef}},
label={lst:structTypeCombo}]
#include <stdio.h>

typedef struct point_s {
    double x;
    double y;

} point_t;

typedef struct {
    point_t center;
    double radius;
} circle_t;

int main(void)
{
    struct point_s p = { 1.1, 2.3 };
    point_t        q = { 1.2, 3.4 };
    circle_t  origin = { .center = {.x = 0, .y = 0}, .radius = 1 };
}
\end{lstlisting}
\end{minipage}

Las dos declaraciones de estas dos estructuras son equivalente en el hecho
de que les asignan un nombre simple: \verb!point_t! y \verb!circle_t!, pero con
un matiz: la estructura punto conserva su nombre de \verb!struct!, por lo que
se podría utilizar para declarar variables de su tipo como se ve luego, al
\verb!struct! círculo no le hemos puesto nombre de estructura, sólo lo hemos
usado para definir un tipo. Esto es más simple, pero tiene un problema, cuando
haces esto y el compilador necesita decirte que ha habido un error, será
distinto dependiendo de la técnica que utilices. Con la estrutura
\verb!circle_t!, si declaramos una función que recibe un argumento de este tipo
y la llamamos con un tipo distinto, provocando un error, el mensaje del
compilador será:

\begin{lstlisting}[style=terminalStyle]
main.c:14:18: note: expected 'circle_t' {aka 'struct <anonymous>'} but argument is of type 'int'
   14 | int foo(circle_t c){
\end{lstlisting}

Como puedes ver, te dice el nombre que tiene el tipo, y después intenta
explicarte qué tipo era originariamente, el problema es que como hemos definido
la estructura sin nombre, no tiene nada que decirnos, es un \verb!struct!
anónimo. Y te estarás preguntando que todo esto cómo puede ser, bueno, es porque
en C puedes declarar estructuras sin nombre con una variable para usarlas
y tirarlas. Te lo voy a enseñar, pero es algo que no he visto en código
profesional, así que, como el \verb!goto!, interioriza que existe, pero sería
mejor que no lo usaras.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Estructura anónima y efímera},
label={lst:anonymousStruct}]
#include <stdio.h>


int main(void)
{
    struct { double x; double y; } temporal_point = { .x = 1, .y = 2 };
    printf("Esto es un punto temporal que está en [%1.2f, %1.2f]\n", temporal_point.x, temporal_point.y);
}
\end{lstlisting}
\end{minipage}

Es por eso que podemos definir \verb!struct! que no tienen nombre y usar ese
\verb!struct! anónimo para definir un tipo. Mi consejo es que siempre le pongas
nombre a los \verb!struct! para evitar que el error del compilador sea más
difícil de leer. Compara ese error del compilador que te he presentado antes con
éste para la estructura punto que sí tenía un nombre independiente del
\verb!typedef!.


\begin{lstlisting}[style=terminalStyle]
main.c:13:18: note: expected 'point_t' {aka 'struct point_s'} but argument is of type 'int'
   13 | void foo(point_t p){
      |          ~~~~~~~~^
\end{lstlisting}

Terminando ya con este tema: si te fijas, siempre que le he puesto nombre a una
estructura, lo he terminado con \verb!_s!, y siempre que he hecho un
\verb!typedef!, lo he terminado con \verb!_t!. Esto es una convención, es decir,
es algo que los programadores hacemos por tradición, pero no es obligatorio,
ni el compilador ni ningún analizador de código te dirán que esto está mal
(salvo que, claro, los hayas configurado para seguir la convención). El subfijo
\verb!_s! es menos importante, pero sí te recomiendo encarecidamente que
termines todos los tipos que definas con \verb!typedef! en \verb!_t!, primero:
porque es muy común, lo hace casi todo el mundo y, segundo: porque los editores
entienden que cualquier identificador (nombre, vaya), que termina en \verb!_t!
es un tipo, y lo utilizan para darte pistas sobre qué es cada cosa, por ejemplo,
los editores de texto colorearán todos los identificadores terminados en
\verb!_t! del color de los tipos en ese editor.

Aparte de esta utilidad tan cómoda para nosotros, hay otra, sirve para renombrar
tipos básicos, por ejemplo, podemos renombrar el \verb!char! sin signo como
\verb!byte_t!. Así si utilizamos nuestro programa para manejar listas de bytes
podemos usar este tipo y el lector de nuestro código sabrá de qué estamos
hablando.


\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Redefinición de un tipo básico},
label={lst:typedefBasicType}]
#include <stdio.h>

typedef unsigned char byte_t;

void print_byte(byte_t b) {
    byte_t current_byte = 128;
    for (int ii = 0; ii < 8; ++ii) {
        printf("%d", (b & current_byte) != 0);
        current_byte /= 2;
    }
    printf("\n");
}

int main(void)
{
    print_byte(110);
}
\end{lstlisting}
\end{minipage}

Quizá no entiendas todo este código, la línea 8, concretamente, pero simplemente
observa cómo al utilizar un tipo concreto, se lee todo mucho mejor. Además,
nos ahorramos escribir \verb!unsigned! múltiples veces.
Del mismo modo que con el
modificador de signo, podemos definir tipos con el modificador constante, por
ejemplo: \verb!typedef const char letter_t!.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Ejemplo de definición de tipo a partir de un tipo constante},
label={lst:typedefConstType}]
#include <stdio.h>

typedef const char letter_t;

letter_t dictionary[] = { 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z' };

int pos_of_letter(letter_t l){
    for(unsigned int ii = 0; ii < sizeof(dictionary); ++ii){
        if(l == dictionary[ii]){
            return ii + 1;
        }
    }
    return -1;
}

int main(void)
{
    letter_t l = 'f';
    printf("%c es la letra número %d del diccionario.\n", l, pos_of_letter(l));
}
\end{lstlisting}
\end{minipage}

Aunque esto es posible, en general la constancia es mejor dejarla
\textbf{explícita}, es decir, definir tipos para lo que necesites, pero
escribir el modificador \verb!const! cuando sea necesario, en vez de ocultarlo
detrás del tipo redefinido.

<<Y el más difícil todavía>> decían los maestros de ceremonias de los antiguos
circos cuando los trapecistas o los payasos realizaban el truco final. Con
\verb!typedef! este truco final es que, como los arrays de distintas dimensiones
son tipos distintos, puedes definir un tipo a partir de un tipo array. ¿Qué
utilidad tiene esto? A veces un conjunto de cosas de un tamaño concreto es un
concepto en sí mismo. Dos personas juntas son un matrimonio, siete días son una
semana y una mano tiene cinco dedos. La sintaxis de esto es un poco distinta a
la que podrías pensar, pongo el ejemplo y explico por qué rápidamente.


\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Definición de un tipo personalizado a partir de un array},
label={lst:typedefArrayType}]
#include <stdio.h>

typedef unsigned char pixel_t[3];

int main(void)
{
    pixel_t pixel = { 125,33,129 };
    printf("Este pixel tiene los valores: Rojo = %hu, Verde = %hu, Azul = %hu\n", pixel[0], pixel[1], pixel[2]);
}
\end{lstlisting}
\end{minipage}

Como puedes ver, \verb![3]! se pone a la derecha del nombre del nuevo tipo, en
vez de a la izquierda, que sería lo intuitivo. Simplemente recuérdalo si quieres
hacer esto. De todos modos, al igual que con la constancia, que un tipo sea
un array es algo que es recomendable dejar explícito.

La otra herramienta para añadir significado a tus programas, semántica, es
el \verb!enum!, o tipo enumerado. Este es un tipo en C que nos permite asignar
números correlativos automáticamente a nombres, los ejemplo clásicos (tan
clásicos que casi son manidos) son los siguientes: días de la semana,
meses del año, colores del arcoíris... La utilidad de esto es que podemos
codificar fácilmente conjuntos de nombres como estos a números y utilizarlos
para iterar, para indexar arrays, etc. Veamos el ejemplo de los días de la
semana.


\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Ejemplo básico de tipo enumerado},
label={lst:BasicEnum}]
#include <stdio.h>

enum week_days {
    MONDAY,
    TUESDAY,
    WEDNESDAY,
    THURSDAY,
    FRIDAY,
    SATURDAY,
    SUNDAY
};

int main(void)
{
    printf("Hoy es: %d\n", SATURDAY);
}
\end{lstlisting}
\end{minipage}

Si compilas y ejecutas esto verás que imprime <<Hoy es: 5>>. Esto es porque
cuando escribes un enumerado así, el primer elemento recibe el valor cero, el
siguiente uno, y así sucesivamente, en este caso de cero a seis.
Y los enumerados pueden dar más de sí los combinas con arrays de tipos que
ayuden a añadir la semántica, observa:


\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Enum combinado con array de nombres},
label={lst:EnumWithNames}]
#include <stdio.h>

enum week_days {
    MONDAY,
    TUESDAY,
    WEDNESDAY,
    THURSDAY,
    FRIDAY,
    SATURDAY,
    SUNDAY
};

const char* WEEK_DAYS_NAMES[] = { "lunes","martes","miércoles","jueves","viernes","sábado","domingo" };

int is_today_weekend(int day){
    return day == SUNDAY || day == SATURDAY;
}

int main(void)
{
    for(int ii = MONDAY; ii <= SUNDAY; ++ii){
        if(is_today_weekend(ii)){
            printf("¡Es fin de semana!\n");
        }else{
            printf("No es fin de semana.\n");
        }
    }
}
\end{lstlisting}
\end{minipage}

Como puedes ver, tener el tipo enumerado nos permite que los programas sean
mucho más legibles, que es lo que queríamos, porque como puedes ver, el bucle
se lee como <<siendo \verb!ii! LUNES, hasta que sea igual a DOMINGO, si
\verb!ii! es un fin de semana, imprime que lo es, si no, no>>. Habrás notado que
tanto para \verb!ii! como para la declaración de la función utilizo el tipo
\verb!int!. Esto es porque <<por dentro>> un tipo enumerado es un tipo entero,
pero para escribir las cosas más claramente, podemos definir un tipo enumerado
como definimos un tipo a partir de un \verb!struct!.

Para ver que la legibilidad el código ha aumentado, mira cómo en la
comprobación se puede ver que se lee como <<si el día es SÁBADO o DOMINGO,
es un fin de semana>>. Pero el \verb!enum! tiene más flexibilidad, podemos
definir el valor de cada etiqueta, o, esto es más útil: definir el valor de la
primera, y las siguientes tomarán el valor correlativo correspondiente. Voy
a poner en un mismo programa un ejemplo de ambas cosas, los días de la semana
y los meses del año. El siguiente programa aúna todas las posibilidades
anteriores:


\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Ejemplo final de enumerados},
label={lst:finalEnums}]
#include <stdio.h>

typedef enum week_days_e {
    MONDAY = 2, TUESDAY = 4, WEDNESDAY = 6, THURSDAY = 8, FRIDAY = 10, SATURDAY = 12, SUNDAY = 14
} week_days_t;

typedef enum months_e {
    JANUARY = 1, FEBRUARY, MARCH, APRIL, MAY, JUNE, JULY, AUGUST, SEPTEMBER, OCTOBER, NOVEMBER, DECEMBER
} months_t;

typedef enum seasons_e {
    SPRING, SUMMER, FALL, WINTER
} seasons_t;

const char* season_names[] = { "primavera", "verano", "otoño", "invierno" };
const char* month_names[] = { "NOT USED", "enero","febrero","marzo","abril","mayo","junio","julio","agosto","septiembre","octubre","noviembre","diciembre" };
int is_today_weekend(week_days_t day) {
    return day == SUNDAY || day == SATURDAY;
}

seasons_t season(months_t m) {
    if (m >= MARCH && m <= MAY) {
        return SPRING;
    }
    else if (m >= JUNE && m <= AUGUST) {
        return SUMMER;
    }
    else if (m >= SEPTEMBER && m <= NOVEMBER) {
        return FALL;
    }
    else {
        return WINTER;
    }
}

int main(void)
{
    for (months_t ii = JANUARY; ii <= DECEMBER; ++ii) {
        printf("Estamos en %10s y es %s\n", month_names[ii], season_names[season(ii)]);
    }
}
\end{lstlisting}
\end{minipage}

He tenido que declarar los \verb!enum! en una línea para que quepa en esta
página, pero eso no afecta. Mira bien como en el caso de los días de la semana
he hecho que cada uno valga un valor arbitrario. Además, en iniciado los meses
en el valor uno, no he definido valor del resto, por lo que se sucederán
valiendo dos, tres... Esta definición tiene una implicación, en el
caso de los días de la semana ya no puedo escribir el mismo
bucle \verb!for! para iterar sobre
ellos \textbf{porque ahora sus valores no son correlativos},
sino que son arbitrarios. Además, si miras el array de
los nombres de los meses del año, he tenido que poner al principio una
posición que no se usa para que encaje.

Al contrario que \verb!typedef!, los \verb!enum! son muy situacionales, aunque,
como el \verb!do-while! o el \verb!switch!, cuando se da dicha situación son
la herramienta ideal.
\subsection{Estilo de código}
Ahora que ya hemos hablado de muchas herramientas del lenguage, es hora de que
establezcamos algunas reglas para escribir nuestros programas que he dejado
implícitas y que me gustaría empezar a escribir aquí. En este epígrafe vamos
a ver cómo deben escribirse los programas más allá de que funcionen o, incluso,
de que sean eficientes. Cuando uno trabaja en programación, hay muchos momentos
en que vas a estar más tiempo leyendo el código de otros programadores que
escribiendo código nuevo. Y, consecuentemente, debes escribir tu código con la
intención de que sea claro para otros programadores que lo lean. Vamos a ver
un ejemplo de cómo un fragmento de código puede ser trivial o indescifrable
simplemente cambiando cómo está escrito.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Ejemplo de programa escrito con un mal estilo},
label={lst:badStyle}]
#include <stdio.h>
#include <stdlib.h>
int main(void)
{
int** a=malloc(10*sizeof*a);
for(int ii=0;ii<10;++ii){
(*(a+ii))=mailloc(5*sizeof**a);
for(int jj=0;jj<5;++jj){
(*(a+ii))[jj]=10*ii+jj;
}
}
for(int ii=0;ii<10;++ii){
for(int jj=0;jj<5;++jj){
printf("%d ",(*(a+ii))[jj]);
}printf("\n");
}
for(int ii=0;ii<10;++ii){
free(*(a+ii));
}
free(a);
}
\end{lstlisting}
\end{minipage}

Intenta leer el programa \ref{lst:badStyle} y dime si sabes qué hace. Es probable
que, después de unos cinco o diez minutos, descifres que simplemente reserva un
vector de vectores, lo rellena, lo imprime y lo libera. Como puedes ver, sin
espacios, sin las líneas tabuladas (tabular las líneas es poner espacios delante
para que queden desplazadas a la derecha), sin líneas en blanco entre
estructuras de control y escribiendo algunas líneas al lado de una llave,
es imposible de
leer. Además, no hemos declarado variables o macros que nos ayuden a entender
si el mismo valor es así por casualidad o por simboliza lo mismo. Además, he
mezclado arbitrariamente operadores distintos para acceder al vector. Si
aplicamos una serie de mejoras a cómo está estrito el código, quedaría así:

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Ejemplo de programa escrito con un buen estilo},
label={lst:goodStyle}]
#include <stdio.h>
#include <stdlib.h>

typedef unsigned int uint_t;

int main(void)
{
    const uint_t ROWS    = 10;
    const uint_t COLUMNS = 5;
    int** matrix = malloc(ROWS * sizeof(*matrix));

    for (uint_t ii = 0; ii < ROWS; ++ii) {
        matrix[ii] = malloc(COLUMNS * sizeof(**matrix));
        for (uint_t jj = 0; jj < COLUMNS; ++jj) {
            matrix[ii][jj] = ROWS * ii + jj;
        }
    }

    for (uint_t ii = 0; ii < ROWS; ++ii) {
        for (uint_t jj = 0; jj < COLUMNS; ++jj) {
            printf("%d ", matrix[ii][jj]);
        }
        printf("\n");
    }

    for (uint_t ii = 0; ii < ROWS; ++ii) {
        free(*(matrix + ii));
    }
    free(matrix);
}
\end{lstlisting}
\end{minipage}
\newpage

Como pudes ver, hemos introducido varias mejoras: los operadores están rodeados
por espacios, las utilizaciones de \verb!sizeof! siempre llevan paréntesis para
que sea más legible, hemos utilizado dos macros para simbolizar el tamaño del
vector en vez de escribir cinco y diez todo el rato en el código,
hemos utilizado siempre la misma manera de acceder a los
vectores y, finalmente, hemos escrito cada instrucción
en una línea con la tabulación correcta. Veamos qué pasos o
principio hay que seguir para escribir código que sea entendible.

\subsubsection{Tabulación}
En la introducción de esta sección hemos hablado de la tabulación, y te he dicho
que es anteponer a algunas líneas espacios para que salgan desplazadas a la
derecha. Es una de las cosas que debes hacer obligatoriamente si quieres que te
tomen en serio como programador, pero hay varias variaciones sobre cómo puedes
hacerlo. La primera decisión que debes tomar es si tabulas con espacios o con
tabuladores. Un tabulador es un carácter especial que indica al editor de texto
que alinee las cosas en la siguiente columna de la pantalla. La ventaja de
tabular con ellos es que puede configurar el editor para que muestre el
tabulador como el número de espacios que más te guste. Este carácter se inserta
con la tecla tabulador, que es la que tiene este símbolo:\tiny
$
\matrix{
    \left|\leftarrow\right.\cr
    \left.\to\right|
}
$
\normalsize .
La otra opción es tabular con espacios, es decir, en vez de usar este carácter
especial, usaremos un número determinado de espacios. En general, no pulsas
varias veces la tecla espacio, sino que configuras tu editor de texto para que,
al pulsar tabulador, se introduzca el número de espacios concreto.

Esta es una de las cosas que hará que los programadores se peleen entre ellos
como fanáticos religiosos o hinchas de un equipo de balompié, por lo que la
elección es tuya. Sin embargo; mi modesta opinión es que los espacios son
mejores porque permiten alinear el código de líneas largas, por ejemplo, mejor.
Además, permiten asegurarte de que el código escrito se verá bien en todos los
entornos, porque no hay ambigüedad sobre cuánto mide un espacio.

La norma general para tabular es que los bloques de código deben tener sus
instrucciones tabuladas un nivel más que allí donde estén definidos. Puedes
observar que esto es así en todos los fragmentos de código que he incluido como
ejemplos. Cada nivel de tabulación debe ser igual al anterior, es decir, si has
elegido cuatro espacios, debes tabular siempre con cuatro
espacios, nunca mezclar, y si utilizas tabuladores, un nivel
de tabulación debe ser siempre un único tabulador.

La tabulación también entra en juego cuando una línea es demasiado larga.
Te preguntarás quizá qué sentido tiene ponerle un límite a la longitud de las
líneas si estamos usando editores de texto que nos permiten que éstas sean tan
largas como queramos. Esto es así por varios motivos: las líneas demasiado
largas suelen ser más difíciles de interpretar, impiden que tengas varios
archivos abiertos a la vez y, además, en el improbable, pero posible caso de
que quisieras imprimir tu código, sería difícil que quedase bien. El último
caso no te afecta a ti, pero me ha afectado a mí en muchos de los programas
que he escrito como ejemplos. La longitud de una líneas de código en C
normalmente viene siendo de unos ochenta caracteres. Para que te hagas una idea,
los fragmentos que he insertado en este manual contienen unos 71.

Bueno, y qué pasa si la línea que estamos escribiendo contiene más de esos
caracteres. Pues que hay maneras de escribir la línea de un modo distinto.
Esta manera cambia según dónde se dé el problema, claro, así que vamos a ver
los sitios más habituales y cómo arreglarlo.

El primer caso es cuando se utilizan funciones con muchos argumentos, o cuyos
nombres son muy largos, un ejemplo clásico de esto son las llamadas a
\verb!printf!, pero se puede dar con otras funciones. Por ejemplo: imagina un
programa que imprime un mensaje un poco largo para el usuario, podría quedar
así:

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Impresión larga},
label={lst:longprint}]
#include <stdio.h>
int main(void)
{
    printf("Este es un mensase importante, por favor, mantente hidratado, bebe agua\n");
}

\end{lstlisting}
\end{minipage}
Como puedes ver, la línea no cabe en la pantalla, lo que se hace en estos
casos es separa la constante de \textit{string} en varias. Siempre que las
escribamos juntas o separadas sólo por espacios y líneas nuevas, C las tomará
como una continua. Veamos cómo quedaría:

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Impresión larga},
label={lst:longprint}]
#include <stdio.h>
int main(void)
{
    printf("Este es un mensase importante, "
           "por favor, mantente hidratado,"
           " bebe agua");
}
\end{lstlisting}
\end{minipage}
Nota que, aunque las separemos, debemos incluir los espacios entre palabras.
Cuando se dividen así cadenas de texto, se suelen poner todas al mismo nivel
de tabulación.

El siguiente ejemplo es una función con muchos argumentos, o con argumentos
muy largos. Imaginemos un programa tal que:

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Muchos argumentos},
label={lst:manyArgs}]
int main(int argc, char** argv)
{
    int list[] = {};
    int the_position = 10;
    int* res = insert_at(list, ARRAY_SIZE(list), 0, rand());
    print_array(res, ARRAY_SIZE(list) + 1);
    free(res);
}
\end{lstlisting}
\end{minipage}

Como no me interesa lo que hace el programa, sino sólo el formato, no voy a
poner la definición de las funciones, pero la función \verb!insert_at! crea
un array nuevo con el elemento dado como último argumento en la posición que
indica el segundo. Si quisiéramos que la línea donde se llama a esa función
fuera separada en varias, lo haríamos generalmente entre los argumentos de la
llamada, veamos algunos estilos:

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Cómo acortar líneas con muchos argumentos},
label={lst:manyArgsShorting}]
//1
int* res = insert_at(list, ARRAY_SIZE(list),
                                        0, rand());

//2
int* res = insert_at(list,
                     ARRAY_SIZE(list),
                     0,
                     rand());

//3
int* res =
    insert_at(list, ARRAY_SIZE(list), 0, rand());
\end{lstlisting}
\end{minipage}

En el primer ejemplo hacemos un único corte en un argumento y ponemos
el resto de la línea un nivel de tabulador por detrás de donde estaría.
Este método es útil cuando nos pasamos del límite por pocos caracteres.
El siguiente es mi preferido y básicamente pone cada argumento en una línea
y al mismo nivel. En el último, nos aprovechamos de que estamos asignando el
resultado de la llamada, utilizamos esta operación para hacer el corte,
con una nueva línea y un nivel de tabulador hacia adentro. Los tres se pueden
combinar como quieras, pero a mí me gusta el segundo porque impide que
queden alineaciones extrañas.

La siguiente localización es la declaración de una función con muchos
argumentos, por ejemplo, una función que imprima una fecha dado el año, el
mes y el día y un argumento boleano que nos diga si lo hacemos en ese orden
y en el inverso:

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Acortamiento de una declaración de función},
label={lst:functionShorting}]
void print_date(unsigned short day,
                unsigned char  month,
                unsigned int   year,
                int            order);
\end{lstlisting}
\end{minipage}

En estos casos se suelen poner todos los argumentos en una línea distinta,
además, me he molestado en alinear los nombres de los argumentos para
que se cree una especie de tabla, lo que facilita la lectura cuando se deben
acortar así las listas de argumentos.

En otros sitios donde se pueden dar estas situaciones es en listas de varios
tipos, estoy usando la palabra listas aquí a la ligera, me refiero a
las sucesiones de cosas separadas por comas que van entre llaves:
listas de inicialización especialmente, en general puedes aplicar lo mismo que
con los argumentos en el método primero de cuando acortamos una llamada a
función.

\subsubsection{Espaciado entre símbolos}
En términos generales la mayoría de los espacios en blanco que pondremos en
nuestros programas son para facilitar esta legibilidad, porque C es un lenguaje
diseñado para que los espacios en blanco no importen. Normalmente,
los operadores matemáticos, lógicos o de cualquier tipo deben ir rodeados de
espacios, es decir: se prefiere \lstinline[style=C]!a = b + 10;!
que \lstinline[style=C]!a=b+10;!,
rodea el operador de asignación y la suma de espacios. Las excepciones a esto
son los operadores unarios (la negación lógica, el asterisco de
desreferenciación de punteros, etc.). Además, en las declaraciones, el asterisco
debe estar siempre pegado o al tipo de dato, o al nombre de la variable. Es una
cuestión de estilo, pero yo recomiendo que se adhieran los asteriscos al nombre
de la variable, o, en su caso, del argumento de la función.
Es decir:
\begin{enumerate}
\item Espacia los operadores: \lstinline[style=C]!int var = a * 3 + ii!
\item Los asteriscos deben ir pegados a las variables a las que afectan, en
declaraciones y desreferenciaciones:
\begin{enumerate}
\item \lstinline[style=C]!double *var1;!
\item \lstinline[style=C]!int function(int *arg1, void **arg2);!
\item \lstinline[style=C]!int a = *ptr1 + *ptr2;!
\end{enumerate}
\end{enumerate}

Además, después de todas las comas que haya en listas de inicialización,
de los puntos y coma de los bucles \verb!for! o de los argumentos de una función
debe haber una coma y un espacio debe rodear los paréntesis de estructuras
de control (nota: llamada a función no es una estructura de control), es decir:

\begin{enumerate}
\item \lstinline[style=C]!for (int i = 0; i < 10; ++i)!\verb! {!
\item \lstinline[style=C]!int list[] = {1, 2, 3, 4, 5, 6};!
\item \lstinline[style=C]!int res = pow(var1, var2);!
\end{enumerate}

\subsubsection{Estilo de las llaves}
Hay varias combinaciones de estilo de las llaves que definen los bloques de
código que componen los cuerpos de bucles, condicionales y demás estructuras
de control. Hay dos estilos fundamentales: llaves K\&R y Allman.
Las primeras se ponen en la misma línea que la estructura de control que
las necesita, es decir:

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Ejemplo de llaves estilo K\&R},
label={lst:KRBrackets}]
int main(void) {
    return 0;
}
\end{lstlisting}
\end{minipage}

Las llaves Allman se ven así:

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Ejemplo de llaves estilo Allman},
label={lst:AllmanBrackets}]
int main(void)
{
    return 0;
}
\end{lstlisting}
\end{minipage}

Hay otros estilos que combinan las tabulaciones de maneras distinta con las
llaves, pero estas son las más importantes. Una manera que se puede ver habitualmente
es que
las definiciones de funciones (que son principalmente bloques de código de
primer nivel) utilicen el estilo Allman, mientras que los bloques internos a
éstas usen el estilo K\&R. Lo más importante es que utilices un estilo o una
combinación racional de ellos y lo mantengas en todo el proyecto. En caso de
añadir código a una base existente, aplica la vieja regla de: <<donde fueres
haz lo que vieres>>, es decir, sigue el estilo que sigan en el proyecto en el
que colabores.

\subsubsection{Declaración de variables, estructuras y enumerados}
Hasta ahora, cada declaración de variable la hemos hecho en una línea distinta,
y cada miembro de una estructura también. Esto no es necesario, se pueden
declarar todas las variables de un mismo tipo en la misma línea, e incluso
inicializarse. Veamos un ejemplo sencillo. Vamos a reescribir el programa
\ref{lst:bidimensionalVector}: \nameref{lst:bidimensionalVector}, pero omitiré
parte de él porque no ha cambiado.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Declaración de variables en una misma línea},
label={lst:singleLineDeclaration}]
#include <stdio.h>
#include <stdlib.h>

int main(void)
{
    int rows = 10, columns = 5, **matrix = NULL;
    matrix = malloc(rows * sizeof(*matrix));

    for (int ii = 0; ii < rows; ++ii) {
    //resto del programa...
\end{lstlisting}
\end{minipage}

Como puedes ver en la línea 6, podemos declarar variables del mismo tipo
en la misma línea, separando sus nombres por comas. Además, podemos incluso
inicializarlas. Si vas a declarar punteros junto a variables de tipos no
puntero, el asterisco que indica que esa variable es un puntero va pegado al
nombre de la variable, como puede ver con \verb!matrix!. En el caso de la
inicialización del puntero, podría ir en la misma línea, pero lo he movido
a otra para impedir que la línea sea excesivamente larga.

En las estructuras se puede hacer lo mismo, es decir, declarar todos los
miembros del mismo tipo en la misma línea, con los enumerados también se puede
hacer, pero es convención que cada identificador de una estructura vaya en
su propia línea. Veamos un ejemplo de ambas cosas:

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Declaración de miembros de un \textit{struct} en una sola línea},
label={lst:singleLineDeclarationStruct}]
struct point_s {
    double x, y;
}

enum week_days {
    MONDAY,
    TUESDAY,
    WEDNESDAY,
    THURSDAY,
    FRIDAY,
    SATURDAY,
    SUNDAY
}
\end{lstlisting}
\end{minipage}

\subsubsection{Convenciones de nombres}
Una de las cosas más importantes es que debes evitar el uso de los llamados
\textbf{números mágicos}. Éstos son los valores literales que se incluyen en
el código y que no se explican, se asignan a una variable y, en el peor de los
casos, se usan en muchas partes del código. Si rescatas el ejemplo de mal código
del programa \ref{lst:badStyle}, verás que nunca defino variables o macros para
definir las columnas y filas de la matriz. Esto lo hago intencionadamente,
porque es una mala práctica. Como puedes ver en el ejemplo de buen código,
lo primero que hago es definir macros para estos conceptos, y, además, las
defino con un cásting añadido a un tipo concreto, para controlar de qué tipo
son, y las encierro entre paréntesis, para evitar los problemas que vimos en
la sección sobre macros.
En general, debes hacer esto, definir macros, variables y constantes para todo
concepto o valor que haya en tu código, \textbf{especialmente si aparece varias
veces}.

Además, hay una serie de convenciones que vamos a reunir aquí sobre los nombres.
Cuando te expliqué el nombre que se le podía poner a una variable, te dije de
que existían el \textit{camel case} y el \textit{snake case} para escribir
nombres con varias palabras. En C lo normal es usar el segundo, es decir:
\verb!my_var!, así que en general será el que me hayas visto aplicar. Por otro
lado, las constantes deben estar escritas en mayúscula, es decir:
\lstinline[style=C]!const int LENGTH = 10;! es preferible a
\lstinline[style=C]!const int length = 10;!, las macros siguen la misma
convención como ya habrás podido notar.

En general, los tipos terminan en \verb!_t!, como ya comentamos, ya sean estos
renombramiento de tipos básicos o creación de estructuras. A los enumerados
se les puede omitir su nombre de enumerado, es decir, es normal escribir:

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Ejemplo de tipo enumerado con typedef},
label={lst:typedefEnum}]
typedef enum {
    MONDAY,
    TUESDAY,
    WEDNESDAY,
    THURSDAY,
    FRIDAY,
    SATURDAY,
    SUNDAY
}week_days;
\end{lstlisting}
\end{minipage}

Las funciones deben tener nombres descriptivos, del mismo modo que sus argumentos,
por ejemplo, es preferible:

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Ejemplo de función descriptiva},
label={lst:descriptiveFunction}]
int multiply_array_scalar(int *array, int array_size, int scalar);
\end{lstlisting}
\end{minipage}

a

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Ejemplo de función no descriptiva},
label={lst:nonDescriptiveFunction}]
int multi(int *a, int s, int n);
\end{lstlisting}
\end{minipage}

En el primer caso queda claro qué hace la función y qué es cada argumento
con un golpe de vista. En el segundo habría que acudir a la implementación
para saber qué hace.


\section{Lo que hay detrás de la compilación}
Hasta ahora hemos dicho que crear un binario a partir de un archivo de código
fuente se llama compilar. Si bien esto es una expresión correcta, no es del todo
cierto. Hay varios procesos involucrados en lo que llamamos compilación:
\begin{enumerate}
\item Preprocesado: Prepara el código fuente para ser compilado, esto incluye
eliminar comentarios, expandir macros, ejecutar directivas y eliminar saltos de
línea.
\item Compilado: Crea el binario de cada archivo de código fuente que se utilice
en el proyecto.
\item Enlazado: Genera los binarios ejecutables propiamente dichos, para ellos
utiliza los binarios del paso anterior y crea enlaces entre ellos, ya sea
juntándolos en el mismo archivo o simplemente indicando dónde están los que
necesita.
\end{enumerate}

Esto introduce muchos conceptos nuevos que explicaré a continuación, pero lo
principal es que esta va a ser la sección en que aprendas a hacer programas con
más de un archivo de código fuente. Esto es útil porque, como has visto, en el
momento en que un programa se hace un poco complejo, empieza a hacerse confuso
subir y bajar por el fichero de código buscando lo que necesitas o modificando
cosas. Por esto, todo proyecto serio de programación en C contiene varios
archivos de código fuente. Algunos proyectos muy grandes pueden llegar a tener
hasta decenas de miles o cientos de miles de archivos de código fuente.
Voy a explicar ahora los tres procesos.

\subsection{Preprocesado}
El preprocesado es la etapa que se realiza más discretamente, porque todo
archivo de código fuente que se compile pasa primero por ella sin que tengamos
que hace nada. En la introducción de esta sección he comentado que se realizan
varias tareas, siendo la primera la eliminación de comentarios. Ya es hora de
que te explique qué son los comentarios. Un comentario es una herramienta que
nos permite introducir cualquier texto dentro del códido de tal modo que podamos
explicar cosas, apuntar datos o cosas así. Veamos un ejemplo. Voy a incluir
comentarios en el código del
programa \ref {lst:pointStruct}: \nameref{lst:pointStruct}


\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Ejemplo de definición de estructura punto},
label={lst:comments1}]
#include <stdio.h> //for printf
#include <math.h>  //for sqrt

//Definimos la estructura punto bidimensional.
struct point_s {
    double x;
    double y;
};

int main(void)
{
    struct point_s A;
    struct point_s B;

    A.x = 1.1;
    A.y = 3.2;
    B.x = 2.3;
    B.y = 5.4;

    double diff_x = A.x - B.x;
    double diff_y = A.y - B.y;
    /*Recordemos que la distancia
    entre dos puntos es la raíz
    cuadrada de la suma de los cuadrados
    de la diferencia entre sus coordenadas*/
    double distance = sqrt(diff_x * diff_x + diff_y * diff_y);

    printf("P1 : [%f, %f]\n", A.x, A.y);
    printf("P1 : [%f, %f]\n", B.x, B.y);
    printf("Distance: %f\n", distance);
}
\end{lstlisting}
\end{minipage}

Como habrás adivinado, los textos que salen en verde son los comentarios. Se ve
claramente que son cualquier texto que queramos, y que no tienen nada que ver
con código en C. El preprocesador los eliminará antes de pasarle el programa al
compilador. Hay dos tipos de comentarios:
\begin{enumerate}
\item Comentarios de una línea: Se empiezan con \verb!//!, son comentarios que
hacen que el preprocesador elimine todo después de las barras inclinadas, éstas
incluidas. Se pueden poner varios en líneas correlativas.
\item Comentarios multilínea: Empiezan por \verb!/*!, y \textbf{terminan con}
\verb!*/!. El comentario ignorará saltos de línea y cualquier carácter que
haya hasta que se encuentre el final, como puedes ver en el ejemplo.
\end{enumerate}

En general, puedes poner los comentarios que consideres oportunos, sobre todo,
se comentan funciones que tengan algoritmos difíciles o cosas que no sean
evidentes. Como nota, al ser el inglés la \emph{lingua franca} de esta época y
estar además los lenguajes de programación basados en él, los comentarios del
código se hacen siempre en inglés en entornos profesionales.


El siguiente paso es la expansión de macros. Y te estarás
preguntando qué es una macro. Una macro es una constante simbólica que definimos
en el código y que el preprocesador sustituirá por su valor allá donde la
escribamos. Veamos un ejemplo.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Directiva \texttt{define}},
label={lst:defineDirective}]
#include <stdio.h>

#define LIST_LENGTH 100

int main(void)
{
    int list[LIST_LENGTH];
    for(int ii = 0; ii < LIST_LENGTH; ++ii){
        list[ii] = ii;
    }
}
\end{lstlisting}
\end{minipage}


En la línea tres puedes ver la única novedad que tenemos aquí, la directiva
\verb!define!. Las directivas empiezan con almohadilla (\verb!#!). Y ya vamos
desvelando uno de los misterios que más tiempo llevan en nuestros programas, las
líneas que contienen \verb!#include! son, efectivamente, una directiva. Pero
hablemos de la directiva \verb!#define!. Esta directiva define (lógico, claro)
un símbolo que será sustituido por otro por el preprocesador, en este caso,
hemos definido que allá donde escribamos \verb!LIST_LENGTH!, el preprocesador
lo sustiuirá por \verb!100!. Un uso común para esto es, como puedes ver,
definir el tamaño de arrays. ¿Quiere decir esto que cada array debe tener
su macro correspondiente? No, sólo si se va a usar en varios sitios o tiene
un significado, por ejemplo, el tamaño de una lista de pruebas que vas a
hacer al mismo código.

Como las macros se expanden \textbf{antes} de la compilación, sí que puedes
definir el tamaño de un array y la vez inicializarlo. Esto tiene una ventaja:
cuando inicializas un array, pero faltan elementos, el resto se rellena a 0
automáticamente, así que podemos escribir nuestros programas como:


\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Uso de \texttt{define} con arrays},
label={lst:defineArray}]
#include <stdio.h>

#define LIST_LENGTH 65536

int main(void)
{
    int list[LIST_LENGTH] = {};
    for(int ii = 0; ii < LIST_LENGTH; ++ii){
        if(list[ii] != 0){
            printf("Hay elementos que no son 0.\n");
            break;
        }
    }
}
\end{lstlisting}
\end{minipage}

Ya te expliqué que una variable no se podía usar para indicar el tamaño de un
array que inicializaras con una lista de inicialización
porque esa variable podía valer lo que fuera (el
compilador no puede saberlo, porque eso sólo se sabría al ejecutar el programa).
Quizás te preguntes si una variable constante, por ejemplo,
\verb!const int LENGTH=100;! podría valer. No, una variable marcada con
\verb!const! sigue siendo una variable, porque hay mecanismos, algunos normales
y otros producto de abusos del lenguaje C, que permiten que el valor de esa
variable cambie. Haz una prueba: compila y ejecuta ese programa de ejemplo
algunas veces (no compiles cada vez, sólo necesitas compilar si cambias el
código). Verás que jamás se imprime el mensaje. Ahora, elimina la inicialización
del array, deja la línea 7 como \verb!int list[LIST_LENGTH];! y después de
compilar verás que casi siempre se imprimirá. Esto es porque, recuerda, lo que
no inicializas tiene valores aleatorios.

Pero las macros tienen una potencia increíble, porque admiten argumentos.
Habrás notado que hay cosas que hacemos muy comúnmente, como por ejemplo hallar
el cuadrado de un número, para eso podemos invocar a la función \verb!pow!, lo
que implica compilar enlazando la biblioteca correspondiente, como vimos, o
escribiendo \verb!var*var!, con una macro, podemos hacerlo más legible.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Uso de macro con argumentos},
label={lst:macroWithArguments}]
#include <stdio.h>

#define SQUARE(a) a*a

int main(void)
{
    for(int ii = 0; ii < 10; ++ii){
        printf("%d^2 = %d\n", ii, SQUARE(ii));
    }
}
\end{lstlisting}
\end{minipage}

Como puedes ver, este programa funciona como se espera. Siendo esto así, ¿por
qué no se usan macros para todo? El primer motivo es que se pueden convertir
en un auténtico infierno para encontrar errores o problemas en tus programas.
Esto es porque, recuerda, no son más que un copiar y pegar automático. Imagínate
que hiciéramos un bucle con macros (cosa perfectamente posible), al final, ese
bucle se traduciría en tantas líneas como iteraciones tenga el bucle. Así que si
alguna de ellas es incorrecta, tienes que depurar sobre líneas que no existen ni
puedes ver porque sólo existen después del preprocesado. Además, al ser un
copiar y pegar automático, se pueden producir problemas porque no se comprueban
tipos ni se respetan preferencias de operadores por ser una sustitución
simbólica. Cambiemos un poco el programa anterior:

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Ejemplo de error por una macro},
label={lst:macroError}]
#include <stdio.h>

#define SQUARE(a) a*a

int main(void)
{
    for(int ii = 0; ii < 10; ++ii){
        printf("%d^2 = %d\n", ii, SQUARE(ii+1));
    }
}
\end{lstlisting}
\end{minipage}

Si lees este programa, pensaríamos que debería imprimir: 1, 2, 4, 9... Pero
no es lo que pasa, imprime: 1, 3, 5, 7, 9... Y esto es así porque esta macro
está mal escrita, haz el ejercicio de sustituir \verb!a! en la macro por
\verb!ii+1! mentalmente, verás que sale: \verb!ii+1*ii+1!. Eso no es lo que
querías escribir. La solución a esto es escribir \verb!a! entre paréntesis en la
macro, quedando \verb!#define SQUARE(a) (a)*(a)!, pero aunque en este caso sea
sencillo, sirva este ejemplo para demostrarte que las macros son peligrosas.
Puedes usar macros con argumentos, pero se recomienda que sea para cosas
sencillas, por ejemplo este cuadrado de un número, un valor absoluto, etc.

Además, hay una versión de las macros que pone como una cadena de texto
lo que se introduzca como argumento. Se hace con la almohadilla de nuevo,
veamos el ejemplo.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Uso de macros con cadenas de texto},
label={lst:macroText}]
#include <stdio.h>

#define PRINT_INT(a) printf(#a"=%d\n", a);

int main(void)
{
    for(int ii = 0; ii < 10; ++ii){
        PRINT_INT(ii);
    }
}
\end{lstlisting}
\end{minipage}

Como puedes apreciar, al poner \verb!#a! le estamos diciendo que sustituya
\verb!a! por \verb!"a"!. No te lo he dicho, pero dos cadenas de texto escritas
como literales, juntas, se convierten en una, es decir: \verb!"Hola"" Mundo"!
es equivalente a \verb!"Hola Mundo"!. Y después hemos escrito \verb!a! para que
la sustituya de manera normal. Estos serían los fundamentos más importantes
sobre las macros.

La siguiente directiva que nos importa es, por fin, la directiva \verb!include!.
Es la directiva que hemos usado para poder utilizar una variedad de funciones
como \verb"printf" o \verb!malloc!. Esto es por lo que hace la directiva:
incrusta el contenido de un archivo de código fuente en el tuyo. Sí, lo has
oído bien, cuando escribes \verb!#include <stdio.h>!, lo único que estamos
haciendo es pegar en este archivo de código los contenidos de un archivo
distinto, en este caso, \verb!stdio.h!. Es extraño que sea un archivo con
extensión \verb!.h!, si todos los programas los hemos escrito en un archivo
acabado en \verb!.c!. Esto es porque este archivo es un archivo de
\textbf{cabeceras}, en este tipo de archivo, del que veremos más adelante
ejemplos y te enseñaré a hacer, se escriben sólo definiciones, es decir:
declaraciones de funciones, declaraciones de variables globales, de tipos
nuevos...

Pero, de momento, puedes experimentar con esta directiva escribiendo estos
dos archivos: \verb!main.c!, el que ya teníamos, y \verb!other.c!. En el primero
escribe esto:

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Ejemplo de directiva \texttt{include}, archivo principal},
label={lst:include1}]
//main.c
#include <stdio.h>
#include "other.c"

int main(void)
{
    int a = 10;
    printf("a ahora vale: %d\n", a);
    multiply(&a, 2);
    printf("a ahora vale: %d\n", a);
}
\end{lstlisting}
\end{minipage}

Como puedes ver, al incluir \verb!other.c!, estamos usando comillas en vez de
los signos de menor que y mayor que. Esto es porque cuando a la directiva le
indicamos el nombre del archivo entre menor que y mayor que, los busca en los
directorios predefinidos que el sistema tiene para cabeceras. Si pones comillas,
los busca en donde está este archivo de código fuente que lleva la directiva
\verb!include!. Por ello, cuando utilices archivos que no estén en esos
directorios, debes tener esto en cuenta. En el archivo \verb!other.c! irá este
contenido:

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Ejemplo de directiva \texttt{include}, archivo incluido},
label={lst:include2}]
//other.c
void multiply(int* a, int b){
    *a *= b;
}
\end{lstlisting}
\end{minipage}

Si miras el contenido de ambos archivos, simplemente estamos <<sacando>> la
función a otro archivo y hemos usado la directiva para que desde el archivo
principal se escriba todo el contenido del segundo en el primero. No obstante;
una regla de oro es que nunca debes incluir archivos de código fuente, sino esos
archivos de cabecera que te presenté antes. Sin embargo;
para poder hacer esto, debemos primero ver los dos pasos siguientes de la
creación del binario.

Antes de llegar allí, sin embargo; quiero que veas un par de directivas muy
interesantes: \verb!ifndef!, \verb!ifdef! y
\verb!endif!, que siempre van juntas. Su nombre
es más o menos explicativo, pero se trata de lo siguiente, estas directivas
comprueban si una macro está definida, y si según esté o no, el código
entre \verb!ifdef/ifndef! y \verb!endif! se incluirá o no. Veamos un ejemplo
sencillo.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Uso de directivas \texttt{ifdef} e \texttt{ifndef}},
label={lst:ifdefAndIfndef}]
//main.c
#include <stdio.h>

int main(void)
{
#ifndef MY_MACRO
    printf("¡Hola mundo!\n");
#else
    printf("¡Adiós Mundo!\n");
#endif
}
\end{lstlisting}
\end{minipage}

Aquí puedes ver que usamos \verb!ifndef!, \verb!else! y \verb!endif!, creo
que es muy explicativo, pero simplemente, cuando \verb!MY_MACRO! no está
definida, el código que resulta del preprocesado imprimirá <<¡Hola, mundo!>>;
cuando sí lo está (en el \verb!else!), el código resultante
imprimirá <<¡Adiós Mundo!>>. Las macros se pueden definir desde la línea de
comandos a la hora de compilar (ten en cuenta que aquí ni siquiera nos
interesa su valor, tan solo si existe o no) así que esto permite
modelar nuestra compilación a distintos entornos.
Para definir una macro en el comando de compilación con gcc simplemente
agregar: \verb!-DNOMBRE_MACRO=valor!, por ejemplo, en el caso que acabo
de presentarte: \verb!-DMY_MACRO=0!. Pruébalo, compila el programa anterior
con esta orden: \verb!gcc -o main.exe main.c! y ejecútalo, imprimirá <<¡Hola,
mundo!>>, si lo compilas con esta: \verb!gcc -o main.exe main.c -DMY_MACRO=0!,
imprimirá <<¡Adiós, mundo!>>.

Por ejemplo, se usa para
hacer que existan o no impresiones por pantalla que sólo deben verse en
compilaciones usadas para hallar errores en el código, pero no en la compilación
final, la que se vendería, por ejemplo. Estas directivas son muy importantes
por algo que veremos en la sección siguiente.

\subsection{Compilación de objetos}
El siguiente paso es el de la compilación propiamente dicha. Es un paso
muy sencillo, pero con implicaciones muy interesantes. Lo que has venido
haciendo hasta ahora es compilar un binario de un único fichero de código
fuente. Pero si ejecutaras la orden de compilación de otro modo:
\begin{verbatim}
gcc -c <fichero de código fuente>
\end{verbatim}

Esto generará un fichero con el mismo nombre que el de código, pero con la
extensión \verb!.o!. Esto es un fichero de código \textbf{objeto}. Estos
ficheros son un punto intermedio entre el código fuente en C y el ejecutable,
es un punto intermedio porque estos archivos tienen aún información sobre
símbolos (variables, funciones...) etc. Si compilas con esta opción el programa
Hola Mundo que escribimos al principio, verás que \textbf{no} puedes ejecutar
este archivo de código objeto, pero estos archivos son los ingredientes que
usaremos en nuestra marmita para poder componer por fin un ejecutable con
varios códigos objeto.

Para hacer esto quiero que recuperes los ficheros \verb!main.c! y \verb!other.c!
y \textbf{elimines} la línea donde incluías \verb!other.c!. Si ahora intentas
compilar el archivo \verb!main.c! con la orden
\verb!gcc -c main.c! el compilador lanzará un \emph{warning} como este:

\begin{lstlisting}[style=terminalStyle]
main.c: In function 'main':
main.c:8:5: warning: implicit declaration of function 'multiply' [-Wimplicit-function-declaration]
    8 |     multiply(&a, 2);
      |     ^~~~~~~~
\end{lstlisting}

Nos dice que hemos declarado implícitamente la función \verb!multiply!, eso
significa que el compilador no ha encontrado la definición de la función en el
código fuente, es decir, te advierte que esta función se queda pendiente de
existir tal y como está usada aquí (nombre, tipo de retorno y argumentos).
Quizás esto te parezca una locura, pero así es, en C se pueden declarar
funciones simplemente llamándolas porque se espera que \textbf{estén en otros
códigos objeto}. De ahí que los códigos objeto aún guarden información sobre
los nombres de las funciones, porque así cuando los juntas todos, se juntan
las piezas de este puzzle que es nuestro ejecutable.

Ahora, debemos crear el código objeto del otro archivo, simplemente ejecuta
el mismo comando, pero sobre \verb!other.c!. Ahora tendrás dos archivos:
\verb!main.o! y \verb!other.o!. Ya tenemos las piezas, para juntarlas,
simplemente ejecutarías:
\begin{verbatim}
gcc -o main.exe main.o other.o
\end{verbatim}

Esto generará un ejecutable que podrás ejecutar normalmente y verás que,
efectivamente, funciona. Como comprenderás, es muy mala idea que cuando compilas
un archivo de código fuente haya funciones que existen simplemente porque las
usas, imagínate el horror de tener que compilarlo todo para luego descubrir que
has llamado mal a una función (por ejemplo, con un número equivocado de
argumentos). Si has experimentado con los ejercicios, habrás visto que muy
sencillo cometer esos errores y que el compilador es, de hecho, tu mejor aliado
para señalártelos. En la solución a esto es donde entran los archivos de cabecera
y los archivos de código. Como ya vimos en la sección \ref{funciones}, se pueden
declarar en un sitio y definir en otro, y es aquí donde esto nos resulta más
útil. Todas las funciones pueden ir declaradas en un fichero de cabeceras, de
tal manera que el compilador \textbf{conozca} la cabecera de la función y
pueda generar el objeto comprobándola. Para ello, vamos a escribir el archivo
de cabeceras que corresponde a \verb!other.c!, es decir, \verb!other.h!. Es muy
sencillo, como sólo tenemos una función, el archivo será tal que así:


\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Archivo de cabecera},
label={lst:headerFile}]
//other.h
void multiply(int* a, int b);
\end{lstlisting}
\end{minipage}

Hay que cambiar \verb!other.c!, simplemente \textbf{incluyendo} la propia
cabecera. Esto lo hacemos así porque, si nos equivocamos al definir la función,
por ejemplo, imagínate que se nos olvida el asterisco, el compilador nos dirá
que hemos redefinido la función porque, al haberla declarado en dos maneras
distintas, sería como dos funciones con el mismo nombre, y eso no está
permitido. Quedaría así:


\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Archivo de definiciones con cabecera incluida},
label={lst:fileCofHeader}]
//other.c
#include "other.h"
void multiply(int* a, int b) {
    *a *= b;
}
\end{lstlisting}
\end{minipage}

Finalmente, en \verb!main.c! incluiremos el archivo de cabeceras. Quedaría así:

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Archivo principal con cabeceras incluidas},
label={lst:fileCofHeader}]
//main.c
#include <stdio.h>
#include "other.h"

int main(void)
{
    int a = 10;
    printf("a ahora vale: %d\n", a);
    multiply(&a, 2);
    printf("a ahora vale: %d\n", a);
}
\end{lstlisting}
\end{minipage}

Ahora, para generar el binario, simplemente tenemos que generar ambos
objetos y después el ejecutable con estas órdenes:

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=terminalStyle]
gcc -c main.c
gcc -c other.c
gcc -o main.exe main.o other.o
\end{lstlisting}
\end{minipage}

Si observas, el compilador ya no nos lanza el \emph{warning} de que hemos
usado la función sin una declaración previa. Pero hay un problema, el código
de \verb!other.h! será incrustado en todos los archivos que utilicen la función,
porque en todos ellos estará la directiva de inclusión. Si dejamos esto tal y
como está, no podríamos usar la función en otro archivo, porque el compilador
vería esto como una redefinición. Incluyo aquí todos los archivos para que
tengas toda la información.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Ejemplo de redefinición -- \texttt{point.h}},
label={lst:redefInclude}]
//point.h
struct point_s{
    double x;
    double y;
};

typedef struct point_s point_t;

double distance(const point_t* a, const point_t* b);
\end{lstlisting}
\end{minipage}
\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Ejemplo de redefinición -- \texttt{point.c}},
label={lst:redefInclude}]
//point.c
#include "circle.h"
#include <math.h>
#include <stddef.h>

double distance(const struct point_s* a, const struct point_s* b) {
    double res = 0.0;
    struct point_s origin = { .x = 0.0 , .y = 0.0 };
    if (NULL == a) {
        a = &origin;
    }
    if (NULL == b) {
        b = &origin;
    }
    double diff_x = a->x - b->x;
    double diff_y = a->y - b->y;
    res = sqrt(diff_x * diff_x + diff_y * diff_y);
    return res;
}
\end{lstlisting}
\end{minipage}
\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Ejemplo de redefinición -- \texttt{circle.h}},
label={lst:redefInclude}]
//circle.h
#include "point.h"

#define PI ((double)3.141592)

struct circle_s {
    point_t center;
    double  radius;
};

typedef struct circle_s circle_t;

double area(const circle_t* c);

double diameter(const circle_t* c);
\end{lstlisting}
\end{minipage}

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Ejemplo de redefinición -- \texttt{circle.c}},
label={lst:redefInclude}]
//circle.c
#include "circle.h"
double area(const circle_t* c) {
    return c->radius * c->radius * PI;
}

double diameter(const circle_t* c) {
    return 2 * PI * c->radius;
}
\end{lstlisting}
\end{minipage}

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Ejemplo de redefinición -- \texttt{main.c}},
label={lst:redefInclude}]
//main.c
#include <stdio.h>
#include "point.h"  //for using points
#include "circle.h" //for using circles


int main(void)
{
    point_t a = {1.1, 2.3};
    point_t b = {4.1, 3.3};
    printf("La distancia entre a y b es: %f\n", distance(&a, &b));

    circle_t circle = {a, 1};
    printf("La el círculo tiene un área de: %f\n", area(&circle));
}
\end{lstlisting}
\end{minipage}

Si intentas generar los objetos de todos los archivos de código fuente (los
archivos de cabeceras no se compilan), verás que a la hora de compilar
\verb!main.c! éste da errores sobre redefiniciones. Esto es porque, si sigues
el <<rastro>> de las inclusiones, verás que \verb!main.c! incluye
\verb!circle.h! y éste incluye \verb!point.h!. Por otro lado, el propio
\verb!main.c! incluye \verb!point.h!, esto provoca que el contenido de éste
último esté presente dos veces. Si bien en este ejemplo se podría solucionar
sencillamente eliminando la inclusión de \verb!point.h! en el archivo principal,
pero no podemos hacerlo, porque entonces no habría modo de usar las estructuras
definidas en esa cabecera aquí. En proyectos con más archivos es una tarea
imposible rastrear estos problemas
para comprobar si incluyes un archivo más de una vez. Además, si hicieras esto,
volveríamos a esa situación en que no podrías saber si estás usando bien las
funciones en \verb!main.c!, porque no has incluido la cabecera correspondiente.
Por esto, se usan los llamados \emph{include guards}.

Éstos son simplemente el uso de directivas de tipo \verb!ifndef endif! para
hacer que, si un archivo de cabeceras se incluye más de una vez, las
repeticiones sean archivos vacíos. Es costumbre que todos los archivos
de cabeceras de un proyecto lleven uno, así que para cuando uses varios
archivos de código te recomiendo que te acostumbres desde ahora a usarlos.
Veamos cómo añadir un \emph{include guard} a \verb!point.h!


\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Ejemplo de \emph{include guard}},
label={lst:includeGuard}]
//point.h
#ifndef POINT_H
#define POINT_H

struct point_s{
    double x;
    double y;
};

typedef struct point_s point_t;

double distance(const point_t* a, const point_t * b);

#endif
\end{lstlisting}
\end{minipage}

Como puedes ver, lo que se hace es encerrar todo el contenido del archivo
en un condicional del preprocesador.
Si la macro \verb!POINT_H! no está definida, la definiremos,
y con ella todo el código de la cabecera. Así, cuando se incluya por segunda
vez, como dicha macro ya está definida, el \verb!ifndef! no se cumplirá y,
a efectos del compilador, este archivo estará vacío. El nombre de la macro
suele ser el nombre del archivo, sustituyendo los puntos por guiones bajos,
si usaras directorios dentro de tu proyecto, lo ideal sería que la macro tuviera
la ruta completa del archivo relativa al directorio donde guardes tu proyecto,
por ejemplo, si este archivo estuviera en:
\verb!proyecto/lib/math/geometry/include!, el nombre de la macro del
\emph{include guard} debería ser:
\verb!LIB_MATH_GEOMETRY_INCLUDE_POINT_H!.


\subsection{Enlazado}
El enlazado es la fase final del proceso de creación de un ejecutable. En él,
lo que se hace es juntar los códigos objeto y las diferentes
\textbf{bibliotecas} (en inglés: \textit{libraries})
necesarias para el funcionamiento del ejecutable. Ya
sabemos qué son los códigos objeto, y ya has usado varios para crear un
ejecutable, pero ahora vamos a centrarnos en las bibliotecas.

Una biblioteca es, en términos conceptuales, un conjunto de funcionalidades que
se compilan y distribuyen en un paquete que el usuario de la misma puede
utilizar en sus programas. La principal ventaja es que el código fuente de una
biblioteca es prácticamente imposible de reconstruir a partir de la misma, y,
sobre todo, de una manera comprensible. Esto es una ventaja porque el código
fuente está sujeto a propiedad intelectual, y, si bien es común que existan
proyectos de código abierto, muchas bibliotecas comerciales se distribuyen sin
acceso al código.

Además, las bibliotecas trasladan la responsabilidad del código de las mismas
a quien las vende o distribuye, descargando al usuario de éstas de la tarea
de fabricar
el binario cuando cambie el código. Son una herramienta de distribución de
\emph{software} imprescindible. De hecho, ya has usado bibliotecas, todas las
funciones que has usado hasta ahora que venían dadas simplemente poniendo
alguna directiva de inclusión de una cabecera (\verb!malloc!, \verb!printf!...)
residen en distintas bibliotecas \textbf{proporcionadas como parte de tu
sistema operativo Linux}. Cuando el sistema operativo se actualiza, estas
bibliotecas podrían cambiar y por tanto su funcionalidad verse actualizada.
Esto puede implicar que necesites recompilar tus programas para ver esos cambios
o no, dependiendo de qué tipo de bibliotecas utilices, habiendo dos tipos:

\begin{enumerate}
\item Bibliotecas dinámicas: Son aquéllas que se cargan en memoria cuando el
programa se ejecuta, de ahí su nombre, pues se cargan sólo cuando son
necesarias.
\item Bibliotecas estáticas: Son aquéllas que se combinan con el binario en
tiempo de compilación. Esto implica que cuando se cambia una biblioteca de este
tipo se deben recompilar los binarios que la usen.
\end{enumerate}

Las bibliotecas, como el ejecutable, \textbf{son gestionadas por el sistema
operativo}, es decir, los ejecutables que utilicen bibliotecas solicitarán al
sistema operativo (sin que el programador deba hacer nada a nivel de código
fuente) que las cargue cuando sea necesario. Además, es él el que gestiona
las versiones, permitiendo al programador de un binario indicar que su
ejecutable sólo funcionará con determinada versión de una biblioteca dinámica
pero no con otras.

En general, cuando se generan bibliotecas se utilizan herramientas que
automatizan la compilación de todos los códigos objeto y el enlazado de
bibliotecas. Pero voy a mostrarte cómo se haría <<a mano>>.

Supongamos que queremos hacer una biblioteca con nuestra estructura punto y
nuestra estructura círculo y que la vamos a llamar \verb!libGeometry!.
Es convencional que todas las bibliotecas empiecen por \verb!lib!.
El primer paso es generar el código objeto,
pues de él nos valemos tanto para crear ejecutables como para crear bibliotecas.
\begin{verbatim}
gcc -c point.c
gcc -c circle.c
\end{verbatim}

Una vez hecho eso, creamos la biblioteca, para ello utilizamos este comando:
\begin{verbatim}
gcc -shared -o libGeometry.so point.o circle.o
\end{verbatim}

Utilizamos la opción \verb!shared! para indicar que estamos compilando
una biblioteca dinámica. Ahora, para crear el ejecutable, debemos enlazar con
la biblioteca:

\begin{verbatim}
gcc -shared -o pointLib.so point.o circle.o
\end{verbatim}

Esto creará nuestro archivo de biblioteca, \verb!pointLib.so!, ahora podemos
compilar el ejecutable utilizando la biblioteca en vez de los códigos objeto
directamente. Para ello se usaría este comando:

\begin{verbatim}
gcc -L. -Wl,-rpath=. -o main.exe main.o -lGeometry -lm
\end{verbatim}

Este comando es un poco complicado, la opción \verb!-L! nos permite indicar
en qué fichero deben buscarse las bibliotecas para la compilación, esto se hace
indicando la ruta punto (\verb!.!), que significa este directorio. Por otro
lado, la opción \verb!-Wl,-rpath=! nos permite indicar dónde debe buscarse
el archivo de la biblioteca en el momento de la ejecución,
igualmente, escribimos punto. El resto del
comando es igual, pero añadimos el enlazado de las dos bibliotecas: la nuestra y
la biblioteca matemática, con la opción \verb!-lm!. Ahora, si ejecutas el
programa con el comando \verb!./main.exe!, funcionará perfectamente.
Para comprobar que la biblioteca se enlaza dinámicamente, prueba a eliminarla,
puedes hacerlo con el comando \verb!rm libGeometry.so!. Si ahora ejecutas el
programa, no funcionará, porque lo buscará en tiempo de ejecución.

En el caso de una biblioteca estática, éstas se crean de manera más sencilla,
crea los objetos como antes, y ahora crea la biblioteca estática:

\begin{verbatim}
ar rvs libGeometry.a point.o circle.o
\end{verbatim}

Ahora se puede compilar incluyendo la biblioteca (tenemos que seguir añadiendo
\verb!-lm! porque usamos la función \verb!sqrt! que está en la biblioteca
matemática):

\begin{verbatim}
gcc -o main.exe main.o libGeometry.a -lm
\end{verbatim}

Para comprobar que es estática, eliminar \verb!libGeometry.a! y verás que el
ejecutable sigue funcionando. Esto es porque la biblioteca se incrusta en
el momento en que realizas el ejecutable con todo sus códigos objeto. Esto hace
que el resultado sea similar a simplemente utilizar todos los códigos objeto,
pero sigue permitiendo la \textbf{distribución} sencilla del \emph{software}.
Además, así nos permite crear unidades conceptuales de software mayores que
los códigos objeto de un único fichero, simplificando nuestros procesos de
creación y distribución de los programas.


\section{Funciones de la biblioteca estándar}
La biblioteca estándar de C es una biblioteca que se incluye en todos los
programas compilados en C en Linux. Esto es así porque contiene la mayoría
de funciones que son implescindibles para realizar tareas básicas, por ejemplo:
\verb!malloc! y \verb!free! están en ella. Aunque haya una cabecera que se llame
\verb!stdlib.h!, la mayoría de funcionalidades que se pueden usar sin enlazado
de bibliotecas extra (como la matemática) están en la biblioteca estándar.
En esta sección vamos a hablar de algunas de estas funciones y a demostrar por
qué son necesarias incluso en niveles básicos.

\subsection{Manejo de memoria}
Aunque ya hemos visto las funciones más básicas para el manejo de memoria:
\verb!malloc! y \verb!free!, hay otras funciones que son útiles que está bien
que conozcas. Éstas son \verb!calloc!, \verb!realloc! y \verb!memset!. Las dos
primeras sirven para reservar memoria y la última sirve para poner a un mismo
valor todos los bytes de una zona de memoria. Suelen verse mucho en programas
con muchas operaciones de memoria.

La primera de ellas: \verb!calloc! es una función que nos permite indicar la
reserva de varios framentos de un tamaño concreto, que se reservarán en una
zona contigua. Para empezar, veamos la declaración de la función:

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Declaración de la función \texttt{calloc}},
label={lst:callocSignature}]
void *calloc(size_t nmemb, size_t size);
\end{lstlisting}
\end{minipage}
Como puedes ver, al igual que su <<hermana>> \verb!malloc!, devuelve un
puntero a \verb!void!, que después podrá ser asignado a cualquier tipo de
puntero. Sin embargo, recibe dos argumentos: el número de elementos que vas
a reservar y el tamaño de los elementos. Si estás pensando que una llamada a
esta función es equivalente a un \verb!malloc! multiplicando los dos argumentos,
tienes razón, pero hay \textbf{una diferencia}: la memoria reservada con
\verb!calloc! será inicializada a \textbf{ceros}. Esto provoca que algunos
programadores utilicen una llamada a \verb!calloc! con el primer argumento
valiendo uno para reservar una zona de memoria que esté inicializada a ceros.

La siguiente función, \verb!realloc!, es más interesante, es una función que nos
permite \textbf{redimensionar} y automáticamente mover, si fuera necesario,
una zona de memoria, su declaración es la siguiente:

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Declaración de la función \texttt{realloc}},
label={lst:callocSignature}]
void *realloc(void *ptr, size_t size);
\end{lstlisting}
\end{minipage}
Como puedes ver, recibe un puntero como primer argumento, éste es el puntero
de la zona de memoria \textbf{que queremos redimensionar} y, como segundo argumento,
recibe el tamaño nuevo, \textbf{en bytes}, de la zona de memoria. En este caso hay
dos posibilidades, que estés ampliando la zona inicial o que la estés
encogiendo. En ninguno de los dos casos tienes garantizado que la zona de
memoria sea la misma, así que debes comprobar que no ha devuelto \verb!NULL! y
además volver a guardar el valor del puntero, porque ha podido cambiar.
Además, si el puntero que se le da a esta función es nulo, simplemente se
comporta como \verb!malloc!, esto es útil para poder usarla en bucles sin tener
que mezclarla con una llamada a \verb!malloc! inicial.
Para ilustrar el uso de esta función, implementaremos con ella el programa
\ref{lst:mallocAndFree} donde demostramos el primer uso de reserva de memoria
dinámica.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C, label={lst:reallocExample},
caption={Utilización de \texttt{realloc}}]
#include <stdio.h>
#include <stdlib.h>

int* erase_reps(int* array, int array_length, int* final_length) {
    *final_length = 0;
    int* result = realloc(NULL, sizeof(*result) * array_length);
    for (int ii = 0; ii < array_length; ++ii) {
        int unique = 1;
        for (int jj = 0; jj < ii; ++jj) {
            if (array[ii] == array[jj]) {
                unique = 0;
            }
        }
        if (unique) {
            result[*final_length] = array[ii];
            ++(*final_length);
        }
    }

    return realloc(result, *final_length * sizeof(*result));
}


int main(void)
{
    int array[] = { 20,1,2,3,4,5,6,5,8,7,9,6,6,5,4,1,2,3,8,5,4,4,5,6 };
    int length;
    int* result = erase_reps(array, 24, &length);
    if (NULL == result) {
        printf("Ha habido un error de memoria\n");
        return -1;
    }
    for (int ii = 0; ii < length; ++ii) {
        printf("%d\n", result[ii]);
    }
    free(result);
}
\end{lstlisting}
\end{minipage}

Si comparas ambos programas, verás que en la primera tuvimos que declarar un
array para poder tener un sitio en el que guardar los datos hasta que sepamos
cuántos hay que alojar. La desventaja de esto es que después tenemos que copiar
los datos a la nueva zona que vamos a devolver y reservamos con \verb!malloc!,
en este caso en que usamos \verb!realloc!, dejamos que sea el gestor de memoria
del sistema operativo el que se preocupe de esto, y, siendo sensatos, es poco
probable que al encoger una zona de memoria se mueva el contenido, así que
podemos asumir que nos ahorraremos la copia la mayoría de veces. Ojo, repito:
poco probable; pero posible.

La siguiente función es también interesante, \verb!memset! es una función que se
encuentra declarada en la cabecera \verb!string.h!. Y esto tiene sentido porque,
al poner todos los bytes de una zona de memoria al mismo valor, se usa mucho
cuando se utilizan cadenas de texto, para permitir rellenar un texto con el
mismo carácter. La función tiene esta forma:

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Declaración de la función \texttt{memset}},
label={lst:memsetSignature}]
void *memset(void *s, int c, size_t n);
\end{lstlisting}
\end{minipage}
El primer argumento es el puntero es donde vas a escribir los cambios, el
segundo es el valor que vamos a escribir \textbf{en cada byte} y el último
el número de bytes que se van a escribir. El típico ejemplo de uso para esto
es cuando necesitas inicializar a ceros una zona de memoria. Esto es típico
cuando reservas memoria para alguna estructuras cuyo valor necesitas controlar
o que requiere que sea inicializada así. En ejemplos posteriores las veremos.
El ejemplo que voy a poner, sin embargo, es más original. Imagina que
quieres imprimir una carra de progreso en modo de texto que tenga este aspecto:
\begin{verbatim}
[#############################.....................]
\end{verbatim}
Imagino que ves por dónde voy. Para que la barra se imprima de manera
<<bonita>>, tengo que presentarte un  nuevo caracter especial: \verb!\r!, que
se llama retorno de carro, es decir, lleva el punto de impresión al principio
de la línea, permitiéndote sobreescribirlo. Además, voy a usar una función
llamada \verb!usleep!, que nos permite pausar el programa durante algún tiempo,
si no, el programa haría la secuencia muy deprisa. Finalmente, la función
\verb!fflush! te permite \textbf{forzar} a la terminal a que imprima caracteres
que estén pendientes, esto lo hacemos porque, como no imprimimos ninguna línea
nueva, la terminal imprimiría sólo cada cierto tiempo, fastidiando el efecto.


\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Utilización de la función \texttt{memset}},
label={lst:memsetExample}]
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#define ARRAY_SIZE(array) ((sizeof((array)))/(sizeof((array)[0])))
#define BAR_LENGTH ((size_t)100)

void print_bar(int progress) {
    //el resto de chars serán cero
    char bar[BAR_LENGTH + 3] = { '[' };
    //dejamos espacio al final para el último cero
    bar[ARRAY_SIZE(bar) - 2] = ']';
    //escribimos las almohadillas que indican completado
    memset(bar + 1, '#', progress);
    //escribrimos los puntos que indican la parte sin completar
    memset(bar + 1 + progress, '.', BAR_LENGTH - progress);
    //imprimimos y volvemos al principio de la línea
    printf("%s\r", bar);
    //obligamos a la terminal a actualizarse inmediatamente
    fflush(NULL);
}

int main(void)
{
    for (int ii = 0; ii <= 100; ++ii) {
        print_bar(ii); //imprimimos la barra
        usleep((unsigned int)(2.50 * 100000)); //esperamos
    }
    //imprimimos una línea nueva para que el prompt salga
    //en la siguiente
    printf("\n");
}
\end{lstlisting}
\end{minipage}

Como puedes ver, la función que imprime una barra dado determinado progreso
es muy simple. Debido a que aparecen varias cosas que no había explicado antes,
he comentado el código exhaustivamente. Aquí lo hago en español, pero, como
ya dijimos, en cualquier entorno profesional los comentarios se hacen en inglés.

Otra función muy útil es la que nos permite \textbf{copiar} lo que hay en una
zona de memoria a otra. Esto es especialmente útil porque nos permite copiar
de una parte a otra cualquier tipo de dato sin tener que hacer un bucle, cuando
un algoritmo copia muchas veces de un sitio a otro, al final esos simples
bucles pueden hacer el código más difícil de leer. Como con las demás, vamos
a ver su declaración:


\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Declaración de \texttt{memcpy}},
label={lst:memcpy}]
void *memcpy(void *dest, const void *src, size_t n);
\end{lstlisting}
\end{minipage}

Recibe tres argumentos, el primero es la zona de memoria donde copiaremos
los datos, el segundo la zona de memoria desde la que los copiaremos
y el tercero el número de bytes que queremos copiar. Para recordar qué argumento
va primero (si el destino o el origen), yo recuerdo que funciona como una
asignación, es decir, el destino va a la izquierda. Veamos un ejemplo, imagínate
una función que nos permite insertar un elemento en la posición que queramos de
un array.


\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Utilización de la función \texttt{memcpy}},
label={lst:memcpyExample}]
int *insert_at(int *list,
               int  list_size,
               int  position,
               int  element)
{
    int *res = malloc(sizeof(*res) * (list_size + 1));
    memcpy(res, list, sizeof(*res) * position);
    memcpy(res + position, &element, sizeof(*res));
    memcpy(res + position +1,
               list + position,
               sizeof(*res) * (list_size - position));
    return res;
}
\end{lstlisting}
\end{minipage}

La función es bastante sencilla, simplemente copiamos desde la primera posición
a la posición de inserción, copiamos el elemento que queremos insertar (esto
lo podríamos hacer con un operador de asignación, pero ya que estamos en el
negocio...) y después copiamos los elementos que vienen después del que
queríamos insertar.


\subsection{Manejo de cadenas de texto}
Quizás hayas notado que, debido a que los \emph{strings} en C son simplemente
arrays y a que no podemos hacer una serie de cosas con ellos de manera sencilla,
siempre ocurre que es complicado manejarlos. Si no, ya te comunico que utilizar
cadenas de texto en C intensivamente es algo ligeramente (si no mucho) más
engorroso que con otros lenguajes. Pero hay muchas funciones que nos ayudan
a manejarlos. Veamos de qué funcionalidades disfrutamos:

\begin{enumerate}
\item Comparar cadenas y ordenarlas lexicográficamente
\item Saber la longitud de cadenas de texto.
\item Duplicar una cadena.
\item Crear cadenas nuevas con formato determinado.
\end{enumerate}

Como puedes ver, tenemos una enorme cantidad de funcionalidades a nuestra
disposición para manipular cadenas de texto. Estas funciones están todas en las
cabeceras \verb!string.h! y \verb!stdio.h! (la misma que \verb!printf!).
Vayamos funcionalidad por funcionalidad.

En general, las variables básicas se comparan con el operador \verb!==!, pero
las cadenas de texto en C son punteros. Si hicieras una comparación con este
operador, simplemente compararías las direcciones de ambas cadenas que, salvo
que fueran la misma, nunca serían iguales. Supongo que, con lo que ya sabes del
lenguaje, podrás deducir cómo se hace la comprobación: simplemente un bucle que
compare carácter a carácter hasta que se llegue al final de uno de los dos, que
debería ser el mismo número de iteraciones para que sean iguales. La función
para hacer esto es \verb!strcmp!.

En general, cuando comparas cosas en un lenguaje, invocas un operador o una
función que devuelve cierto si son iguales y falso si son distintos. Por
ejemplo: \verb!a == b!. Pero en este caso, \verb!strcmp! devuelve un número
menor que cero si la primera cadena es anterior a la segunda en orden
lexicográfico (alfabético), \textbf{cero si son iguales} y un número mayor
que cero si la segunda es anterior a la primera. Veamos un ejemplo de su uso,
vamos a realizar un programa que indique si una sucesión de cadenas está en
orden alfabético.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Ejemplo de uso de \texttt{strcmp}},
label={lst:strcmp}]
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main(int argc, char const* argv[])
{

    if (argc < 3) {
        printf("Necesitamos al menos dos palabra.\n");
        return EXIT_FAILURE;
    }


    for (int ii = 1; ii < argc - 1; ++ii) {
        if (0 < strcmp(argv[ii], argv[ii+1])) {
            printf("Las palabras introducidas como argumento no"
                   " están en orden alfabético\n");
            return EXIT_FAILURE;
        }
    }
    printf("ok\n");
    return EXIT_SUCCESS;
}
\end{lstlisting}
\end{minipage}

El condicional es un poco confuso, pero suele pasar cuando utilizamos
\verb!strcmp!, queremos que los argumentos anteriores sean menores que los
posteriores, por lo que debemos comprobar si el resultado de \verb!strcmp! es
mayor que cero (o, tal y como está escrito, si cero es menor que ese resultado)
porque indicaría que es la palabra en la siguiente posición la que iría antes,
es decir, que están desordenadas. Por otro lado, mira el bucle, empezamos
desde la posición uno, porque en la cero está el nombre del programa y
terminamos en la anterior a la última, porque dentro del bucle comprobamos
la siguiente posición, y no hay siguiente a la última.

La siguiente función que nos ocupa es \verb!strlen!, que nos dice la longitud
de una cadena de texto, eso sí: \textbf{sin contar el carácter nulo}. Para
empezar, antes de ver la \emph{signature} de la función, vamos a hacer el
ejercicio de hacer una función que realice esta sencilla tarea:

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Propia versión de \texttt{strlen}},
label={lst:ownStrlen}]
size_t my_own_strlen(const char* string)
{
    size_t res  = 0;
    char   iter = string[res];

    while ('\0' != iter) {
        ++res;
        iter = string[res];
    }

    return res;
}
\end{lstlisting}
\end{minipage}

La función es muy simple, pero quiero que notes una cosa que se ve bien en
esta implementación (implementación es una manera de decir realización, es
decir, cómo está hecho):
si el \emph{string} no contiene ningún carácter nulo,
esta función leerá lo siguiente que haya en memoria sin parar, lo que, como
ya sabes, suele provocar que los programas fallen y se cierren. Por esto,
ten cuidado al usar la función, porque llamarla sobre un puntero a \verb!char!
sin un carácter nulo provocaría errores en el programa.

Rápidamente, la función que duplica cadenas de texto es \verb!strdup!, y su
\emph{signature} es ésta:

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Definición de \texttt{strdup}},
label={lst:ownStrlen}]
char *strdup(const char *s);
\end{lstlisting}
\end{minipage}
Simplemente es una función a la que le pasas por argumento la cadena que quieres
duplicar y devuelve un puntero a una zona de memoria con este mismo contenido.
Sin embargo, debes liberar los dos, si el primero se reservó con memoria
dinámica, porque no es una operación que mueve, sino que copia.

Por ejemplo, un uso común para esta función es cuando estás creando una
estructura de datos que almacene cadenas de texto, como ya vimos en el programa
\ref{lst:constantArguments}: \nameref{lst:constantArguments}, es útil que
ciertas estructuras de datos se manejen sólo mediante llamadas a funciones,
por ello, en vez de hacer lo que hacemos allí: primero el \verb!malloc! y
después la copia, podemos usar \verb!strdup!, para hacerlo en menos líneas.
Un buen ejercicio sería que reescribieras ese programa utilizando esta nueva
función.

Y llegamos al punto más importante de esta sección, el formateado de una cadena
de texto a partir de variables. Esto ya lo has estado haciendo con la función
\verb!printf!. Para poder hacer esto, existen varias funciones:
\begin{enumerate}
\item \verb!sprintf!: Permite hacer los mismo que \verb!printf!, pero a un
puntero a \verb!char!.
\item \verb!fprintf!: Es la misma idea, pero con ficheros, del mismo modo de
las funciones de escritura y lectura de archivos, recibe un puntero de tipo
\verb!FILE!.
\end{enumerate}

De nuevo, este es un manual de C, y pretendo que siga siendo más o menos
estrictamente eso, pero me es conveniente presentarte un ejemplo de caso de uso
para estas funciones. En informática, a veces, para transmitir información,
por ejemplo, por Internet o entre máquinas de cualquier modo realizamos un
proceso que se llama \textbf{serialización}. Este proceso es la conversión de
datos residentes en la memoria de alguna máquina a texto. Esto se hace porque
las máquinas pueden usar maneras distintas para guardar información en su
memoria, por ejemplo, hay ordenadores cuyos bytes están ordenados <<al revés>>.
Esto quiere decir que el número 10.669 que en hexadecimal es:
0x29AD se compone de dos bytes (recuerda, cada byte son dos dígitos
hexadecimales), en la memoria de algunos ordenadores estará guardado como
0x29~AD y en otras como 0xAD~29. Para evitar este tipo
de confusiones, convertirmos nuestros datos en cadenas de texto.

Volviendo al ejemplo del programa \ref{lst:constantArguments}. Podríamos
crear una función que creara esta serialización de la estructura, por ejemplo,
en el caso de una persona llamada José Pérez Martínez, querríamos serializarlo
así:

\begin{verbatim}
{
    "name":"José",
    "last_name_1":"Pérez",
    "last_name_2":"Martínez"
}
\end{verbatim}

Veamos como quedaría la función (recuerda que sería añadida al programa
que he citado antes) a la que llamaremos \verb!person_to_string!. Esta función
quedaría como:

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Ejemplo básico de \texttt{sprintf}},
label={lst:sprintfExample}]
char* person_to_string(const person_t *p){
    char preliminar[1024] = {};

    sprintf(preliminar,
            "{\n"
            "\t\"name\":\"%s\",\n"
            "\t\"last_name_1\":\"%s\",\n"
            "\t\"last_name_2\":\"%s\"\n"
            "}",
            p->name, p->last_name_1,
            p->last_name_2);

    return strdup(preliminar);
}
\end{lstlisting}
\end{minipage}

Para que se lea mejor, he escrito todos los argumentos de la función en una
línea distinta. En el caso del segundo argumento, el formato, lo he dividido
en varias, si observas un poco verás que no hay comas en esas líneas. Eso es
porque dos literales de \textit{string} escritos juntos son como uno solo. Ese
<<juntos>> incluye si sólo los separan espacios en blanco. Ten en cuenta que
esas líneas nuevas no aparecen en el \textit{string}, por eso debemos poner
\verb!\n! al final igualmente.
Además,
observa como utilizamos un array para formatear el texto porque, como ya es
habitual, no sabemos cuánto mide, una vez lo hemos formateado,
usamos \verb!strdup! para devolver una cadena del tamaño correcto.

No obstante este uso de la función es simple, aún queda un detalle: el valor que
devuelve la función. Tanto \verb!printf! como  \verb!sprintf! y todas las
funciones de esta familia devuelven un entero que indica
\textbf{el número de carácteres impresos}
(sin contar el caracter nulo que incluyen para que el \emph{string} resultante
esté bien formado).
Esto es de suma utilidad cuando quieres imprimir varias cosas en el mismo
\emph{string}. Veamos un ejemplo, imagina un programa que, análogamente,
serializa un array de enteros, si el array es {1,2,3,4,5} la serialización
quedaría como:

\begin{figure}[H]
\begin{verbatim}
[
    1,
    2,
    3,
    4,
    5
]
\end{verbatim}
\end{figure}
La solución más inmediata sería usar \verb!sprintf! para imprimir todos los
enteros, pero tenemos un problema, no sabemos cuántos números hay, así que
no podemos escribir en el formato que pide la función los especificadores
necesarios. Por eso vamos a imprimir con un bucle que utilice el valor
de retorno de la función.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Ejemplo de uso avanzado de \texttt{sprintf}},
label={lst:sprintfExample}]
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_STRING_SIZE ((size_t) 65536)
#define ARRAY_SIZE(array) ((sizeof((array)))/(sizeof((array)[0])))

char* integer_array_to_string(const int* array, size_t array_size)
{
    char res[MAX_STRING_SIZE] = {};
    int  printed_chars        = 0;

    printed_chars += sprintf(res + printed_chars, "[\n");
    for (size_t ii = 0; ii < array_size; ++ii) {
        char* separator;
        if (ii != array_size - 1) {
            separator = ",\n";
        }
        else {
            separator = "\n";
        }
        printed_chars += sprintf(res + printed_chars,
                                     "\t%d%s", array[ii], separator);
    }
    printed_chars += sprintf(res + printed_chars, "]");

    // desbordamiento
    if(printed_chars >= MAX_STRING_SIZE){
        return NULL;
    }

    return strdup(res);
}

int main(void)
{
    int list[] = {1,2,3,4,5,6};
    char *serialization = integer_array_to_string(list,
                                                  ARRAY_SIZE(list));
    printf("%s\n", serialization);
    free(serialization);
}
\end{lstlisting}
\end{minipage}

Si ves cómo hemos escrito la función, aprovechamos este valor de retorno para
concatenar cada impresión, el mecanismo es muy sencillo, si hemos impreso,
por ejemplo, tres letras, debemos sumar a la posición inicial ese número.
Además, usamos un condicional dentro del bucle para impedir que se imprima
una coma en el último elemento. Después del bucle, imprimimos el corchete de
cierre y, finalmente, hay un condicional que comprueba que no hemos impreso
más caracteres de los que habíamos previsto. Nota que utilizamos \verb!>=!
porque debemos provisionar que el último \verb!char! es un cero (\verb!\0!).

No obstante, tenemos un problema, aunque somos capaces de decir cuándo se ha
desbordado el \emph{buffer} inicial que proveímos, \textbf{no podemos impedir
que se desborde}. Esto tiene implicaciones muy serias, porque una vez escribes
en zonas de memoria en que no deberías, no sabes qué puede ocurrir. Por suerte,
hay una variación de la función que estamos usando que nos ayudará en este
propósito. Ésta se llama \verb!snprintf!, y tiene la misma \textit{signature}
que la anterior, pero añade un argumento: el número \textbf{máximo} de
caracteres que debe imprimir, de este modo, nunca desbordará nuestro
\emph{buffer}. Veamos cómo se implementaría el mismo programa usando esta
función.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Ejemplo de uso de \texttt{snprintf}},
label={lst:snprintfExample}]
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#define MAX_STRING_SIZE ((size_t) 100)
#define ARRAY_SIZE(array) ((sizeof((array)))/(sizeof((array)[0])))

char* integer_array_to_string(const int* array, size_t array_size)
{
    char res[MAX_STRING_SIZE] = {};
    int  printed_chars        = 0;

    printed_chars += snprintf(res + printed_chars,
                              MAX_STRING_SIZE,
                              "[\n");
    for (size_t ii = 0;
         ii < array_size && printed_chars < MAX_STRING_SIZE - 2;
         ++ii)
    {
        char* separator;
        if (ii != array_size - 1) {
            separator = ",\n";
        } else {
            separator = "\n";
        }
        printed_chars += snprintf(res + printed_chars,
                                  MAX_STRING_SIZE - printed_chars,
                                  "\t%d%s",
                                  array[ii],
                                  separator);
    }
    printed_chars += snprintf(res + printed_chars,
                             MAX_STRING_SIZE - printed_chars,
                             "]");
    // desbordamiento
    if(printed_chars >= MAX_STRING_SIZE){
        return NULL;
    }
    return strdup(res);
}

int main(void)
{
    int list[24] = { };
    char* serialization =
                    integer_array_to_string(list, ARRAY_SIZE(list));
    if (serialization != NULL) {
        printf("%s\n", serialization);
    }else{
        printf("Error: límite excedido\n");
    }
    free(serialization);
}
\end{lstlisting}
\end{minipage}

Como puedes ver, el segundo argumento de la función es el límite de caracteres
que podemos seguir imprimiendo. Siempre restamos a la longitud del buffer
lo que ya llevamos impreso, así, si ya hemos impreso 100 letras, nos quedan
65536--100. Por otro lado, ten en cuenta que \verb!snprintf! devuelve siempre
el número de caracteres que se imprimirían, es decir, sin contar con que se
realice la impresión o no. A la hora de imprimir, el carácter nulo del final
cuenta, es decir, si a una llamada a \verb!snprintf! le pasas como límite
un tres e intentas imprimir \verb!"abc"!, devolverá tres, pero no escribirá
el carácter nulo.

Ten cuidado, debes comprobar que el argumento del límite no es negativo,
porque está definido como un tipo sin signo, por lo que si le pasaras un número
negativo, sería un número positivo y aleatorio. En este código, lo comprobamos
en el bucle.

\subsubsection{Especificadores posicionales}
Al principio del manual te enseñé a imprimir cosas para que pudieras probar
tus programas, pero lo hice de una manera básica para no abrumarte al inicio
de este manual. No obstante; aprovecho que hemos vuelto a utilizar funciones
de manipulación de texto para desarrollar algo que me dejé entonces en el
tintero. Estos son los especificadores posicionales, ya sabemos qué es un
especificador, indican, dentro del formato, qué tipo dato tiene el argumento
que queremos escribir en esa posición. El problema de este sistema, sencillo,
es que provoca problemas cuando se repite la misma variable varias veces.

Si, por ejemplo, necesitamos imprimir varias veces la misma variable, no
tiene ningún sentido que le pasemos varias veces a la función de impresión.
Por ejemplo, imagínate una función que simulara una partida de nacimiento,
incluyendo el nombre de los padres, es decir, para un padre
llamado Fernando García Pérez y una madre llamada María Fernández López,
si el nombre de pila del niño fuera
Federico, su nombre sería Federico Garía López y deberían incluirse los tres.
La función es trivial, vamos a implementarla simplemente con lo que sabemos:


\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Ejemplo de impresión con argumento repetido},
label={lst:repeatedMessages}]
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct person_s {
    char *name;
    char *last_name_1;
    char *last_name_2;
} person_t;

char *son_name(const person_t *father, const person_t *mother,
               const char *first_name) {
    const int STRING_LENGHT = 65536;
    char res[STRING_LENGHT];
    char *format = "===PARTIDA DE NACIMIENTO===\n"
                   " - Nombre del Padre: %s %s %s\n"
                   " - Nombre de la madre: %s %s %s\n"
                   " - Nombre del hijo: %s %s %s\n";
    snprintf(res, STRING_LENGHT, format, father->name,
             father->last_name_1, father->last_name_2, mother->name,
             mother->last_name_1, mother->last_name_2, first_name,
             father->last_name_1, mother->last_name_1);
    return strdup(res);
}

int main(void) {
    char* text = NULL;
    person_t father = {"Fernando", "García", "Pérez"};
    person_t mother = {"María", "Fernández", "López"};
    text = son_name(&father, &mother, "Federico");
    printf("%s\n", text);
    free(text);
}
\end{lstlisting}
\end{minipage}

La función es sencilla, pero repetimos argumentos, como he introducido antes,
eso no sólo no es eficiente, sino que puede inducir a errores, porque tienes
que ir contando los argumentos. Cuando hay pocos, unos cinco o menos, es
factible, si son muchos más y además hay repeticiones, es sencillo perderse,
por ello, puedes indicar que se imprima el argumento de determinada posición.
Esto nos permite pasárselos sólo una vez a la función. Veamos cómo.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Ejemplo de impresión con argumento repetido y especificador posicional},
label={lst:repeatedMessagesPos}]
typedef struct person_s {
    char *name;
    char *last_name_1;
    char *last_name_2;
} person_t;

char *son_name(const person_t *father, const person_t *mother,
               const char *first_name) {
    const int STRING_LENGHT = 65536;
    char res[STRING_LENGHT];
    char *format = "===PARTIDA DE NACIMIENTO===\n"
                   " - Nombre del Padre: %s %s %s\n"
                   " - Nombre de la madre: %s %s %s\n"
                   " - Nombre del hijo: %s %2$s %5$s\n";
    snprintf(res, STRING_LENGHT, format, father->name,
             father->last_name_1, father->last_name_2, mother->name,
             mother->last_name_1, mother->last_name_2, first_name);
    return strdup(res);
}

int main(void) {
    char *text      = NULL;
    person_t father = {"Fernando", "García", "Pérez"};
    person_t mother = {"María", "Fernández", "López"};
    text            = son_name(&father, &mother, "Federico");
    printf("%s\n", text);
    free(text);
}
\end{lstlisting}
\end{minipage}

El primer cambio es que ahora los dos últimos especificadores son especiales,
un especificador posicional empieza como todos, con un signo de porcentaje,
después la posición en forma de número, un símbolo de dolar y el indicador
del tipo, en este caso, una ese, de \textit{string}. Como puedes ver, nos
ahorramos la repetición de los argumentos.

\subsection{Manejo de errores y manual}
Ahora que hemos visto muchas funciones y sabemos cómo se compila un programa
quiero volver a un ejemplo de programa muy sencillo de algunas secciones atrás,
el programa \ref{lst:exampleRemove}: \nameref{lst:exampleRemove}. Si incluimos el
archivo de cabecera \verb!errno.h! podemos reescribir el programa
de este modo:

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Ejemplo de programa que usa la variable \texttt{errno}},
label={lst:exampleRemove2}]
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char const *argv[]) {
    if (argc != 2) {
        printf("Usage: ./main <path to the file>");
    }

    int error = remove(argv[1]);

    if (error == 0) {
        return EXIT_SUCCESS;
    }
    switch (errno) {
    case ENOENT:
        printf("No such file or directory.\n");
        break;
    case EACCES:
        printf("Permission denied\n");
        break;
    default:
        printf("Undetermined error\n");
        break;
    }
    return EXIT_FAILURE;
}
\end{lstlisting}
\end{minipage}

Como has visto en el programa \ref{lst:exampleRemove} compruebo el valor de
retorno de la función que he llamado y, si es cero (lo que suele indicar éxito)
devuelvo yo mismo \verb!EXIT_SUCCESS!, terminando el programa. En cambio, si
el valor devuelto no es cero, entramos en un \verb!switch! sobre una variable
que no conocemos. En él, utilizamos una serie de valores que tampoco están
presentes en el programa. Esto es porque hemos incluido la cabecera
\verb!errno.h!. Esto nos permite utilizar la variable global
\verb!errno!.

Esta variable existe para que cuando llamemos a alguna función que la utilice
para notificar errores, su valor será escrito en consecuencia del error a uno
de los valores también definidos como macros en la cabecera. Por ejemplo, aquí
hemos contemplado algunos de los casos. Sin embargo; se presenta la pregunta
de cómo saber qué funciones utilizan esta variable global y cuáles no, y qué
valores hay. Para esto se utiliza el \textbf{manual}. Esta es una función de
los sistemas operativos Linux en la que puedes invocar el comando \verb!man!
para encontrar información sobre una función o cabecera. Por ejemplo, prueba
a escribir en una terminal

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=terminalStyle]
\$ man errno
\end{lstlisting}
\end{minipage}

Verás que sale un resultado que empieza por:

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=terminalStyle]
NAME
       errno - number of last error

SYNOPSIS
       #include <errno.h>

DESCRIPTION
       The <errno.h> header file defines the integer variable errno, which is set by system calls and some library functions in the event of an error to indicate what went wrong.

   errno
       The  value  in errno is significant only when the return value of the call indicated an error (i.e., -1 from most system calls; -1 or NULL from most library functions); a function that succeeds is
       allowed to change errno.  The value of errno is never set to zero by any system call or library function.

       For some system calls and library functions (e.g., getpriority(2)), -1 is a valid return on success.  In such cases, a successful return can be distinguished from an error return by setting  errno
       to zero before the call, and then, if the call returns a status that indicates that an error may have occurred, checking to see if errno has a nonzero value.
<continúa>
\end{lstlisting}
\end{minipage}

En las pantalla de manual te mueves con las flechas del teclado y sales de ellas
pulsando la tecla q. Si quieres saber el contenido de cualquier cabecera
(funciones, variables...) o la \textit{signature} de cualquier función, sólo
debes escribir \verb!man! seguido del nombre de la cabecera o función. Si
consigues resultados que no son lo que buscabas, ejecuta \verb!man 3 <nombre>!
en su lugar. El manual tiene información sobre otras cosas (como comandos),
pero la sección tres es la que habla de funciones de C.


\subsection{Ejercicios de la sección}
\begin{exercises}[resume*]
\item Reescribe el ejercicio 15 prescindiendo del array estático de punteros
a \verb!char!. (Usa \verb!realloc! y \verb!strdup!.

\item Escribe un programa que reciba un número indeterminado de palabras como
argumentos y los ordene alfabéticamente y que, después, los imprima.
\item Haz un programa que reciba como argumento una palabra y un número. Si el
número es cero, debe convertir la palabra a minúscula, si el número es distinto
de cero, debe convertirla a mayúscula. Por ejemplo:

\noindent
\begin{minipage}[H]{\linewidth}
\begin{lstlisting}[style=terminalStyle]
\$ ./main.exe Anthony 0
anthony
\$ ./main.exe USA 0
usa
\$ ./main.exe spqr 1
SPQR
\end{lstlisting}
\end{minipage}
Pista: Consulta la tabla ASCII para saber qué distancia hay entre una letra
mayúscula y una minúscula.
\item Crea un programa que dado un número como argumento imprima una pirámide
como esta de tantos pisos como el número indicado:

\noindent
\begin{minipage}[H]{\linewidth}
\begin{lstlisting}[style=terminalStyle]
%%%%%%%%%
 %%%%%%%
  %%%%%
   %%%
    %
\end{lstlisting}
\end{minipage}
Nota: utiliza la función \verb+memset+.
\item Escribe un programa que reciba una serie de puntos y de nombres para
cada uno y después los imprima en orden de su distancia al origen de menor a
mayor. Ejemplo de ejecución:

\noindent
\begin{minipage}[H]{\linewidth}
\begin{lstlisting}[style=terminalStyle]
\$ main.exe 2 3 Valencia 4 5 Cuenca -1 3 Vizcaya
-1 3 Vizcaya
2 3 Valencia
4 5 Cuenca
\end{lstlisting}
Nota: crea una estructura llamada \verb!tagged_point! que maneje los
\textit{strings} como se ve en el programa
\ref{lst:structConstPointers}, pero utilizando la función \verb!strdup!.
\end{minipage}
\end{exercises}


\section{Lógica avanzada}
Hasta ahora nos hemos conformado con utilizar cualquier tipo entero
(generalmente \verb!int!) para almacenar valores lógicos, pero esto se puede
evitar, ahorrando espacio y creando un tipo de dato que nos permita almacenar
propiamente un tipo lógico. Este tipo es el tipo \verb!bool!. Para poder
usar este tipo debes incluir la cabecera \verb!stdbool.h!. Además, este tipo
añade dos nuevas palabras reservadas: \verb!true! y \verb!false!. Palabras
que simbolizan, como puedes imaginar, un valor lógico cierto y uno falso.

Veamos un ejemplo de uso de este tipo en acción:

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Ejemplo del uso del tipo \texttt{bool}},
label={lst:bool1}]
#include <stdio.h>
#include <stdbool.h>

int main(void)
{
    bool it_is_difficult = 10;
    printf("%d\n", it_is_difficult);
}
\end{lstlisting}
\end{minipage}

No existe un especificador para imprimir booleanos, pero si usas el
especificador \verb!%d!, verás que ese programa imprime <<1>>. Es decir, si
somos diligentes almacenando los valores lógicos en el tipo booleano,
podemos asumir que un valor lógico cierto siempre será igual a 1.
Sin embargo, seguimos teniendo un problema, que es la utilización de un byte
entero para un valor que podría ser almacenado en un bit. Este problema viene
del hecho de que los ordenadores no se direccionan porciones de memoria más
pequeñas que bytes. Sin embargo; esto no quiere decir que no podamos manipular
los bits concretos de un byte, por ejemplo, poner a cero un bit concreto,
invertirlos... para eso utilizamos operadores a nivel de bit.

\subsection{Operadores a nivel de bit}
Voy a ser sincero, esta sección no sabía muy bien dónde encajarla, es decir,
no encontraba el sitio donde incluirla en el manual.
Al principio pensé incluirla después de los operadores lógicos, por la
similitud gráfica que ahora verás,
pero la utilidad de éstos era muy difícil de enseñar
en ese momento del manual, o en ese momento de tu aprendizaje, mejor dicho.
Así que mejor los vemos ahora.
Hay varios operadores a nivel de bit, estos son:
\begin{enumerate}
\item Conjunción a nivel de bit, denotada en matemáticas por el punto
medio ($\cdot$), se realiza con el operador \verb!&!.
\item Disyunción a nivel de bit, denotada por $+$, se realiza con el operador
\verb!|!.
\item Negación a nivel de bit, denotado del mismo modo que la negación lógica,
se realiza con el operador \verb!~!.
\item Desplazamiento hacia la izquierda, operador binario que mueve todos los
bits de un tipo entero a la izquierda tantas posiciones como indique el segundo
operando. Se realiza con el operador \verb!<<!.
\item Desplazamiento hacia la derecha, operador binario que mueve todos los
bits de un tipo entero a la derecha tantas posiciones como indique el segundo
operando. Se realiza con el operador \verb!>>!.
\end{enumerate}

Lo que quiere decir que lo hagan a nivel de bit es que, aplicando estos
operadores a dos tipos enteros, el operador genera otro entero cuyo valor será
el resultado de realizar la operación lógica indicada por el operador, pero bit
a bit. Es decir, la conjunción a nivel de byte entre dos números es otro número
en que cada uno de sus bits será el resultado de la conjunción
de los bits en esa posición en los operandos.

Para que endiendas esto bien tienes que entender cómo están representados los
enteros en el ordenador. Ya sabes cómo están representados los enteros sin
signo, en binario natural, es decir, como lo que vimos en la sección
\ref{numericSystems}. Sin embargo; los números negativos se representan
de un modo especial.
Hay varias maneras de representar los números con signo
en binario, la más ingenua es dedicar un bit (el primero, generalmente) al signo
y el resto al valor. De este modo, en un entero de ocho bits el número 7 sería
00000111 y el número -7 es 10000111, pero el problema de esta representación
es que tenemos el número 0 y el -0. Y como somos informáticos,
nos molesta sobremanera desperdiciar un preciado número. Por esto,
los números con signo se representan en \textbf{complemento a dos}.

En este sistema de representación, los números positivos coinciden con su
representación en binario natural, sin embargo, los números negativos se
representan con su complemento, para hallar el complemento a dos de un número
hay que seguir este proceso.
\begin{enumerate}
\item Invertir todos sus bits (el decir, pasar los ceros a unos y
los unos a ceros).
\item Sumarle uno al resultado anterior.
\end{enumerate}
Por ejemplo, volvamos al número 7 y a los ocho bits:
$$
7_{\left(10\right.} = 00000111_{\left(2\right.}; \;\;
\overline{00000111} = 11111000; \;\;
+\matrix{                      11111000\cr
        \underline{\hphantom{0000000}1}\cr
                              11111001
}\to -7_{\left(10\right.} = 11111001_{\left(\mathrm{CA}2\right.}
$$
La ventaja de esta representación es que, además, el primer bit sólo es uno
cuando el número es negativo, así que es el primer bit sigue indicando el signo,
como en la representación ingenua que te comenté al principio. Otra ventaja de
esto es que sólo existe una representación del cero, que cuenta como número
positivo, porque su primer bit es cero. Esto explica por qué cuando enunciamos
los rangos de los tipos básicos, los tipos enteros siempre llegaban a números
con valores absolutos una unidad mayores en el lado negativo que en el positivo,
el \verb!char!, por ejemplo, tiene un rango que va desde -128 a 127.

Volvamos a los operadores a nivel de bit, sea un \verb!char! que valga
-7 y otro que valga 12:
$$
a = -7_{\left(10\right.} = 11111001_{\left(\mathrm{CA}2\right.} \;\;
b = 12_{\left(10\right.} = 00001100_{\left(\mathrm{CA}2\right.}\;\;
a \cdot{} b = \cdot{}\matrix{11111001\cr
        \underline{00001100}\cr
                              00001000}
$$

En cuanto a los desplazamientos, es sencillo, sea por ejemplo el propio número
7, es decir: 00000111, si le aplicamos un desplazamiento hacia la izquierda
de dos bits, se convertiría en 00011100, en decimal: 28. Si no lo has notado ya,
te lo digo yo, desplazar bits hacia la izquierda es una manera rápida de
multiplicar por dos. Por otro lado, si desplazamos a la derecha, quedaría
00000001, los unos que ya no caben, se eliminan, como puedes ver. Análogamente
a lo anterior, desplazar a la derecha es equivalente a dividir entre dos (en
división entera, claro).

La mayor utilidad para esto es que nos permite establecer algo que los
informáticos llamamos \emph{flags}. Es decir, nos permite utilizar los bits de
una variable entera para indicar sendas variables lógicas. Por ejemplo, podemos
crear una función que serialice un objeto de tipo persona, con estas opciones:
\begin{enumerate}
\item Serializar con nombres legibles para personas, es decir,
<<apellido>> en lugar de, por ejemplo <<last\_name\_1>>.
\item Serializar con espacios o no entre caracteres de contro, es decir,
\verb!"last_name_1" : "Johnson"! en vez de \verb!"last_name_1":"Johnson"!.
\item Serializar en varias líneas.
\end{enumerate}

En general, si estas opciones \textbf{fueran excluyentes}, no se pudieran dar
dos juntas, podríamos codificarlas simplemente con un enumerado, pero como no
lo son, deben ser variables lógicas separadas, el problema es que esto
obligaría a que la función recibiera tres argumentos booleanos. Para esto
utilizaremos las \textit{flags}, vamos a asignar a cada opción un bit, y vamos
a crear un tipo enumerado donde cada opción tenga el valor de un entero
con ese bit puesto a uno. Para pasar varias opciones el usuario simplemente
debe hacer una disyunción a nivel de bit con las opciones.
Veamos la implementación de todo esto:

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C, label={lst:options},
caption={Implementación de opciones con operaciones a nivel de bit}]
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef enum {
    LEGIBLE_NAMES   = 1 << 0,
    CONTROL_ESPACES = 1 << 1,
    MULTIPLE_LINES  = 1 << 2
} serialization_options_t;

typedef struct person_s {
    char *name;
    char *last_name;
    unsigned int age;
} person_t;

char *serialize_person(const person_t *person,
                       serialization_options_t opts) {
    char *field_names_legible[] = {"Nombre", "Apellido", "Edad"};
    char *field_names_normal[]  = {"name", "last_name", "age"};
    char **field_names          = NULL;
    char *separator             = NULL;
    char *line_end              = NULL;

    bool legible   = opts & LEGIBLE_NAMES;
    bool espaces   = opts & CONTROL_ESPACES;
    bool multiline = opts & MULTIPLE_LINES;

    field_names = legible ? field_names_legible : field_names_normal;
    separator   = espaces ? " : " : ":";
    line_end    = multiline ? "\n" : "";

    char *fmt = "{%7$s\"%1$s\"%8$s\"%4$s\",%7$s"
                "\"%2$s\"%8$s\"%5$s\",%7$s"
                "\"%3$s\"%8$s%6$u%7$s}";

    char res[65536];
    sprintf(res, fmt, field_names[0], field_names[1], field_names[2],
            person->name, person->last_name, person->age, line_end,
            separator);
    return strdup(res);
}

int main(void) {
    person_t myself = {"Francisco", "Rodríguez", 26};
    char *text = serialize_person(&myself, MULTIPLE_LINES |
                                     LEGIBLE_NAMES | CONTROL_ESPACES);
    printf("%s\n", text);
    free(text);
}
\end{lstlisting}
\end{minipage}

El tipo enumerado de la línea 8 quizás asusta un poco, pero si recuerdas cuando
los explicamos, a un enumerado le puedes explicitar el valor numérico de cada
valor, aquí utilizamos el operador de desplazamiento a la izquierda para
crear valores que sólo tengan un bit a uno, en posiciones distintas. Podría
haberles asignado a mano los valores 1, 2 y 4, pero con el desplazamiento veo
mejor y no me equivoco al calcular porque sé que siempre tiene que salir
\verb!1 <<! y después el número consecutivo.

Después está la difinición de la estructura persona, que no tiene nada
especial. En la línea 20 llegamos a la función de serialización, como es normal,
recibe un puntero constante a la estructura que va a serializar y las opciones.
Al principio declaramos variables, nada fuera de lo normal. Lo interesante
empieza en la línea 28, estoy calculando variables booleanas para cada una de
las opciones, es decir, estoy decodificando las \textit{flags}. El modo es
simple, al hacer la conjunción de las opciones con cada opción individual,
el resultado será cierto si esa \textit{flag} está levantada, falso en otro
caso. Vamos a verlo rápidamente con la opción de la multilínea. Si
\verb!MULTIPLE_LINES = 1 << 2!, es decir 00000100, y  las opciones son, por
ejemplo, 00000101, al hacer la conjunción quedaría 00000100, es decir, un valor
distinto de cero y por tanto cierto.

En la siguientes línea utilizo un artefacto del lenguaje
que es útil cuando tienes muchas operaciones que se basan en valores lógicos.
Se llama operador ternario, y su nombre radica en que es un operador con tres
operandos, su sintaxis es como sigue: \verb!condition ? valor1 : valor2!,
el operador devolverá el \verb!valor1! si la condición es cierta, si no,
devolverá el \verb!valor2!. Ten cuidado, porque ambos valores deben tener el
mismo tipo. Aquí lo utilizo para definir los separadores de campo, de línea y
los nombres de los campos en la serialización.
El final de la función no tiene nada que no hayas visto antes, me aprovecho
mucho de utilizar aquí especificadores posicionales.

Finalmente, en la función \verb!main! llamamos a la de serialización con las
opciones, simplemente las unimos todas con una disyunción a nivel de bit.
Ten cuidado de no confundirte cuando utilices opciones y utilizar sin
intención un operador lógico.

Por otro lado, hay una operación que me gustaría comentarte aparte, que es
cuando tenemos la necesidad de bajar un \textit{flag} concreto de un conjunto de
opciones, por ejemplo, imagina que queremos serializar primero con todas las
opciones y después sin la opción de multilínea, podríamos crear las opciones
en ambas llamadas, pero si quisiéramos, podríamos guardar las opciones en una
variable, usarlas y después bajarle esa bandera. Para hacer esto hay que hacer
una conjunción con la negación de la bandera. Veamos cómo se haría:

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C, label={lst:setFlagOff},
caption={Ejemplo de bajada de una bandera}]
int main(void) {
    person_t myself = {"Francisco", "Rodríguez", 26};
    char *text      = NULL;

    serialization_options_t opts =
        LEGIBLE_NAMES | CONTROL_ESPACES | MULTIPLE_LINES;

    text = serialize_person(&myself, opts);
    printf("%s\n", text);
    free(text);

    opts = opts & ~CONTROL_ESPACES;

    text = serialize_person(&myself, opts);
    printf("%s\n", text);
    free(text);
}
\end{lstlisting}
\end{minipage}

Dicho así queda un poco contraintuitivo, veámoslos con este ejemplo, en la línea
12, \verb!opts! vale 00000111, la opción \verb!CONTROL_ESPACES! es 00000010,
si la negamos, quedaría 11111101, si haces la conjunción bit a bit de ese valor,
verás que todos quedarían como estuvieran en \verb!opts!, salvo el
correspondiente a \verb!CONTROL_ESPACES!, que será forzosamente cero porque
cualquier valor al que se le haga la conjunción con cero será cero.
Así es como bajas una bandera en una serie de opciones. Ten en cuenta que
para todas las operaciones a nivel de bit existen sus equivalentes de
asignación, es decir: \verb!|=!, \verb!&=!, \verb!~=!, \verb!<<=! y
\verb!>>=!, así que podríamos escribir la línea en cuestión aquí de este modo:
\lstinline[style=C]!opts &= ~CONTROL_ESPACES;!

\section{Algoritmos}
Un algoritmo, como ya explicamos en la introducción, es el conjunto de pasos
que debes seguir para conseguir un objetivo. Los programas que hemos hecho
tienen una serie de objetivos, que cumplen mediante algoritmos. En esta sección
quiero dar las primeras pinceladas sobre ellos, y, sobre todo, presentar
algunos que te permitan interiorizar algunos patrones de código. Además, en
secciones posteriores podremos utilizar estos simples algoritmos para introducir
conceptos más complicados (y útiles) del lenguaje.

Lo primero que vamos a ver es cómo expresar un algoritmo, un algoritmo se
a veces se expresa en lenguaje natural, es decir, como hablamos las personas,
si ya tenemos el código que lo ejecuta, también estamos expresando el algoritmo,
pero a veces es necesario utilizar herramientas intermedias, primero: porque
puede ser difícil codificar el algoritmo directamente sin pensarlo antes y,
segundo: porque hacer esto nos permite pensar en él sin tener que pensar en los
artefactos concretos del lenguaje que vamos a utilizar, lo que nos permite
dejar ese trabajo para más tarde.

Estas maneras intermedias son variopintas, por ejemplo, los diagramas del flujo
que utilicé en su momento son una de ellas. Otra manera es el
\textbf{pseudocódigo}, éste es un concepto que permite expresar los algoritmos
de modo estructurado, utilizando artefactos básicos de cualquier lenguaje de
programación: condicionales, bucles, llamadas a función... pero de una manera más
laxa. Veámoslo con un ejemplo: el algoritmo que nos permite eliminar las
repeticiones en un array expuesto en el programa \ref{lst:mallocAndFree}:
\nameref{lst:mallocAndFree}.

\begin{lstlisting}[style=pseudoCode]
algoritmo eliminar_repeticiones :=
entrada: array
solución = {}
para ii desde 0 hasta tamaño(array) - 1:
    elemento = array[ii]
    único = CIERTO
    para jj desde 0 hasta ii - 1:
        elemento2 = array[jj]
        si elemento es igual a elemento2:
            único = FALSO
    si único
        añadir elemento a solución
retornar solución
\end{lstlisting}

Como puedes ver, se entiende mejor lo que hace, porque nos estamos librando
de varios aspectos del lenguaje que no nos interesan, por ejemplo: asumimos
que podemos saber el tamaño del array sin necesidad de preocuparnos de dónde
viene; no tenemos que convertir las variables lógicas a números, podemos
asumir que añadir un elemento a un array es autoexplicativo, podemos ignorar
que hay reserva dinámica y simplemente decir que devolvemos el array. Visto
así, es un poco inútil, pero piensa que escribir esto \textbf{antes} de la
labor de codificación nos habría ayudado.

El problema del pseudocódigo es que podemos hacer <<trampas>>, es decir,
siempre podemos obviar varias cosas importantes que, a la hora de traducirlo a
código real, no sean triviales. Por eso, puedes decidir tú hasta qué punto
obvias o incluyes los artefactos del lenguaje. En este caso, por ejemplo,
podríamos incluir el asunto de que las dimensiones de los arrays no pueden
ser sabidos desde dentro de una función \textit{per se}.

\subsection{Recursividad}
A la hora de definir algunos algoritmos, se definen utilizándolos a ellos
mismos, es decir, parte de ellos incluye su propia utilización. Un ejemplo
clásico de este tipo de algoritmos es el número factorial. Sea $n$ un número
entero, $n$ factorial se denota como $n!$, que es igual a la multiplicación de
todos los números desde 1 hasta $n$. Es decir:

$$
n! = \prod^{n}_{i=1}{i}= 1\!\cdot\!2\!\cdot\!3\!\cdot\!4\dots{}n
$$

Siguiendo con el pseudocódigo, la manera de definir esto más evidente
es la \textbf{iterativa}, es decir, la que utiliza repeticiones mediante
bucles, las soluciones iterativas se contraponen frecuentemente a soluciones
\textbf{recursivas}. Veamos el pseudocódigo de esta manera de resolver el
problema:


\begin{lstlisting}[style=pseudoCode]
algoritmo factorial :=
entrada: n
resultado = 1
para i desde 1 hasta n:
    resultado = resultado*i
retornar resultado
\end{lstlisting}

Sin embargo; podemos sencillamente definir el factorial a partir de sí mismo,
volvamos a su definición matemática:
$$
n! = \prod^{n}_{i=1}{i}= n\!\cdot\!\!\prod^{n-1}_{i=1}{i} = n\left(n-1\right)!
$$

Entonces, si seguimos con este razonamiento, podemos definir el pseudocódigo
como:

\begin{lstlisting}[style=pseudoCode]
algoritmo factorial :=
entrada: n
si n es igual a 0:
    retornar 1
retornar factorial(n - 1) * n
\end{lstlisting}

Si saltamos a la implementación, veremos que es tan sencillo como que la función
se llama a sí misma. Como ya bien sabes, una función puede llamar a otra, y así
sucesivamente, pero nada dice que esa función no se llame a sí misma. El
único problema que tiene esto es que, si se diseña mal, se puede incurrir en
llamadas infinitas, esto provocaría que, como cada llamada sin finalizar
que se acumula añade a datos a la pila, ésta terminara por acabarse y nuestro
programa fallaría.
Para ver la comparación en la implementación con ambas soluciones, crearemos
dos versiones de la misma función, la iterativa y la recursiva, a la primera
la llamaremos \texttt{factorial\_interative} y a la segunda
\texttt{factorial\_recursive}.


\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C, caption={Ejemplo final de variables},
label={lst:factorialIterativeVsRecursive}]
unsigned long factorial_recursive(int n)
{
    if (n == 0) {
        return 1;
    }
    return factorial_recursive(n - 1) * n;
}

unsigned long factorial_iterative(int n)
{
    if (n == 0) {
        return 1;
    }
    unsigned long res = 1;
    for (int i = 1; i <= n; ++i) {
        res *= i;
    }
    return res;
}
\end{lstlisting}
\end{minipage}

Este ejemplo es tan clásico porque se aprecian bien las diferencias de las dos
formas de resolver el problema y, además, se aprecian bien las partes de una
función recursiva. Una función recursiva, en términos generales, debe tener dos
componentes: un caso base y la llamada (o llamadas) recursivas.
El primero está aquí
representado por el condicional, una función recursiva se basa en utilizar
una definición circular, es decir, defines una función usándola a ella misma,
para poder salir de ese ciclo, debe haber un momento en que demos la respuesta
por sabida. Este caso base es cuando $n$ es igual a cero, caso en que la respuesta
es inmediata porque sabemos por definición matemática que es 1. La llamada
recursiva es la siguiente línea.

Comparando las dos soluciones, la primera es lo que se llama más <<elegante>>,
en el sentido de que es una definición más legible (tanto así que podría decirse
que es trivial) mientras que la iterativa es más larga y menos trivial. Sin
embargo; es en general más eficiente la versión iterativa de un algoritmo que
su versión recursiva. Esto es porque las sucesivas llamadas a función tienen
cierto coste, obligan a hacer copias de datos, cada vez que invoques a la
función, $n$ será copiada en la pila, una copia encima de otra, hasta que llegues
a la invocación del caso base. En ese momento, la llamada del caso base
retornará y se empezará a desenrollar esa sucesión de llamadas a la función.

Por contraposición, la solución iterativa no tiene esa necesidad de copiar nada,
ni de ir llamando a funciones una y otra vez, es un simple bucle. Es razonable
pensar que la primera será más lenta. Déjame que lo compruebe y te dé los
resultados para que puedas verlo. La solución recursiva tarda 1,7431 veces más
que la solución iterativa, por lo que se puede apreciar que es más lenta.
Además, recuerda la pila, utiliza más memoria.
En resumen: los algoritmos iterativos son más rápidos que sus contrapartes
recursivas, pero menos elegantes.

Otro ejemplo más claro de las diferencias entre ambos métodos se puede ver en
el cálculo de la sucesión de Fibonacci. Someramente: esta sucesión fue creada
por un matemático italiano en el siglo \textsc{xiii}, cuyo nombre da a esta
sucesión. Es una sucesión que se define así: los dos primeros elementos son 1,
y los demás se definen como la suma de los dos anteriores (ya
se ve que aquí hay un caso base y una definición recurrente). Matemáticamente se
definiría así:
$$
a_1 = 1, a_2 = 1, \forall_{n=3}^{\infty}\left(a_n = a_{n-1} + a_{n-2}\right)
$$

Creo que entiendes que esto, iterativamente, se puede resolver con un bucle,
como el cálculo del factorial. Así que saltemos a la definición recursiva:


\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C, caption={Función para el cálculo de la suceción
de Fibonacci},
label={lst:funFibonacci}]
unsigned long fibonacci(unsigned int n) {
    if (n < 3) {
        return 1;
    }
    return fibonacci(n - 1) + fibonacci(n - 2);
}
\end{lstlisting}
\end{minipage}

Como puedes ver, seguimos el mismo patrón: un condicional que comprueba el caso
base y una llamada recursiva. El caso base es lógico, el primer y segundo
elemento son uno, así que se devuelve uno siempre que $n$ sea menor que tres.
Por otro lado, esto hace que también devolvamos uno cuando se introduce cero,
pero esto es una simplificación que nos podemos permitir. Es la llamada
recursiva la que nos interesa, como puedes ver, hay dos llamadas a esta función
por cada llamada que no sea un caso base. Esto es importante, porque debes tener
claro en qué orden se ejecutan estas llamadas, por esto, vamos a representarlo
aquí.
\begin{itemize}
\item Llamamos a la función para el valor 5
    \begin{itemize}
        \item Se llama a la función para el valor 4
        \begin{itemize}
            \item Se llama a la función para el valor 3
            \begin{itemize}
                \item Se llama a la función para el valor 2
                \item Se devuelve 1.
            \end{itemize}
            \begin{itemize}
                \item Se llama a la función para el valor 1
                \item Se devuelve 1.
            \end{itemize}
            \item Se devuelve 2
        \end{itemize}
        \begin{itemize}
            \item Se llama a la función para el valor 2
            \item Se devuelve 1.
        \end{itemize}
    \item Se devuelve 3
    \end{itemize}
    \begin{itemize}
        \item Se llama a la función para el valor 3
        \begin{itemize}
            \item Se llama a la función para el valor 2
            \item Se devuelve 1.
        \end{itemize}
        \begin{itemize}
            \item Se llama a la función para el valor 1
            \item Se devuelve 1.
        \end{itemize}
        \item Se devuelve 2
    \end{itemize}
    \item Se devuelve 5
\end{itemize}

Estas listas anidadas expresarían cómo funciona la secuencia de llamadas a las
funciones recursivas. Puedes observar varias cosas, la primera es que, incluso
para una llamada pequeña, el quinto elemento, se realiza un gran número de
llamadas a función. Por otro lado, si lo miras bien, se repiten un montón de
cálculos, la llamada para tres se repite dos veces, la llamada a dos tres
veces... y esto sólo para el valor de $n$ igual a cinco. Esto te da la medida
de que la implementación recursiva de este tipo de funciones es muy ineficiente.
Técnicas más avanzadas permiten mitigar esto. En conclusión, es
muy poco recomendable realizar esta implementación.

Y, si esto es así, si los algoritmos recursivos son así de ineficientes, lo
lógico sería pensar que no se utilizan. Sí, se utilizan porque hay algoritmos
que están definidos simplemente de un modo recursivo, es decir, que no es
posible implementar iterativamente (o dicha implementación sería una
simulación de la recursividad que aportaría poco), pero esos algoritmos son más
complicados y serían problemáticos como primeros ejemplos del concepto de
recursividad.

\subsection{Algoritmos de ordenación}
Uno de los conjuntos de algoritmos más elementales que existen en el conjunto
básico de algoritmos de ordenación, entre ellos veremos los siguientes:
\begin{enumerate}
\item De burbuja.
\item Selección.
\item Inserción.
\item \textit{Quick sort}.
\end{enumerate}
Esto es así porque esta tarea (ordenar un vector o array) es muy común y permite
una enorme cantidad de innovación, muchos autores de trabajos científicos se
esfuerzan en proponer mejoras en estos algoritmos. Además, es una operación
muy común y básica en la informática. Los primeros algoritmos son más bien
sencillos, así que hablaremos directamente sobre la implementación en C, pero
los dos últimos necesitarán de una explicación más pausada.

El algoritmo de la burbuja se basa en comparar cada elemento con el siguiente
y, si no están en orden, intercambiarlos. Veamos cómo se haría:

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Implementación del algoritmo de la burbuja},
label={lst:bubbleSort}]
void bubble_sort(int *list, int list_size) {
    for (int ii = 0; ii < list_size - 1; ++ii) {
        for (int jj = 0; jj < list_size - 1; ++jj) {
            if (list[jj] > list[jj + 1]) {
                int aux = list[jj];
                list[jj] = list[jj + 1];
                list[jj + 1] = aux;
            }
        }
    }
}
\end{lstlisting}
\end{minipage}

Es el algoritmo de ordenación más simple, porque, como puedes ver, se compone
de dos bucles anidados y un condicional. Rápidamente: recorres el array,
pero como estás comparando con el siguiente elemento, paras una posición antes.
Si el elemento anterior (\verb!list[jj]!) es mayor que el que viene después,
los cambias. Para cambiarlo simplemente guardas uno en una variable auxiliar,
asignas el otro al primero y finalmente pones la variables auxiliar en el
hueco libre. Esto, hecho una sola vez, provocaría que el elemento más grande
subiera al último puesto del array. Y he usado el verbo subir porque es de
este tránsito del que deriva el nombre del algoritmo, porque los elementos
suben como burbujas de aire en el agua.
De hecho, puedes probar
a ejecutar la función cambiando la condición del primer bucle a \verb!ii < 1!.
Y verás como sólo el último elemento está siempre en orden.

Este algoritmo tiene una ventaja fundamental: utiliza muy poca memoria. Es más,
si obviamos las variables auxiliares, los argumentos en la pila y demás, la
única memoria ocupada es la variable auxiliar, es decir, el tamaño del tipo
de dato que estés ordenando, en este caso: cuatro bytes. En informática casi
siempre se hace un compromiso (en inglés: \textit{trade-off}) entre memoria y
velocidad. Los algoritmos que consumen más memoria para hacer lo mismo suelen
ser más rápidos que los diseñados para ocupar poca memoria. El algoritmo de
la burbuja es un ejemplo claro.

Como añadido, vamos a prestar atención a la realización del intercambio de
elementos: como es algo que voy a usar en todos o casi todos los algoritmos,
vamos a crear una función llamada \verb!swap!, que nos permita intercambiar
rápidamente dos elementos de tipo entero. Veamos cómo quedaría el algoritmo
de la burbuja y cómo sería la definición de la función.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Implementación de \texttt{swap} y uso en algoritmo de la burbuja},
label={lst:bubbleSwap}]
void swap(int *a, int *b)
{
    int aux = *b;
    *b = *a;
    *a = aux;
}

void bubble_sort(int* list, int list_size)
{
    for (int ii = 0; ii < list_size - 1; ++ii) {
        for (int jj = 0; jj < list_size - 1; ++jj) {
            if (list[jj] > list[jj + 1]) {
                swap(&list[jj], &list[jj + 1]);
            }
        }
    }
}
\end{lstlisting}
\end{minipage}

El siguiente algoritmo es el de selección. Este algoritmo se basa en elegir
(seleccionar) el elemento menor y ponerlo en la última posición del array
que tengamos ordenada. Al principio no hay ninguna, cuando hayas puesto una,
deberás poner el siguiente elemento después de esa, y así sucesivamente,
veámoslo:

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Algoritmo de selección},
label={lst:selectionSort}]
void selection_sort(int *list, int list_size)
{
    int ordered = 0;
    while (ordered < list_size) {
        int min_value = list[ordered], min_pos = ordered;
        for (int jj = ordered; jj < list_size; ++jj) {
            if(list[jj] < min_value){
                min_value = list[jj];
                min_pos = jj;
            }
        }
        swap(&list[ordered], &list[min_pos]);
        ++ordered;
    }
}
\end{lstlisting}
\end{minipage}

Esta implementación es un poco ingenua, porque nunca comprobamos si el elemento
siguiente al ordenado resulta estar ordenado. Es evidente que una implementación
un poco más inteligente añadiría una variable para discernir esto, queda como
ejercicio. Con la implementación que tenemos, podemos ver bien cómo funciona,
que es lo que nos interesa. La quinta línea es un poco complicada porque junto
dos declaraciones con sus inicializaciones, pero ya hay que ir acostumbrándose.

Si te das cuenta, este algoritmo ocupa marginalmente más memoria que el de la
burbuja. En este caso debemos mantener siempre en memoria el valor y la
posición del elemento más pequeño. En cambio, es un poco más rápido, ¿por qué?
Porque en el peor de los casos, este algoritmo hace $n!$ comparaciones y
$n$ intercambios. En el algoritmo de la burbuja haremos las mismas comparaciones
y, sin embargo, haremos muchos más intercambios, porque los elementos van
<<pasito a pasito>>, no a su lugar directamente como en este caso.

El siguiente algoritmo es el de inserción. En el anterior elegíamos el elemento
más pequeño y lo poníamos al principio, en este, el razonamiento es el
contrario, crearemos una lista que definiremos como ordenada, inicialmente
vacía, después, cogeremos un elemento de la lista original y lo insertaremos
en la posición que le corresponda en la lista ordenada. De este modo, la lista
ordenada siempre permanecerá así. Veamos un pseudocódigo más claro:

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=pseudoCode]
algoritmo insertion_sort :=
entrada: array
lista_ordenada = {}
para i desde 0 hasta size(array):
    insertar_ordenado(lista_ordenada, array[ii])
array = lista_ordenada
\end{lstlisting}
\end{minipage}

El problema de esto es que insertar en una lista ordenada es algo lo
suficientemente complejo como para necesitar su propia definición. Vamos
a definir un algoritmo que inserte un elemento en una lista, pero que
\textbf{cuenta con que ya está reservada la memoria}.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=pseudoCode]
algoritmo insertar_ordenado :=
entrada: array, elemento
insertado = 0
para i desde 0 hasta size(array):
    si array[ii] es mayor que elemento:
        insertar(array, elemento, ii)
        insertado = 1
        break
si no insertado:
    insertar(array, elemento, ii)
\end{lstlisting}
\end{minipage}

Pero seguimos teniendo el problema de cómo insertar, en general, un elemento
en una posición dada, para esto utilizaremos otro algoritmo:

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=pseudoCode]
algoritmo insertar :=
entrada: array, elemento, posición
insertado = 0
para i desde size(array) hasta 0 en paso de -1:
    array[ii] = array[ii - 1]
array[posición] = elemento
\end{lstlisting}
\end{minipage}

Es un poco confuso, pero lo que hacemos es, primero, mover los elementos
posteriores a la posición donde queremos insertar una posición a la derecha,
abriendo así el hueco para el nuevo elemento, después, insertamos el elemento.
Como puedes ver, ya en este algoritmo tenemos que hacer acopio de una serie
de funciones intermedias. Aunque este algoritmo se suele implementar
de un modo más sencillo, aquí lo vamos a hacer así para que empieces a ver
la utilidad de extraer el comportamiento en funciones más pequeñas que se
entiendan mejor en vez de escribir funciones muy largas. La implementación
de las funciones auxiliares sería tal que:


\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Algoritmos auxiliares al de inserción},
label={lst:insertionAuxiliar}]
void insert_at(int* list, int list_size, int position, int element)
{
    for(int ii = list_size; ii != position; --ii){
        list[ii] = list[ii-1];
    }
    list[position] = element;
}

void insert_at_ordered(int* list, int list_size, int element) {
    int inserted = 0;
    for(int ii = 0; ii < list_size; ++ii){
        if(list[ii] > element){
            insert_at(list, list_size, ii, element);
            inserted = 1;
            break;
        }
    }
    if(!inserted){
        insert_at(list, list_size, list_size, element);
    }
}
\end{lstlisting}
\end{minipage}


\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Algoritmo de inserción},
label={lst:insertionSort}]
void insertion_sort(int* list, int list_size)
{
    int ordered_list[list_size];
    int ordered_size =0;
    for (int ii = 0; ii < list_size; ++ii) {
        insert_at_ordered(ordered_list, ordered_size, list[ii]);
        ordered_size++;
    }
    memcpy(list, ordered_list, sizeof(int) * list_size);
}
\end{lstlisting}
\end{minipage}

Este algoritmo es el que usamos inconscientemente para ordenar objetos físicos
cuando los tenemos. Si tuvieras los números $\left\{5,4,6,9,8\right\}$,
probablemente cogerías el cinco y lo pondrías después del cuatro, verías que el
seis está en orden, después verías el nueve y lo pondrías detrás del ocho.
De todos modos, si has pensado que lo que tú harías sería selección, sí, sería
posible que te resultara cómodo hacer eso también.

Pero la manera en que lo hemos implementado es muy ingenua, utilizamos muchos
más pasos de los necesarios. Hay una manera más sencilla si nos damos cuenta
de que podemos realizar todas las operaciones en la misma lista. Para ello
voy a ponerte un ejemplo, imagínate la lista:
\begin{tabular}{|c|c|c|c|c|}
\hline
\textbf{2}&\textbf{6}&2&5&7\\\hline
\end{tabular}

Las celdas en negrita son los elementos de la lista ordenada, lo que vamos
a hacer es guardanos el siguiente elemento después de ellos en una variable,
es decir, el dos. Después, vamos a mover todos los elementos de la lista ordenada
mayores que dos una posición a la derecha, quedando el array así:
\begin{tabular}{|c|c|c|c|c|}
\hline
\textbf{2}&\color{white}2\normalcolor&\textbf{6}&5&7\\\hline
\end{tabular}.
Con una posición vacía, como puedes ver. Ese hueco se utiliza
para colocar el elemento que está en la variable que hemos mencionado antes,
quedando el array así:
\begin{tabular}{|c|c|c|c|c|}
\hline
\textbf{2}&\textbf{2}&\textbf{6}&5&7\\\hline
\end{tabular}
Si sigues a mano esta ejecución verás que nos guardaríamos el cinco, moveríamos
el seis, pondríamos el cinco a la izquierda del seis; nos guardaríamos el siete
volveríamos a mover el seis, pondríamos siete en el hueco libre y el array
quedaría ordenado. La implementación de esto sería, por ejemplo, la siguiente:

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C, label={lst:insertionOptimized},
caption={Implementación alternativa de ordenación por inserción}]
void insertion_sort_optimized(int *array, int array_size)
{
    int element;
    for (int ii = 1; ii < array_size; ii++) {
        element = array[ii];
        int jj;
        for (jj = ii - 1; jj >= 0; --jj) {
            if (array[jj] <= element) {
                break;
            }
            array[jj + 1] = array[jj];
        }
        array[jj + 1] = element;
    }
}
\end{lstlisting}
\end{minipage}

La lógica de esto quizá es menos evidente. El bucle exterior es
muy sencillo, recorremos todo el array \textbf{desde la segunda posición}.
Nos guardamos el elemento siguiente a los ordenados en la variable
\verb!element!. Después, en este bucle \verb!for! interno moveremos todos los
elementos de la lista ordenada a la derecha una posición, en orden inverso,
por eso \verb!jj! disminuye de uno de uno. Cuando hemos encontrado el elemento
que es mayor, paramos (\verb!break!). Finalmente, ponemos el elemento en su
sitio.

Finalmente, llegamos al algoritmo \textit{Quick Sort}, que, como puedes ver,
no se basa en cómo lleva a cabo la tarea de ordenación sino por una cualidad
muy interesante del mismo: es un algoritmo muy rápido. Si recuerdas lo que he
dicho unos párrafos antes, en informática, velocidad y memoria ocupada son
valores ortogonales (perpendiculares, cuando uno se propicia, es en detrimento
del otro). Me interesa especialmente que lo veas porque \textbf{es un algoritmo
recursivo}. Y es uno de esos algoritmos que es puramente así.
Además, como es más complejo (como probablemente hayas podido deducir), vamos a
ver primero su pseudocódigo.


\noindent
\begin{minipage}[H]{\linewidth}
\begin{lstlisting}[style=pseudoCode]
algoritmo quick_sort :=
entrada: array
lista_pequeña = {}
lista_grande  = {}
pivote        = array[0]
si size(array) es igual a 1:
    res = {pivote}
    retornar res
para i desde 0 hasta size(array):
    si array[i] es menor que pivote:
        añadir(array[i], lista_pequeña)
    en otro caso:
        añadir(array[i], lista_grande)
lista_pequeña_ordenada = quick_sort(lista_pequeña)
lista_grande_ordenada  = quick_sort(lista_grande)
res = juntar(lista_pequeña_ordenada, pivote, lista_grande_ordenada)
retornar res
\end{lstlisting}
\end{minipage}

Este algoritmo se resume en lo siguiente: el caso base es cuando la lista
es de tamaño uno, porque una lista de un elemento siempre está ordenada.
Cuando no estamos en el caso base, creamos dos listas: en una irán los elementos
menores que el pivote, y en otra los demás. El pivote es sencillamente un
elemento cualquiera de la lista, a este nivel es irrelevante cuál, aunque
su elección influye mucho en la eficiencia del algoritmo en casos especiales,
es decir, con arrays concretos.
La implementación de este algoritmo es la siguiente:

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Implementación de \textit{Quick Sort}},
label={lst:quick_sort}]
int *quick_sort(int *list, int list_size)
{
    int *biggers          = NULL, *smallers         = NULL,
        *biggers_ordered  = NULL, *smallers_ordered = NULL,
        *res              = malloc(list_size * sizeof(int));

    int bigger_size = 0, smaller_size = 0, pivot = 0;

    if (list_size == 1) {
        *res = list[0];
        return res;
    }

    if(list_size == 0){
        return NULL;
    }

    pivot = list[0];
    biggers = malloc(sizeof(int) * list_size);
    smallers = malloc(sizeof(int) * list_size);

    for (int ii = 1; ii < list_size; ++ii) {
        if (list[ii] < pivot) {
            smallers[smaller_size] = list[ii];
            smaller_size++;

        }
        else {
            biggers[bigger_size] = list[ii];
            bigger_size++;
        }
    }

    biggers  = realloc(biggers, sizeof(int) * bigger_size);
    smallers = realloc(smallers, sizeof(int) * smaller_size);

    biggers_ordered  = quick_sort(biggers, bigger_size);
    smallers_ordered = quick_sort(smallers, smaller_size);

    memcpy(res, smallers_ordered, sizeof(int) * smaller_size);
    res[smaller_size] = pivot;
    memcpy(res + smaller_size + 1,
               biggers_ordered, sizeof(int) * bigger_size);

    free(biggers);
    free(smallers);
    free(smallers_ordered);
    free(biggers_ordered);
    return res;
}
\end{lstlisting}
\end{minipage}

El algoritmo es un poco más complicado así que lo que era en el pseudocódigo,
pero debes seguirlo paralelamente a aquél. Lo primero es la declaración de todas
las variables. De nuevo, vamos a empezar a declarar varias juntas, o si no las
funciones de harían interminables. Nota que inicializamos sin comprobar
nada la variable \texttt{res} (que es donde guardaremos el resultado)
llamando a \texttt{malloc} para reservar un vector del mismo tamaño de la lista.
No hay peligro porque llamar a \texttt{malloc} para reservar cero bytes es
totalmente seguro. Después, como ya es normal en nuestras funciones recursivas,
comprobamos si estamos o no en el caso base, el caso base es tanto una lista
que mida uno como una lista vacía. Ambas listas están ordenadas por definición.

Después, empieza el caso recursivo, lo primero es leer el valor del pivote,
lo hacemos ahora porque antes de comprobar el tamaño de la lista no sabemos
si hay primer elemento. Ahora reservamos memoria para las listas de los
elementos mayores y menores que el pivote respectivamente. Esto también lo hemos
visto antes: como no sabemos cuánto pueden medir, utilizamos un umbral superior,
en este caso es evidente que ninguna de estas listas puede medir más que el
tamaño de la lista original. Después entramos en el bucle que cribará qué
elementos van a cada lista. Como aquí estamos limitados por las restricciones de
C, tenemos que hacerlo así: copiamos el elemento en cuestión a la posición
siguiente al final de la lista (que es igual a su tamaño) y aumentamos
en uno el tamaño. Cuando hemos terminado el bucle, procedemos a redimensionar
las listas de elementos mayores y menores al tamaño real que deben tener. Del
mismo modo que con \verb!malloc!, si se llama con un tamaño de cero no hay
problemas, además, es equivalente a llamar a \verb!free!, pero el puntero
sigue siendo válido para pasarse a esta función.

Ahora que ya tenemos ambas listas, simplemente llamamos al mismo \textit{Quick
Sort} que nos otorgará las listas ordenadas. Del mismo modo que cuando
te expliqué cómo utilizar \verb!memcpy!, copiamos juntos la lista de elementos
menores, el pivote y la lista de elementos mayores. Una vez hecho esto, sólo
nos queda liberar la memoria que hemos utilizado para almacenar datos
auxiliares. En este caso, las cuatro listas. Es evidente que con todas estas
reservas de memoria este algoritmo consume mucho más que los anteriores, pero,
además, recuerda lo que pasa con las funciones recursivas, esta memoria que
hemos reservado se quedará bloqueada hasta que se terminen las llamadas
recursivas, es decir, cada llamada tendrá sus propias copias de las listas.
Esto explica, además, por qué \textit{Quick Sort} es un algoritmo que
no modifica la lista que se le pasa sino que
\textbf{devuelve el resultado en otra}.

Ahora que ya hemos visto el algoritmo conceptual y la implementación de los
algoritmos de ordenación, vamos a comparar su rendimiento en términos de tiempo
de ejecución. Lo que voy a hacer es crear un vector de un tamaño grande, lo voy
a ordenar con un algoritmo, volveré a introducir datos aleatorios en el vector,
lo volveré a ordenar y así sucesivamente. Los resultados son, para 262.144
elementos:

\begin{table}[H]
\begin{tabularx}{\linewidth}{|Y|R|}
\hline
\textbf{Algoritmo}    &\multicolumn{1}{c|}{\textbf{Tiempo $(s)$}}\\\hline
Burbuja               &243,0596                                \\\hline
Selección             &71,2807                                 \\\hline
Inserción             &56,7917                                 \\\hline
Inserción (optimizado)&37,1698                                 \\\hline
\textit{Quick Sort}   &0,0656                                  \\\hline
\end{tabularx}
\caption{Tiempos de ejecución de los distintos algoritmos}
\label{tab:sortingTimes}
\end{table}

Como puedes ver, en cada algoritmo se realiza una mejora bastante importante
respecto al anterior, pero es muy llamativo que \textit{Quick sort} destaque
tanto. Como reflexión: yo no le pondría a un algoritmo que he hecho yo
un nombre tan poco modesto si no fuera al menos mayormente cierto. Sin embargo;
hay ciertos aspectos que hay que tener en cuenta en un algoritmo como estos
más allá de que sean rápidos, por ejemplo, como ya dijimos, \textit{Quick sort}
consume mucha más memoria que todos los demás. Si utilizáramos este algoritmo
en ciertas máquinas quizás nos viéramos con problemas de memoria. Además, hay
una cualidad de los algoritmos llamada \textbf{estabilidad}, que representa
cómo de constante para diferentes casos es el uso de tiempo, memoria, o ambas.
En el caso de estos algoritmos, los únicos estables son el de burbuja y el de
selección. Esto quiere decir que los resultados de los demás pueden variar mucho
en ciertos casos, por lo que si trabajas en sistemas donde esos casos ocurren
con cierta frecuencia o donde la estabilidad es más importante
que la velocidad media, quizás debas usar uno de los
algoritmos más lentos.

El ejemplo más flagrante de esto es lo que le pasa al último algoritmo con
el vector más desfavorable. Para \textit{Quick sort} el peor caso es, irónicamente,
un array que ya esté ordenado (o que esté ordenado inversamente). Si vuelves a
su descripción o a su implementación, verás fácilmente
por qué, al elegir el primer elemento como pivote,
si está ordenado, consistentemente todos los elementos caerán en la lista de
elementos mayores, es decir, por cada nivel de recursividad sólo disminuiremos
el vector en una posición. Eso implica que, en este caso, para un vector de mil
posiciones, haremos mil llamadas recursivas que harán sendas copias del vector
midiendo éstas mil, 999, 998, etc. Eso es insostenible a la mínima que el
vector sea muy grande. Vamos a comparar el algoritmo de selección
(que es estable), con \textit{Quick Sort} en un vector ya ordenado.

El primer hecho que te llamará la atención es que no puedo utilizar la misma
cantidad de elementos que en la comparación anterior, esto es porque mi
ordenador no cuenta con memoria suficiente para que \textit{Quick Sort} termine
bajo estas condiciones. He utilizado un vector de 65.536 elementos. El
algoritmo de selección tarda 4,58 segundos y \textit{Quick Sort} tarda, ni más
ni menos que 21,55. Aquí es donde entra en juego la estabilidad, selección
es de media peor, pero nunca tarda mucho más. De hecho, como sí que puedo
ejecutar el algoritmo de selección sobre 262.144, vamos a que cuánto tarda y
compararlo con el resultado bajo el vector aleatorio.

Selección tarda 72,05 segundos, como puedes ver, casi exactamente lo mismo
que con un vector aleatorio. Además, el consumo de memoria es siempre el mismo,
cualidad que comparte con los algoritmos anteriores a él.
Esto demuestra que hay que tener
en cuenta más factores aparte de lo rápido que sea un algoritmo, pero todas
estas cosas sería objeto de un libro en sí mismo y de un curso de agoritmia que
no ha lugar, el motivo de esta sección es más bien enunciar la existencia de
este tipo de problemas y mostrar la importancia de la elección e implementación
de algoritmos para tareas incluso tan prosaicas como ordenar un array.

\subsection{Búsqueda}
La búsqueda es otra de las tareas más importantes de un informático o
programador, pero la búsqueda depende de dónde estés buscando. Hasta ahora sólo
conocemos la estructura del array o del vector, que en relación a la búsqueda
son indistinguibles. La búsqueda es, dado un valor, encontrar en la estructura
el valor dado, o la primera ocurrencia de él. Es evidente cómo resolver este
problema en general, un bucle que compruebe si el elemento concreto del vector
es igual al elemento que queremos buscar. Si esto es así, se devuelve el
índice donde se encuentra, si no, se devuelve un valor que generalmente es -1
o cualquier negativo.

Pero hay una manera de buscar más rápidamente en un array o vector, si éste está
ordenado, puedes buscar con la búsqueda binaria. Se llama binaria porque te
mueves en dos direcciones: empiezas en el medio del array y compruebas si éste
es menor que el que buscas, vas hacia delante en el array un cuarto de su
longitud, repites la operación y vuelves a dividir entre dos la distancia que
saltas. Veamos el pseudocódigo.


\noindent
\begin{minipage}[H]{\linewidth}
\begin{lstlisting}[style=pseudoCode]
algoritmo búsqueda_binaria :=
entradas: array, objetivo

mientras array no es igual a {}:
    pos = centro(array)
    elemento = array[pos]
    si elemento es igual a objetivo:
        retornar pos
    si elemento es menor que objetivo:
        array = mitad_después(array, pos)
    si elemento es mayor que objetivo:
        array = mitad_antes(array, pos)

retornar -1
\end{lstlisting}
\end{minipage}

Básicamente, aprovechamos que el array o vector está ordenado para que, cuando
elegimos una posición, sepamos que necesariamente el elemento que buscamos
está en la mitad del array que quede después o antes de este elemento. Dividimos
pues el tamaño del problema entre dos en cada iteración de este proceso hasta
que queda sólo el elemento que buscamos (si sólo hay uno) o nada, y por tanto
no existe el elemento.


\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Implementación del algoritmo de búsqueda lineal},
label={lst:binarySearch}]
int binary_search(int* array, int array_size, int target)
{
    int low_end = 0;
    int high_end = array_size;
    while (high_end != low_end) {
        int pos = (high_end - low_end) / 2 + low_end;
        int element = array[pos];
        if (element == target) {
            return pos;
        }
        else if (element < target) {
            low_end = pos;
        }
        else if (element > target) {
            high_end = pos;
        }
    }
    return -1;
}
\end{lstlisting}
\end{minipage}

Como en C dividir arrays es complicado, vamos a realizar el juego con las
posiciones. Definimos un umbral inferior y otro superior que serán
los límites de la zona donde queremos buscar (la parte del array donde
puede estar el elemento buscado). Lo que hacemos es siempre situarnos
en el medio de esa zona del array y comprobar si hemos dado con el elemento
que queremos, si no, vemos si es menor o mayor que donde estamos. Si el objetivo
es mayor que donde estamos, movemos el límite inferior aquí,
decir: sabemos que lo que buscamos no puede estar antes de la posición actual.
Si el objetivo es menor, sabemos que debe estar antes. Si en algún momento los
límites colisionan, es que nos hemos quedado sin zona que buscar y devolveremos
-1.

La ventaja que tiene este algoritmo reside en un comentario que he dejado caer
unos pocos párrafos atrás, cada vez que comprobamos si un elemento es el que
buscamos, dividimos el problema entre dos. Esto quiere decir que, de media,
haremos $\log_{2}{\left(n\right)}$ comprobaciones. En el caso de la búsqueda <<normal>>, en
cualquier array, de media haremos $\frac{n}{2}$ comprobaciones. Esto hace que
sea un algoritmo más deseable, aunque hay que tener en cuenta que el array
debe estar ordenado, y si no lo estaba, esto tiene un coste. Lo ideal es
que se utilice con arrays que se mantengan siempre ordenados, es decir, donde
las inserciones se hagan ordenadas, pero eso tiene un coste a su vez porque
hay que mover los elementos en la operación de inserción.

%\subsection{Cómo dividir funcionalidad entre distintos archivos}
%Aunque esto es en sentido estricto un manual de programación, y no de
%ingeniería del \emph{software}, tenemos que hablar de algunos consejos sobre
%cómo dividir tu funcionalidad en distintos archivos, ahora que ya saber hacerlo.
%Como la mejor manera de aprender a montar en bicicleta es montando, vamos a
%utilizar un ejemplo para ver de qué manera podemos dividir entre archivos
%funcionalidades distintas. Vamos a hacer un programa que calcule el camino
%más corto entre en un punto A y un punto B en un mapa. Para ello, deberemos
%hacer estas cosas:
%
%\begin{enumerate}
%\item Crear mapas
%\item Guardar mapas en un archivo y leerlos de él
%\item Encontrar el camino de un punto A al punto B sabiendo que es el más corto.
%\end{enumerate}
%
%En general, lo primero que se suele hacer cuando te encuentras con un problema
%complejo es preguntarse qué vamos a modelar en nuestro sistema. Un modelo es,
%en términos generales, una simplificacion de la realidad que nos permite
%entenderla y actuar sobre ella o predecirla. En informática, cuando tienes una
%realidad, lo primero es crear un modelo de datos que nos permita manejarlo
%dentro del lenguaje de programación.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Algoritmos genéricos}
Ahora que ya sabemos qué es un algoritmo en sus términos más elementales y
que conocemos algunos con una complicación suficiente como para retarnos,
podemos dar un paso más: hacer que estos algoritmos sean más <<puros>>, sean
simplemente un conjunto de instrucciones, pero sean ignorantes de qué tipo
de dato van a recibir o de qué operación van a realizar. Dicho así, esto es
confuso, pero lo vas a entender fácilmente. En la sección anterior hemos
implementado varios algoritmos que manejan arrays, y, aunque no lo he dicho,
si retrocedes ahora y miras el código de ejemplo, siempre verás que son
arrays o vectores de enteros, nunca de otro tipo de dato. El problema es que,
como supondrás, el proceso de ordenación de un array de enteros es similar
al de un array de cualquier tipo de dato que admita ordenación. Por ejemplo,
de decimales.

Pensarás que, entonces, siempre podemos copiar el código de la ordenación de
elementos de tipo \verb!int! y sustituir \verb!int! por \verb!double!.
Podríamos, pero esta manera de proceder tiene un defecto muy problemático:
duplica código. Duplicar código es malo por dos motivos: hace nuestros
ejecutables más grandes, y nuestro código en general \textbf{menos mantenible}.
Dicho en términos entendibles, es más difícil que le pases ese código a alguien
y lo entienda rápido y, en caso de haber un error o comportamiento no definido,
lo resuelva rápido. Imagínate que encontramos un error en la implementación de
la función de ordenación, sea la que sea. Tendríamos que rastrear a mano todas
las copias para eliminar ese error. Además, somos programadores:
nuestro objetivo es hacer más con menos.

Para esto tenemos dos herramientas genéricas, la primera es el puntero a
\verb!void!. Cuando te prensenté el puntero a \verb!NULL! y la reserva
de memoria dinámica te dije que \verb!malloc! devuelve un puntero a \verb.void.
que luego se convertirá a cualquier tipo que necesites. Es decir, el puntero
a \verb.void. se convierte implícitamente en el que tú quieras, con la
asignación. Además, después, \verb.realloc. o \verb.free. rediben punteros a
\verb.void. que no necesitas convertir para pasárselo. En resumen: en C el
puntero a \verb.void. tiene conversión implícita a todos los tipos, y todos
los tipos a \verb!void!.

Esto tiene una potencia enorme, porque podemos recibir un puntero a \verb"void"
cuando no sepamos lo que vamos a recibir. El problema es que un puntero de este
tipo \textbf{no se puede desreferenciar}. Como ya te dije en su momento,
no se puede interpretar un puntero a \verb!void!. Sólo se puede interpretar
si asumimos algún tipo y asignamos este puntero sin tipo a uno con él.
Por ejemplo, veamos una función que invierta un array
\textbf{de cualquier tipo}.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Inversión de arrays de cualquier tipo},
label={lst:genericArrayInversion}]
void invert_array(void* array, int array_size, int type_size)
{
    void *var = malloc(type_size);
    for (int ii = 0; ii < array_size / 2; ++ii) {
        void* element = array + (ii * type_size);
        void* opposite = array + (array_size - 1 - ii) * type_size;
        memcpy(var, element, type_size);
        memcpy(element, opposite, type_size);
        memcpy(opposite, var, type_size);
    }
    free(var);
}
\end{lstlisting}
\end{minipage}

Como puedes ver, se parece mucho a como lo harías sabiendo su tipo, pero hay
que recibir como argumento el tamaño del tipo de dato. Lo que hacemos en
el bucle es crear dos punteros que representan los dos elementos que tenemos
que intercambiar, no podemos hacerlo con variables porque no sabemos el tipo.
Estos punteros no son necesarios, pero, siendo sinceros, sin ellos las líneas
quedan totalmente ilegibles. Después, usamos la función \verb!memcpy! para poder
mover el elemento en la posición \verb!ii! a una variable auxiliar, el elemento
en la posición opuesta (\verb!ii - 1 - array_size!) a la i-ésima y después desde
la variable al elemento opuesto.

Lo primero que se nota es algo evidente: una función sencilla enseguida se
convierte en algo más complicado de leer, porque no podemos usar operadores,
sino que tenemos que usar llamadas a función. Pero debes admitir que, ahora,
podemos invertir todos los tipos de arrays sin duplicar nada de código. También
hay una cuestión importante: mientras que el operador de asignación y saber
el tipo provoca que el compilador pueda mapear las operaciones que escribas con
operaciones del procesador para mover bytes en paquetes de cuatro u ocho, por
ejemplo, haciéndolo así, \verb!memcpy! se ve obligado a copiar byte a byte.
Esto hace que los algoritmos genéricos creados así sean más lentos que sus
contrapartes específicas.

Hay muchos ejemplos de algoritmos que bien pueden utilizar esta técnica, pero
sólo con esto no podemos terminar de solucionar el problema. Vamos a crear
una función que imprima un array de elementos genéricos. La función, con las
herramientas que tenemos, quedaría así:


\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Imprimir arrays de varios tipos},
label={lst:genericPrintf}]
void print_array_generic(void*       array,
                         size_t      array_size,
                         const char* separator,
                         type_t      type)
{
    char* specifier[] = { "%d%s","%f%s", "%lf%s", "%c%s" };

    for (size_t ii = 0; ii < array_size; ++ii) {
        switch (type) {
        case int_enumerate:
        {
            int* var = array + (ii * sizeof(int));
            printf(specifier[type], *var, separator);
        }
        break;
        case float_enumerate:
        {
            float* var = array + (ii * sizeof(float));
            printf(specifier[type], *var, separator);
        }
        break;
        case double_enumerate:
        {
            double* var = array + (ii * sizeof(double));
            printf(specifier[type], *var, separator);
        }
        break;
        case char_enumerate:
        {
            char* var = array + (ii * sizeof(char));
            printf(specifier[type], *var, separator);
        }
        break;
        }
    }
}
\end{lstlisting}
\end{minipage}

Aquí necesito saber el tipo, no sólo su tamaño, por una razón: el especificador
de impresión necesita el tipo exacto. Lo que hago es declarar un \verb!enum!
para poder indexar los tipos en un array de especificadores. Además, en el
\verb!switch! utilizo un truco: cada caso está en un bloque de código diferente
(recuerda que se pueden crear bloques de código sin que estén asociados
a una estructura), así en cada uno la variable \verb!var! puede ser del tipo
que queramos. Esto es un paso hacia delante, pero sigue siendo una función
bastante mala. Es como si hubiéramos pegado todas las funciones para cada tipo
y las hubiéramos metido en la misma. Es un avance, sí, porque, aunque mantenemos
los mismos fragmentos de código duplicado, al menos ahora están todos juntos.

Pero lo ideal es que pudiéramos recibir desde fuera la manera de imprimir, sería
deseable que el usuario de la función nos diera una función que a su vez
contuviera el comportamiento de impresión. Es decir, de algún modo debemos
poder convertir un comportamiento, un algoritmo, una función, al final del día,
en algo que se pueda pasar, mover, trasladar de un sitio a otro. En C hay un
mecanismo concreto para hacer esto que nos otorga un poder enorme:
los punteros a función.

Un puntero a función es un puntero (es decir, una dirección de memoria) que
apunta a las instrucciones que se ejecutarán en esa función. Estos punteros nos
permiten, como formulé antes, transferir, comunicar, a funciones de nuestro
programa comportamientos específicos. Cada tipo de función que se puede
declarar es un tipo de puntero distinto. Una función, como vimos en su momento,
se define por su tipo de retorno y por el tipo de los argumentos que recibe.
Esto quiere decir que, por ejemplo, estas dos funciones son iguales a estos
efectos.

\noindent
\begin{minipage}[H]{\linewidth}
\begin{lstlisting}[style=C]
int sum(int a, int b);
int multiply(int x, int y);
\end{lstlisting}
\end{minipage}

Si cada función es un tipo, quizás estés pensando, debe tener un nombre por
el que referenciarlo y una manera de declararlo y de usarse. Sí, pero no, las
funciones no se pueden inicializar como variables, si quisieras guardar el
puntero de una función, podrías asignarlo a un puntero a \verb!void!.
Sin embargo; se recibe como argumento. Para que una función reciba un puntero
a función como argumento se usa este esquema:

\noindent
\begin{minipage}[H]{\linewidth}
\begin{lstlisting}[style=C]
tipo_de_retorno (nombre) (tipo1, tipo2...)
// por ejemplo
int(foo)(int, int)
\end{lstlisting}
\end{minipage}

Con un ejemplo todo se ve mejor, veamos algo sencillo: cómo hacer una función
que reciba otra función y la ejecute. Por ejemplo, vamos a hacer una función
que reciba otra con esta signatura: \lstinline[style=C]!void (void)! y la ejecute
diez veces.

\noindent
\begin{minipage}[H]{\linewidth}
\begin{lstlisting}[style=C, label={lst:argumentFoo},
caption={Ejemplo primero de puntero a función como argumento}]
void execute_10_times(void (foo)()) {
    for (int ii = 0; ii < 10; ++ii) {
        foo();
    }
}
\end{lstlisting}
\end{minipage}

Como puedes ver, lo único distinto es la declaración de la función, que ya
hemos tratado. La llamada a la función \verb!foo! se hace como cualquier otra.
Nos queda la otra cara de esta moneda, cómo se llama a la función
\verb!execute_10_times!. Esto es bien sencillo, porque el puntero de una función
es, simplemente, su nombre sin los paréntesis, así que la llamada quedaría como:

\noindent
\begin{minipage}[H]{\linewidth}
\begin{lstlisting}[style=C, label={lst:foocall},
caption={Llamada a una función que recibe un puntero a función}]
execute_10_times(print_a);
\end{lstlisting}
\end{minipage}

Hecho esto, volvamos a la función de impresión genérica, pero esta vez haremos
que, a su vez, reciba una función que ejecute la impresión de un único elemento.
Tenemos que elegir la signatura de esta función, como es una función que
imprime, lo normal es que no devuelva nada y que reciba sólo el elemento
que queramos imprimir. Si recibiera el elemento en sí mismo, volveríamos
al problema de que hay que definir su tipo. Lo que haremos es una función
que reciba un puntero a \verb!void! y no devuelva nada. Ojo, esa función será
hecha por quien use nuestra función de impresión de arrays, no por nosotros,
salvo que seamos el mismo individuo, claro. Para el ejemplo, enseñaré ambas
funciones.


\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Definición de función de impresión genérica},
label={lst:printArrayGeneric2}]
#include <stdio.h>
#include <stdlib.h>

void print_int(void* num)
{
    printf("%d", *((int*)num));
}


void print_array_generic(void*       array,
                         size_t      array_size,
                         size_t      type_size,
                         const char* separator,
                         const char* end,
                         void(print_foo)(void*))
{
    for (size_t ii = 0; ii < array_size; ++ii) {
        void* element = array + (ii * type_size);
        print_foo(element);
        if (ii != array_size - 1) {
            printf("%s", separator);
        }
    }
    printf("%s", end);
}

int main(int argc, char** argv)
{
    int array[] = {1,2,3,4,5,6,7,8,9,0};
    print_array_generic(array,
                        ARRAY_SIZE(array),
                        sizeof(*array),
                        " ",
                        "\n",
                        print_int);

}
\end{lstlisting}
\end{minipage}

La función genérica de impresión es sencilla, es simplemente un bucle que
recorre el array y le pasa el puntero correspondiente a la función de impresión
que se le pasa como argumento. Como es lógico, necesito el puntero al array,
la longitud del mismo y, al ser un puntero a \verb!void!, necesito el tamaño
del tipo. Como puedes ver, para darle un poco de vidilla he hecho que la
función reciba dos cadenas: una como separador, que imprimiré después de
todos los elementos (menos el último, de ahí el condicional) y un terminador,
que se imprimirá después del array. La que podríamos denominar función
de impresión específica, es decir: \verb!print_int!, es una función terriblemente
simple, sólo llama a \verb!printf! haciendo un cásting a puntero a entero
y desreferenciándolo.

Es cierto que este modelo de función nos lleva al mismo problema, si
queremos imprimir tipos distintos, tendremos que definir funciones distintas.
Sí, pero piensa una cosa: hemos hecho que el código que se duplique sea ínfimo,
porque son funciones triviales de una línea, además, una vez salimos de los
tipos básicos que podríamos, contando sus variantes, agrupar en 10 funciones,
aproximadamente, se acaba la duplicidad de código. Esto es así porque cualquier
otra estructura requeriría una función o bien de impresión o bien de conversión
a cadena de texto hecha a medida para ella.

Como habrás podido notar, la sintaxis para declarar que una función recibe
otra como argumento es complicada y, además, rompe el patrón de una lista
de argumentos que, hasta ahora, era siempre una sucesión de tipos y nombres
separados por comas. Con esta sintaxis para punteros a función se
incluyen varios paréntesis. C permite definir un tipo para los punteros
a función. Es decir, aún descubrimos otra faceta de la poderosa palabra
\verb!typedef!. Veamos cómo se haría y pondré comentarios de algunos ejemplos
de funciones que pertenecerían a ese tipo.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Definición de tipos puntero a función},
label={lst:functionPointerTypedef}]
typedef void(print_fun_t)(void*); //ej: void print_int(void* a);
typedef void(*malloc_t)(void); //ej: void* malloc(void);
typedef int(sum_t)(int, int); // ej: int sum(int a, int b);
\end{lstlisting}
\end{minipage}
Presta atención porque, si la función devuelve un puntero, el asterisco va
dentro de los paréntesis, junto al nombre del tipo, no fuera. Si hiciéramos en
el programa la primera definición, podríamos cambiar nuestra función genérica
por:

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Ejemplo final de función que recibe un puntero},
label={lst:finalPointerFunction}]
void print_array_generic(void*       array,
                         size_t      array_size,
                         size_t      type_size,
                         const char* separator,
                         const char* end,
                         print_fun_t print_foo);
\end{lstlisting}
\end{minipage}
Queda mucho más claro, porque el último argumento se identifica,
como cualquier otro, por un tipo y un nombre.

La utilidad de esto se puede ver muy bien en funciones que ya hemos tratado,
las funciones de ordenación. Ahora mismo esas funciones siempre ordenan vectores
de enteros y, además, siempre de menor a mayor. Esto presenta varias posibles mejoras,
la primera es evidente, tenemos que poner punteros a \verb!void! y utilizarlos,
pero el otro es más interesante. Esta segunda mejora es: sólo podemos utilizar
una relación de orden. Es decir, sólo podemos ordenar números y de menor a
mayor, no podemos comparar estructuras, no podemos comparar cadenas de texto
alfabéticamente, pero podríamos si utilizáramos estas nuevas herramientas.
Para generalizar una función de ordenación necesitaríamos el tamaño del tipo que
vamos a ordenar y una función de comparación.

Las funciones de comparación son un tipo muy concreto, se llaman
predicados, y son funciones que devuelven un valor lógico ante un conjunto
de argumentos. Así que el prototipo de la función que tenemos que
recibir sería una que devolviera un valor lógico entero y recibiera dos punteros
a \verb!void!. De nuevo, recibe dos punteros a \verb!void! para ser compatible
con nuestra función genérica, aunque el predicado sí debe saber qué
tipo está comparando, lógicamente.

Vamos a usar el algoritmo más sencillo de ordenación que tenemos, el de la
burbuja, para ilustrar esto, esto es así porque una implementación genérica
de, por ejemplo, \textit{Quick Sort} sería más compleja y larga, y me interesa
que veas el concepto del puntero a función y de punteros a \verb!void!
trabajando, no que te pierdas en una función de 40 líneas. Además, para verlo
mejor, vamos a utilizar un caso concreto: una función que ordene cadenas
de texto alfabéticamente, usando \verb!strcmp!.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Definición de \texttt{bubble\_sort} genérico},
label={lst:bubbleSortGeneric}]
typedef int(comparator_t)(const void*, const void*);

void generic_swap(void* one, void* other, size_t type_size)
{
    char aux[type_size];
    memcpy(aux, one, type_size);
    memcpy(one, other, type_size);
    memcpy(other, aux, type_size);

}

void generic_bubble_sort(void*        array,
                         size_t       array_size,
                         size_t       type_size,
                         comparator_t comparator)
{
    for (int ii = 0; ii < array_size - 1; ++ii) {
        for (int jj = 0; jj < array_size - 1; ++jj) {
            void* element = array + (jj * type_size);
            void* next_element = array + ((jj + 1) * type_size);
            if (!comparator(element, next_element)) {
                generic_swap(element, next_element, type_size);
            }
        }
    }
}
\end{lstlisting}
\end{minipage}

Como puedes ver, definimos el tipo de nuestra función de comparación, la cual
devolverá un entero y recibirá dos punteros constantes a \verb!void!, y esto
es importante, la definición de un tipo puntero a función no tiene conversiones
implícitas de ningún tipo. Esto es: como hemos definido la función tal que
recibirá dos punteros constantes a \verb!void!, una función que reciba punteros
no constantes no será de este tipo y no se podrá usar como tal, ten esto en
cuenta.

Después tenemos la función de intercambio en su versión genérica, es decir,
en vez de usar el operador de asignación, utilizaremos la función de copia
de memoria con el tamaño del tipo. Y después, la función genérica de ordenación.
Como puedes ver, simplemente hemos sustituido el condicional por la negación
de la llamada a la función. Recuerda cómo funcionaba el algoritmo de la burbuja:
cuando el elemento i-ésimo es \textbf{mayor} que el siguiente, se intercambian.
Es decir: cuando \textbf{no} se cumple el predicado de que elemento $i$ sea
menor que el siguiente.

Dentro del bucle debemos calcular primero los punteros de los elementos. Esto
es así por legibilidad, pero podríamos escribir las expresiones en la propia
función de intercambio. Ten en cuenta que debemos multiplicar, de nuevo,
\verb!ii! por el tamaño del dato. Recuerda: son punteros a \verb!void!, no
entra en juego la aritmética de punteros, son direcciones de memoria
absolutas. Una vez calculados simplemente llamamos a la función de intercambio.

Debemos tener en cuenta también la función de comparación. En el caso de un
\textit{string} es interesante porque uno puede confundirse debido a que los
punteros se suman sobre punteros. Veamos cómo es la función de comparación:

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Función auxiliar de comparación de \textit{strings}},
label={lst:strcompare}]
int compare_strings(const void* one, const void* two) {
    char* const* str1 = one, * const* str2 = two;
    return strcmp(*str1, *str2) < 0;
}
\end{lstlisting}
\end{minipage}

Es muy interesante porque puedes ver la primera línea, que introduce algo
que no habíamos visto. Esta función recibe dos punteros constantes de
\verb!void!. Estos punteros son, en realidad, punteros a punteros a \verb!char!,
es decir: \verb!char**!. Pero como los hemos recibido como constantes, no
podemos hacerles cásting a ese tipo, el compilador nos diría, hablando claro:
<<estás haciendo cásting de un puntero constante a uno que no lo es, podrías
modificar el contenido>>. Pero si pusiéramos el modificador \verb!const!
primero de todo como hemos hecho siempre el compilador seguiría lanzándonos
esa advertencia. La clave es que lo que es constante es lo que, por ejemplo,
\verb!one! apunte, es decir, la constancia está pegada al contenido de
\verb!one! y \verb!two!. Si escribiéramos \verb!const char**! seguiríamos
pudiendo modificar el contenido al que apunta tal dirección. Vamos a verlo
con un dibujo:

\begin{figure}[H]
    \includegraphics[width=\linewidth]{const_char_pointer_pointer}
    \caption{Puntero a carácter constante}
    \label{img:constcharpointerpointer}
\end{figure}

\begin{figure}[H]
    \includegraphics[width=\linewidth]{char_pointer_const_pointer}
    \caption{Puntero a puntero constante a \texttt{char}}
    \label{img:charconstpointerpointer}
\end{figure}

Vamos a explicarlo despacio, si miras el primer dibujo, es <<a lo que estamos
acostumbrados>>, cada asterisco es un nuevo nivel de puntero, así que puedes
leer la declaración desde la izquierda y construirá los tipos. Empecemos:
nos encontramos \verb!const!, lo que venga ahora es constante, después
\verb!char!, ahora llega un asterisco, el asterisco inicia un nuevo nivel, así
que este puntero \textbf{no} será constante, porque no tiene un \verb!const!
a la derecha y, finalmente, otro nivel de puntero, que tampoco será constante.
Ahora que ya tienes los tres grupos, los inviertes, es decir: puntero no
constante, a puntero no contante, a \verb!char! constante.

En el caso siguiente tenemos un \verb!char!, después un asterisco, es decir,
un nivel de puntero, lleva const a la derecha, así que es constante, y después
otro puntero, sin constancia. Es decir, invirtiéndolo: puntero no constante a
puntero constante a char no constante. En ambos casos, en el diagrama, he
señalado en rojo los valores que no puedes cambiar, como puedes ver, en el
superior no podemos cambiar los \textit{strings}, pero sí los punteros
intermedios. En el caso de abajo, por el contrario, podemos modificar los
caracteres, pero no los punteros del array intermedio.

Una de las implicaciones de las funciones genéricas es la siguiente: se
introduce una sobrecarga inevitable, por dos motivos. El primero es que las
funciones que utilizan punteros a \verb!void! tienen que hacer cálculos
explícitos que se harían implícitamente. No voy a entrar en detalles de
arquitectura de computadores, pero los ordenadores tienen en sus procesadores
instrucciones que manejan datos como enteros de cuatro bytes y números decimales
(y algunos más). Al tener que copiar byte a byte, impedimos que se utilicen y,
además, tenemos que darle más vueltas al bucle de copia, lo cual es más costoso.
El segundo es que cuando se llama a una función de manera normal el
compilador cuenta con ello para saber cómo generar el binario. Cuando ésta
es un argumento, esta tarea se le hace más complicada, porque no sabe qué
función es hasta el momento de la ejecución. Para hacer esto patente, vamos
a hacer una comparación con el tiempo que tarden ambas versiones en ordenar
65.536 y 131.072 elementos. Vamos a comparar ambas cargas de trabajo porque
quiero que veas una cosa.

\begin{table}[H]
\begin{tabularx}{\linewidth}{|c|R|R|}
\hline
\textbf{Función}&\textbf{N=35.536}&\textbf{N=131.072}\\\hline
Específica&16,21&64,61\\\hline
Genérica&41,20&164,44\\\hline
\textbf{Ratio}&0,39&0,39\\\hline
\end{tabularx}
\caption{Tiempos de ejecución de los distintos algoritmos}
\label{tab:sortingTimes}
\end{table}

Como puedes ver, la versión genérica tarda más, pero he calculado un dato
importante a ese respecto: el ratio entre el tiempo del algoritmo específico y
el algoritmo genérico. Como puedes ver, aunque el algoritmo genérico es peor
que el específico, la buena noticia es que esa diferencia es constante, es
decir: no empeora con el tamaño del vector. Esto hace que, si podemos asumir
el aumento de tiempo, la solución sea escalable, que es una manera que se tiene
en informática de decir que puedes hacer crecer algo sin quedarte sin recursos
rápidamente.

Un ejercicio muy interesante sería que programaras la versión genérica de
\textit{Quick Sort} y que, además, hicieras estas mismas mediciones. Para
medir el tiempo puedes utilizar este código:

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Cómo medir el tiempo},
label={lst:measure_times}]
#include <stdio.h>
#include <time.h>

double timespec_to_double(const struct timespec* tm)
{
    return tm->tv_sec + tm->tv_nsec / 1000000000.0;
}

int main(int argc, char** argv)
{
    double start, stop;
    struct timespec start_ts, stop_ts;

    clock_gettime(CLOCK_REALTIME, &start_ts);
    start = timespec_to_double(&start_ts);
    // Aquí el código que quieres medir.
    clock_gettime(CLOCK_REALTIME, &stop_ts);
    stop = timespec_to_double(&stop_ts);
    printf("Hemos tardado: %lf\n", stop - start);
}
\end{lstlisting}
\end{minipage}

La función \verb!clock_gettime! es una función para medir el tiempo de un modo
peculiar, en sistemas Linux se mide el tiempo desde el primero de enero de
1970. Así, la estructura \verb!timespec! indica el tiempo pasado desde entonces
como un conjunto de segundos más los correspondientes nanosegundos en sus dos
miembros. Como eso es poco práctico he creado una pequeña función para
convertirlo a número decimal y así poder restarlo cómodamente. Después,
simplemente mido el tiempo antes y después del código que quiero saber cuánto
tarda y los resto, como puedes ver.

\section{Ejemplo completo de programa}
Esta sección está al final porque, si hasta ahora hemos visto cada parte del
lenguaje en detalle y por sí misma, en esta vamos a intentar montar todas las
piezas en una gran fotografía. Para esto vamos a utilizar y refinar un ejemplo
que ha sido recurrente en el manual: la gestión de una estructura que almacena
los datos de una persona, pero vamos a conseguir separar bien al usuario de la
funcionalidad interna del código que se encague de eso.

Lo que haremos es crear un archivo de código fuente llamado \verb!person.c! y
su correspondiente archivo de cabeceras, \verb!person.h!, en este archivo
incluiremos funcionalidad para crear una estructura persona, cambiar
sus atributos, leerlos y serializarla. Además, vamos a ver un interesante
artefacto del lenguaje para poder impedir que el usuario se entrometa en
nuestra estructura y pueda alterar los datos de manera incorrecta. Por ejemplo:
asignando los punteros a una zona de memoria que no controlemos desde estas
funciones proporcionadas para manipular la estructura de datos.

Lo primero que voy a hacer es crear el archivo de cabeceras porque ya hemos
definido de una manera muy concreta la funcionalidad de este código fuente.
Aquí hay una cosa interesante que podremos comentar, veamos el archivo:

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Ejemplo final de programa -- \texttt{person.h}},
label={lst:finalExPerson_h}]
#ifndef PERSON_H
#define PERSON_H

typedef struct person_s person_t;

person_t *create_person(const char *name, const char *last_name,
                        unsigned int age);

void destroy_person(person_t *p);

void person_set_name(person_t *p, const char *name);

void person_set_last_name(person_t *p, const char *last_name);

void person_set_age(person_t *p, unsigned int age);

const char *person_get_name(const person_t *person);

const char *person_get_last_name(const person_t *person);

unsigned int person_get_age(const person_t *person);

char *person_to_string(const person_t *p);

#endif
\end{lstlisting}
\end{minipage}

Y aquí puedes ver una de las cosas interesantes de este ejemplo final: estamos
declarando el tipo \verb!person_t!, pero no el \textit{struct} al que da nombre,
esto quiere decir que cualquier archivo de código fuente que incluya este
\textbf{no} podrá saber la definición de tal \textit{struct}. La implicación de
esto es que no podrá declarar variables de este tipo, tan solo punteros, puede
declarar un puntero, porque todos los punteros tienen el mismo tamaño. Si
intentáramos declarar una variable de este tipo, el compilador lanzaría un error
como el siguiente:

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=terminalStyle]
main.c: In function 'main':
main.c:5:14: error: storage size of 'francis' isn't known
    5 |     person_t francis;
      |              ^~~~~~~
\end{lstlisting}
\end{minipage}

Este es el mecanismo que nos permite impedir que el usuario altere el contenido
de la estructura fuera de nuestro control (como comentamos en el programa
\ref{lst:structConstMain}) porque, del mismo modo que no conoce el tamaño del tipo,
tampoco conoce los miembros de esta estructura, así que no puede accederse a
ellos. Nota, además, como no hemos incluido ninguna cabecera en \verb!person.h!.
Si necesitáramos cabeceras, por ejemplo, la cabecera \verb!stdint.h! contiene
definiciones de tipo útiles como aquéllos de tamaño fijo: \verb!int8_t!,
\verb!int16_t!, etc.; si quisiéramos definir alguna función con un argumento
de este tipo o de tipo de retorno, sí sería necesario que incluyéramos esta
cabecera. Si las necesitamos en las implementaciones (en las declaraciones de
esctructuras, en las definiciones de funciones...), será en el archivo de
código fuente (en el \verb!.c!) donde las incluiremos.

El siguiente archivo es, precisamente, este archivo de código fuente:
\verb|person.c|. Es bastante largo, así que vamos a incluirlo en tres secciones:
la sección de declaración de tipos (que sólo contendrá uno), las funciones de
manipulación del contenido de la estructura y, finalmente, la de recuperación
de la información.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C, label={lst:finalExDefinition},
caption={Ejemplo final de programa -- \texttt{person.c} definiciones}]
#include <string.h> //strdup, memset
#include <stdlib.h> //malloc
#include <stdio.h>  //snprintf
#include "person.h"

struct person_s
{
    char *name;
    char *last_name;
    unsigned int age;
};

person_t *create_person(const char *name,
                        const char *last_name,
                        unsigned int age)
{
    person_t *res = malloc(sizeof(*res));
    memset(res, 0, sizeof(*res));

    res->age = age;
    res->name = strdup(name);
    res->last_name = strdup(last_name);

    return res;
}

void destroy_person(person_t *p)
{
    free(p->name);
    free(p->last_name);
    free(p);
}
\end{lstlisting}
\end{minipage}

Aquí podemos ver la defininión del tipo del que en la cabecera hicimos un
\verb!typedef!, este estilo de declaración de un tipo se llama declaración
anticipada o, en inglés, \textit{forwarding declaration}. Aquí, aparte de la
definición del tipo propiamente dicho, tenemos las funciones que lo crean
y que lo destruyen. Como esta estructura contiene elementos reservados con
memoria dinámica, debemos proveer al usuario una manera de liberar los recursos
de la estructura. Como puedes ver, en las funciones de creación reservamos
espacio \textbf{para la propia estructura} y para sus campos.

Debemos reservar
nosotros dinámicamente la estructura aparte de sus campos porque, recordemos,
fuera de este archivo de código fuente no podremos declarar más que punteros,
y ese puntero no tendrá espacio para nada si no lo declaramos. Después,
reservamos memoria para el contenido al que apuntarán los \textbf{miembros}
de la estructura.
En la función de destrucción, simétricamente, liberamos primero los contenidos
y después la propia estructura. Nota, además, cómo hemos declarado todos los
argumentos que hemos podido como constantes, para que el usuario no tenga dudas
de si vamos a modificar datos que nos proporcione.

Las siguientes funciones son las que nos permiten sobreescribir los datos:

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C, label={lst:finalExSetter},
caption={Ejemplo final de programa -- \texttt{person.c} manipulación}]
void person_set_name(person_t *p, const char *name)
{
    free(p->name);
    p->name = strdup(name);
}

void person_set_last_name(person_t *p, const char *last_name)
{
    free(p->last_name);
    p->last_name = strdup(last_name);
}

void person_set_age(person_t *p, unsigned int age)
{
    p->age = age;
}
\end{lstlisting}
\end{minipage}

Como puedes ver, las funciones son simples, liberamos la memoria de los campos
y después le asignamos la duplicación del argumento que se nos pasa. De nuevo,
observa cómo hemos definido como constantes los argumentos del mismo modo que
hicimos en la función de creación. Las funciones no devuelven nada (\verb!void!)
porque no tendríai sentido. Aunque siempre podrían devolver un entero que
actuara como código de error, por ejemplo si la reserva de memoria fallara,
se podría indicar devolviendo un número menor que cero.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C, label={lst:finalExGetter},
caption={Ejemplo final de programa -- \texttt{person.c} recuperación}]
const char *person_get_name(const person_t *p)
{
    return p->name;
}

const char *person_get_last_name(const person_t *person)
{
    return person->last_name;
}

unsigned int person_get_age(const person_t *person)
{
    return person->age;
}

char *person_to_string(const person_t *p)
{
#define MAX_STRING_SIZE ((unsigned int)1024)

    char res[MAX_STRING_SIZE + 1];
    snprintf(res, MAX_STRING_SIZE, "{\"name\":\"%s\","
                                   "\"last_name\":\"%s\","
                                   "\"age\":%u}",
             p->name, p->last_name, p->age);
    return strdup(res);
#undef MAX_STRING_SIZE
}
\end{lstlisting}
\end{minipage}

Aquí debes notar que devolvemos punteros contantes a \verb!char!, precisamente
para impedir que el usuario libere, manipule o cambie el contenido de los campos
del \textit{struct}. Sin embargo; en la función de serialización (que he
reducido a su versión más simple) devuelvo un puntero no constante porque la
responsabilidad de liberar es del usuario de la funcionalidad, no de esta
biblioteca. Además, en esta última función puedes ver que podemos
\textbf{eliminar} una macro con la directiva \verb!#undef!. Esto es útil cuando
necesitas inicializar un array, como aquí, pero no quieres contaminar de
símbolos el código fuente. Así, si otra función usara strings de otro tamaño,
podríamos usar el mismo nombre, como si la macro fuera una variable distinta.
De nuevo: ten cuidado, las macros trabajan a nivel de preprocesado, por lo que
no estás definiendo ninguna variable en la función, sólo una región de código
donde un símbolo se sustituirá por otro.

Finalmente, en el archivo principal podemos utilizar la funcionalidad:

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C, label={lst:finalExMain},
caption={Ejemplo final de programa -- \texttt{main.c}}]
#include "person.h"
#include <stdlib.h>
#include <stdio.h>

int main(void)
{
    person_t* person = create_person("John", "Smith", 18);

    char* serialization = person_to_string(person);

    printf("%s\n", serialization);
    free(serialization);

    person_set_name(person, "Michael");
    person_set_last_name(person, "Johnson");
    person_set_age(person, 33);

    serialization = person_to_string(person);
    printf("%s\n", serialization);
    free(serialization);
}
\end{lstlisting}
\end{minipage}

Aquí se puede ver cómo se utilizan estructuras con este patrón de diseño.
Primero la reservas, después la usas, la puedes manipular y, finalmente, la
liberas, todo ello con las funciones proporcionadas junto con el tipo de dato.
Con este patrón, el usuario de la funcionalidad que hemos programado tiene
menos capacidad para <<hacer algo mal>>.

Ahora, vamos a ver rápidamente cómo se podría compilar, para recordarlo. Primero
lo haremos utilizando el código objeto y, después, crearemos una biblioteca
dinámica y la enlazaremos. Para compilar utilizando el código
objeto seguiremos estos pasos:

\noindent
\begin{minipage}[H]{\linewidth}
\begin{enumerate}
\item Crear el código objeto de \verb!person.c!

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=terminalStyle]
\$ gcc -c person.c
\end{lstlisting}
\end{minipage}
\item Crear el código objeto de \verb!main.c!

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=terminalStyle]
\$ gcc -c main.c
\end{lstlisting}
\end{minipage}
\item Crear el ejecutable con ambos códigos objeto

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=terminalStyle]
\$ gcc -o main.exe main.o person.o -g -Wall -Wextra
\end{lstlisting}
\end{minipage}
\end{enumerate}
\end{minipage}

Para la biblioteca, seguiremos estos pasos:

\noindent
\begin{minipage}[H]{\linewidth}
\begin{enumerate}
\item Crear el código objeto de \verb!person.c!

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=terminalStyle]
\$ gcc -c person.c
\end{lstlisting}
\end{minipage}
\item Crear una biblioteca con este código objeto:

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=terminalStyle]
\$ gcc -shared -o libperson.so person.o
\end{lstlisting}
\end{minipage}
\item Crear el código objeto de \verb!main.c!

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=terminalStyle]
\$ gcc -c main.c
\end{lstlisting}
\end{minipage}
\item Crear el ejecutable usando la biblioteca:

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=terminalStyle]
\$ gcc -L. -Wl,-rpath=. -o main.exe main.o -lperson
\end{lstlisting}
\end{minipage}
\end{enumerate}
\end{minipage}

En este ejemplo final se han visto ejemplos de la mayoría de conceptos que
se han explicado en el manual: variables, punteros, memoria, reserva dinámica,
estructuras, macros, enlazado, compilación y constancia y signo. Es mucha
información en pocas páginas, pero permite tener una foto global de todo
si ya se ha leído antes con detenimiento.

%\subsection{Ejercicio de la sección}
%En esta sección voy a proponer un último ejercicio, pero detallado, que permita
%practicar todos o casi todos los conceptos vistos en el manual. El ejercicio es
%crear un proyecto que incluye las siguientes funcionalidades:
%\begin{itemize}
%\item Manejo de una estructura <<coordenada>> que permita almacenar
%una coordenada bidimensional (un punto) con un \textbf{nombre} que sea una
%cadena de texto. Esta cadena de texto debe manejarse con funciones que impidan
%que el usuario deje la estructura en un estado inconsistente.
%    \begin{itemize}
%    \item Debe poderse calcular la distancia entre dos puntos. Se recibirán
%    punteros y si uno de ellos o los dos es \verb!NULL! se tomará por el punto
%    de origen.
%    \item Debe poderse ordenar un vector de puntos por su distancia al origen.
%    Idealmente, debería usarse el algoritmo \textit{Quick Sort}.
%    \item Debe poderse cambiar el nombre de un punto si destruirlo y crearlo
%    de nuevo con una función para tal fin.
%    \end{itemize}
%\item Manejo de una estructura <<polígono>> que tenga un conjunto de puntos
%de los descritos anteriormente. Hay que tener en cuenta que cada punto estará
%conectado con el siguiente y el anterior; menos el último, que estará conectado
%al penúltimo y al primero, y el primero, que estará conectado al segundo y
%al último.
%    \begin{itemize}
%    \item Deberá poderse modificar un polígono añadiendo o eliminando puntos
%    al final.
%    \item Deberá poderse insertar un punto en una posición dada de un polígono.
%    \item Deberá poderse calcular el centro del polígono como la media de las
%    coordenadas de un punto.
%    \end{itemize}
%\item Se deben crear funciones que permitan hacer estas tareas con estructuras
%que simbolicen y aumenten las funcionalidades de los vectores,
%idealmente, de cualquier tipo:
%    \begin{itemize}
%    \item Insertar en cualquier posición
%    \item Insertar al final
%    \item Conocer la longitud del vector
%    \item Vaciar el vector
%    \item Eliminar un elemento de la posición del vector
%    \item Ordenar el vector
%    \item Crear un vector con una longitud dada, relleno de un valor concreto
%    \end{itemize}
%Las dos primeras funcionalidades deben estar en una biblioteca llamada
%\verb!libGeo.so! y la siguiente en \verb!libVector.so!. Se debe crear un
%programa que utilice todas las funcionalidades y las pruebe.
%\end{itemize}

\section{Anexo A: soluciones a ejercicios}
\begin{exercises}
\item Escribe un programa y declara en él una estructura que defina un círculo
en dos dimensiones (su centro y su radio). Y haz que el programa declare una
variable de ese tipo y calcule su área.


\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Solución al ejercicio 1},
label={lst:solution1}]
#include <stdio.h>

struct circle_s {
    double x;
    double y;
    double r;
};

int main(void)
{
    struct circle_s circle = { 1 , 1 , 3.4 };
    double area = 3.141592 * circle.r * circle.r;
    printf("El área del círculo en el punto [%f, %f] con un radio de % f es: %f\n", circle.x, circle.y, circle.r, area);
}
\end{lstlisting}
\end{minipage}

\item Haz un programa que, basándose en el struct punto presentado en el
ejemplo, declare e inicialice un array de ellos y vaya diciendo las direcciones
que hay que seguir para ir de uno a otro.


\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Solución al ejercicio 2},
label={lst:solution2}]
#include <stdio.h>
struct point_s {
    double x;
    double y;
};

int main(void)
{
    struct point_s points[10] = { {-1.056171, 3.401877},
                                  {2.984400, 2.830992},
                                  {-3.024486, 4.116474},
                                  {2.682296, -1.647772},
                                  {0.539700, -2.222253},
                                  {1.288709, -0.226029},
                                  {0.134009, -1.352155},
                                  {4.161951, 4.522297},
                                  {2.172969, 1.357117},
                                  {1.069689, -3.583974} };

    for(int ii = 1; ii < 10; ++ii){
        if (points[ii - 1].x < points[ii].x) {
            printf("Derecha");
        }else if(points[ii - 1].x == points[ii].x){
            printf("Quieto");
        }else if(points[ii - 1].x > points[ii].x){
            printf("Izquierda");
        }
        printf(", ");
        if (points[ii - 1].y < points[ii].y) {
            printf("Arriba");
        }else if(points[ii - 1].y == points[ii].y){
            printf("Quieto");
        }else if(points[ii - 1].y > points[ii].y){
            printf("Abajo");
        }
        printf("\n");
    }
}
\end{lstlisting}
\end{minipage}

\item Haz un programa que declare un array bidimensional y calcule la suma de
sus filas y sus columnas.


\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Solución al ejercicio 3},
label={lst:solution3}]
#include <stdio.h>

int main(void)
{
    int array[3][3] = { {1,3,6},{7,3,6},{1,2,4} };

    for (int ii = 0; ii < 3; ++ii) {
        for (int jj = 0; jj < 3; ++jj) {
            printf("%d ", array[ii][jj]);
        }
        int suma = 0;
        for(int jj = 0; jj < 3; ++jj){
            suma += array[ii][jj];
        }
        printf("= %d\n", suma);
    }
    for(int ii = 0; ii < 3*2; ++ii){
        printf("-");
    }
    printf("\n");
    for(int ii = 0; ii < 3; ++ii){
        int suma = 0;
        for(int jj = 0; jj < 3; ++jj){
            suma+=array[jj][ii];
        }
        printf("%d ", suma);
    }
    printf("\n");
}

\end{lstlisting}
\end{minipage}


\item Haz un programa que haga lo siguiente para los números del 1 al 100 ambos
incluidos: si el número es divisible entre 2, debe imprimirse por pantalla
<<fizz>>, si es divisible entre 5, <<buzz>>, y si es divisible entre los dos,
<<fizzbuzz>>, no imprimir nada en otro caso.


\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Solución al ejercicio 4},
label={lst:solution4}]
#include <stdio.h>

int main(void)
{
    for (int ii = 1; ii <= 100; ++ii){
        int end_of_line = 0;
        if (ii % 2 == 0){
            printf("fizz");
            end_of_line = 1;
        }

        if(ii % 5 == 0){
            printf("buzz");
            end_of_line = 1;
        }
        if(end_of_line){
            printf("\n");
        }
    }
}
\end{lstlisting}
\end{minipage}

\item Escribe una función que calcule si un número es primo o no.


\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Solución al ejercicio 5},
label={lst:solution5}]
#include <stdio.h>

int is_prime(int number) {
    int prime = 1;
    for (int ii = 2; ii < number / 2 && prime; ++ii) {
        if (0 == number % ii) {
            prime = 0;
        }
    }
    return prime;
}

int main(void)
{
    for(int ii = 2; ii < 100; ii++){
        printf("El número %d ", ii);
        if(is_prime(ii)){
            printf("es primo.");
        }else{
            printf("no es primo");
        }
        printf("\n");
    }
}
\end{lstlisting}
\end{minipage}

\item Escribe una función que calcule la distancia entre dos estructuras punto
de las usadas en la sección anterior.


\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Solución al ejercicio 6},
label={lst:solution6}]
#include <stdio.h>
#include <math.h>
struct point_s {
    double x;
    double y;
};

double distance(struct point_s a, struct point_s b) {
    double res = 0.0;
    double diff_x = a.x - b.x;
    double diff_y = a.y - b.y;
    res = sqrt(diff_x * diff_x + diff_y * diff_y);
    return res;
}

int main(void)
{
    struct point_s a = {1.2, 4.3};
    struct point_s b = {3.4, 5.5};
    printf("La distancia entre [%f, %f] y [%f, %f] es: %f\n", a.x, a.y, b.x, b.y, distance(a,b));
}
\end{lstlisting}
\end{minipage}

\item Escribe una función que reciba un array de enteros y un caracter separador
que imprima los elementos del array separados por ese caracter.


\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Solución al ejercicio 7},
label={lst:solution7}]
#include <stdio.h>
void print_separated(int array[], int array_size, char separator){
    for(int ii = 0; ii < array_size; ++ii){
        printf("%d%c", array[ii], separator);
    }
}

int main(void)
{
    int my_array[] = {1,2,3,4,5,6,7,8,9,0};
    print_separated(my_array, 10, '|');
    printf("\n");
}
\end{lstlisting}
\end{minipage}

\item Escribe una función que encapsule el programa
\ref{lst:linealSystemFinal}: \nameref{lst:linealSystemFinal}.
La función debe recibir los coeficientes de las ecuaciones
($a$, $b$, $c$, $d$, $e$ y $f$). Puede recibirlos por separado o en un array.
Para devolver el resultado puedes crear una estructura que simplemente tenga
dos \verb!double!.



\begin{lstlisting}[style=C,
caption={Solución al ejercicio 8},
label={lst:solution8}]
#include <stdio.h>

struct solution_s {
    double x;
    double y;
    int solved;
};

struct solution_s linear_system(int a, int b, int c, int d, int e, int f) {

    double divisor;
    struct solution_s res;
    res.solved = 1;
    if (a != 0 && d != 0) {
        divisor = (a * e - d * b);
        if (divisor == 0)
        {
            printf("El sistema es irresoluble .\n");
            res.solved = 0;
        }
        else
        {
            res.y = (a * f - d * c) / divisor;
            res.x = (f - e * res.y) / (d);
        }
    }
    else if (b != 0 && e != 0) {
        divisor = (b * d - e * a);
        if (divisor == 0) {
            printf("El sistema es irresoluble .\n");
            res.solved = 0;
        }
        else {
            res.x = (b * f - e * c) / divisor;
            res.y = (c - a * res.x) / b;
        }
    }
    else if ((a == 0 && b == 0) || (d == 0 && e == 0)) {
        printf(" Esto no es un sistema \n");
        res.solved = 0;
    }
    else {
        if (a != 0) {
            res.x = (double)c / a;
            res.y = (double)f / e;
        }
        else {
            res.x = (double)f / d;
            res.y = (double)c / b;
        }
    }
    return res;
}


int main(void)
{
    struct solution_s sol = linear_system(1, 1, 1, 2, 2, 2);
    printf(" %dx+ %dy= %d\n", 1, 2, 3);
    printf(" %dx+ %dy= %d\n", 4, 5, 6);
    if (sol.solved) {
        printf("x = %f; y = %f\n", sol.x, sol.y);
    }
    else {
        printf("El sistema no tiene solucion.\n");
    }
}
\end{lstlisting}


\item Escribe una función que normalice los elementos de un array de
\verb!double!.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Solución al ejercicio 9},
label={lst:solution9}]
#include <stdio.h>

void normalize(double array[], int array_size) {
    double biggest = array[0];
    for (int ii = 1; ii < array_size; ++ii) {
        if (array[ii] > biggest) {
            biggest = array[ii];
        }
    }
    for (int ii = 0; ii < array_size; ++ii) {
        array[ii] /= biggest;
    }
}

int main(void)
{
    double array[] = { 1,2,3,4,5,6,7,8,9,10 };
    normalize(array, 10);
    for(int ii = 0; ii < 10; ++ii){
        printf("%f\n", array[ii]);
    }
    printf("\n");
}
\end{lstlisting}
\end{minipage}

\item Completa esta tabla de números en diferentes bases numéricas:
\begin{table}[H]
\begin{tabularx}{\linewidth}{|R|R|R|}
\hline
\multicolumn{1}{|Y|}{\textbf{Decimal}}& \multicolumn{1}{Y|}{\textbf{Binario}} & \multicolumn{1}{Y|}{\textbf{Hexadecimal}} \\\hline
73& 0100~1001 & 0x049 \\\hline
 38&0010~0110&0x026 \\\hline
303&0001~0010~1111&0x12F       \\\hline
128&1000~0000&0x080 \\\hline
\end{tabularx}
\end{table}
\item Vuelve al ejercicio noveno y reproduce los contenidos de la pila en cada
bloque de código del programa. Utiliza de referencia la solución que propongo
yo.

\begin{stack}
    \item Función main
    \begin{stack}
        \item Array (10 elementos)
        \item Entramos en la función normalize
        \begin{stack}
            \item Array (puntero a)
            \item \verb!array_size!
            \item \verb!biggest!
            \item Primer bucle for
            \begin{stack}
                \item \verb!ii!
            \end{stack}
            \item Segundo bucle for
            \begin{stack}
                \item \verb!ii!
            \end{stack}
        \end{stack}
        \item Bucle for
        \begin{stack}
            \item \verb!ii!
        \end{stack}
    \end{stack}
\end{stack}

\item Haz un programa que cree un puntero de tres niveles de tipo \verb!int!,
lo reserve correctamente, lo rellene con el valores correlativos
\textbf{empezando en uno} y después lo imprima de una manera comprensible.
Finalmente, libéralo también de tal modo que no quede memoria sin liberar al
final del programa.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,label=lst:solution12, caption={Solución al ejercicio 12}]
#include <stdio.h>
#include <stdlib.h>

#define DEPTH (10)
#define WIDTH (5)
#define HEIGHT (12)

int main(int argc, char const *argv[]) {
    int ***cube = malloc(sizeof(*cube) * DEPTH);

    for (int ii = 0; ii < DEPTH; ++ii) {
        cube[ii] = malloc(sizeof(**cube) * HEIGHT);
        for (int jj = 0; jj < HEIGHT; ++jj) {
            cube[ii][jj] = malloc(sizeof(***cube) * WIDTH);
            for (int kk = 0; kk < WIDTH; ++kk) {
                cube[ii][jj][kk] =
                    kk + jj * WIDTH + ii * HEIGHT * WIDTH + 1;
            }
        }
    }

    for (int ii = 0; ii < DEPTH; ++ii) {
        for (int jj = 0; jj < HEIGHT; ++jj) {
            for (int kk = 0; kk < WIDTH; ++kk) {
                printf("%3d ", cube[ii][jj][kk]);
            }
            printf("\n");
        }
        printf("\n");
    }

    for (int ii = 0; ii < DEPTH; ++ii) {
        for (int jj = 0; jj < HEIGHT; ++jj) {
            free(cube[ii][jj]);
        }
        free(cube[ii]);
    }
    free(cube);

    return 0;
}
\end{lstlisting}
\end{minipage}


\item Basándote en el programa anterior, crea dos funciones, una para crear
una matriz tridimensional con memoria dinámica dadas sus tres dimensiones y
otra para liberarla.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[ style=C,
                    label=lst:solution12,
                    caption={Solución al ejercicio 13 -- reserva}]
int ***malloc_cube(size_t depth, size_t height, size_t width) {
    int ***cube = malloc(sizeof(*cube) * depth);

    for (int ii = 0; ii < depth; ++ii) {
        cube[ii] = malloc(sizeof(**cube) * height);
        for (int jj = 0; jj < height; ++jj) {
            cube[ii][jj] = malloc(sizeof(***cube) * width);
            for (int kk = 0; kk < width; ++kk) {
                cube[ii][jj][kk] =
                    kk + jj * width + ii * height * width + 1;
            }
        }
    }
    return cube;
}
\end{lstlisting}
\end{minipage}

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[ style=C,
                    label=lst:solution12,
                    caption={Solución al ejercicio 13 -- impresión}]
void print_cube(int ***cube, size_t depth, size_t height,
                size_t width) {
    for (int ii = 0; ii < depth; ++ii) {
        for (int jj = 0; jj < height; ++jj) {
            for (int kk = 0; kk < width; ++kk) {
                printf("%3d ", cube[ii][jj][kk]);
            }
            printf("\n");
        }
        printf("\n");
    }
}
\end{lstlisting}
\end{minipage}

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[ style=C,
                    label=lst:solution12,
                    caption={Solución al ejercicio 13 -- liberación}]
void free_cube(int ***cube, size_t depth, size_t height,
               size_t width) {
    for (int ii = 0; ii < depth; ++ii) {
        for (int jj = 0; jj < height; ++jj) {
            free(cube[ii][jj]);
        }
        free(cube[ii]);
    }
    free(cube);
}
\end{lstlisting}
\end{minipage}

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[ style=C,
                    label=lst:solution12,
                    caption={Solución al ejercicio 13 -- función \texttt{main}}]
int main(int argc, char const *argv[]) {
    int ***cube = malloc_cube(DEPTH, HEIGHT, WIDTH);
    print_cube(cube, DEPTH, HEIGHT, WIDTH);
    free_cube(cube, DEPTH, HEIGHT, WIDTH);
}
\end{lstlisting}
\end{minipage}

\item Escribe un programa que reciba un número variable de números como
argumentos e imprima la descomposición en factores primos de todo ellos.
Se recomienda hacer control de errores comprobando que los argumentos son
números antes de utilizarlos, etc.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[ style=C,
                    label=lst:solution12,
                    caption={Solución al ejercicio 13 -- función \texttt{main}}]
int main(int argc, char const *argv[]) {
    int ***cube = malloc_cube(DEPTH, HEIGHT, WIDTH);
    print_cube(cube, DEPTH, HEIGHT, WIDTH);
    free_cube(cube, DEPTH, HEIGHT, WIDTH);
}
\end{lstlisting}
\end{minipage}

\item Escribe un programa que lea \textbf{por consola} una serie de palabras
y que sólo deje de leer cuando se introduzca <<!!>> como palabra. Después, debe
imprimir dichas palabras en orden aleatorio. La función \verb!rand! devuelve
un número aleatorio entre cero y el máximo entero positivo. Si quieres que
devuelva números aleatorios \textbf{distintos} cada vez debes ejecutar
\verb!srand(time(NULL));! al inicio de la función \verb!main!. Debes incluir la
cabecera \verb!time.h!.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[ style=C,
                    label=lst:solution12,
                    caption={Solución al ejercicio 15}]
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#define STRING_SIZE (1024)
#define MAX_WORDS (1024)

int main(int argc, char const *argv[]) {
    char *word_set[1024];
    int word_length = 0;
    do {
        word_set[word_length] = malloc(STRING_SIZE);
        scanf("%s", word_set[word_length]);
        word_length++;
    } while (strcmp(word_set[word_length - 1], "!!"));

    srand(time(NULL));
    for (int ii = 0; ii < word_length - 1; ++ii) {
        char *aux            = word_set[ii];
        int rand_index       = rand() % (word_length - 1);
        word_set[ii]         = word_set[rand_index];
        word_set[rand_index] = aux;
    }
    for (int ii = 0; ii < word_length - 1; ++ii) {
        printf("%s\n", word_set[ii]);
        free(word_set[ii]);
    }
    free(word_set[word_length-1]);
}
\end{lstlisting}
\end{minipage}

Como nota, para <<barajar>> el vector de palabras lo que hago el recorrerlo
intercambiando cada palabra con una posición aleatoria. Hay otros métodos
que quizás hayas usado como generar una posición aleatoria del vector y copiarlo
a otro, el problema de esto es que si lo que haces es generar un índice nuevo
cuando encuentras que ya has copiado ese, el número de veces que ejecutas
el aleatorio es, lógicamente, impredecible. Tal y como lo he escrito yo el
algoritmo siempre tardará lo mismo generando resultados moderadamente
aleatorios.

\item Haz una función que lea dos archivos e \textbf{intercambie} su contenido,
escribe dicho programa de tal modo que no sea necesario alojar ninguno de los
dos archivos en memoria completamente.

\newpage
\begin{lstlisting}[ style=C,
                    label=lst:solution16,
                    caption={Solución al ejercicio 16}]
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char const *argv[]) {
    FILE *file_1 = NULL, *file_2 = NULL, *file_aux = NULL;
    const int BLOCK_SIZE = 1024;
    int read             = 0;
    char buffer[BLOCK_SIZE], aux_file_path[] = "/tmp/auxFile.txt";
    if (argc < 3) {
        printf("Uso: main.exe <archivo1> <archivo2>\n");
        return EXIT_FAILURE;
    }

    file_1 = fopen(argv[1], "r+");
    if (NULL == file_1) {
        printf("ERROR: El primer archivo no existe.\n");
        return EXIT_FAILURE;
    }

    file_2 = fopen(argv[2], "r+");
    if (NULL == file_2) {
        printf("ERROR: El segundo archivo no existe.\n");
        fclose(file_1);
        return EXIT_FAILURE;
    }

    file_aux = fopen(aux_file_path, "w+");
    if (NULL == file_aux) {
        fclose(file_1);
        fclose(file_2);
        return EXIT_FAILURE;
    }

    // copy file 1 to aux
    while (read = fread(buffer, sizeof(char), BLOCK_SIZE, file_1)) {
        fwrite(buffer, sizeof(char), read, file_aux);
    }
    fclose(file_1);
    file_1 = fopen(argv[1], "w+");
    if (NULL == file_1) {
        printf("Error, el primer archivo no se ha podido reabrir\n");
    }

    // copy file 2 to 1
    while (read = fread(buffer, sizeof(char), BLOCK_SIZE, file_2)) {
        fwrite(buffer, sizeof(char), read, file_1);
    }

    fclose(file_2);
    file_2 = fopen(argv[2], "w+");
    if (NULL == file_2) {
        printf("Error, el segundo archivo no se ha podido reabrir\n");
    }

    // copy aux file to file 2, we need to go back to begin of file aux
    fseek(file_aux, 0, SEEK_SET);
    while (read = fread(buffer, sizeof(char), BLOCK_SIZE, file_aux)) {
        fwrite(buffer, sizeof(char), read, file_2);
    }

    fclose(file_1);
    fclose(file_2);
    fclose(file_aux);
    remove(aux_file_path);
}
\end{lstlisting}

\item Escribe una función que reciba una palabra como argumento e indique
en qué posición (en bytes) dentro del archivo se encuentra la palabra. Sólo
tienes que dar la primera ocurrencia, si la palabra no se encuentra, devuelve
un número negativo. Haz un programa que, con esa función, reciba una ruta a un
archivo y una palabra e imprima el resultado de buscar la palabra en el archivo.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Solución al ejercicio 17},
label={lst:solution17}]
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int find_in_file(const char *path, const char *word) {
    FILE *file = NULL;
    char *buffer;
    int word_length = 0, read = 0, pos = -1;

    file = fopen(path, "r+");
    if (NULL == file) {
        printf("ERROR: El archivo no existe.\n");
        return -1;
    }
    word_length = strlen(word);
    buffer      = malloc(sizeof(char) * word_length * 2);

    while (read = fread(buffer, sizeof(char), word_length * 2, file)) {
        fseek(file, word_length - read, SEEK_CUR);
        for (int ii = 0; ii < word_length; ++ii) {
            char local_word[word_length + 1];
            memcpy(local_word, buffer + ii, word_length);
            local_word[word_length] = 0;
            if (!strcmp(local_word, word)) {
                pos = ftell(file) + ii - word_length;
                goto end;
            }
        }
    }
end:
    free(buffer);
    fclose(file);
    return pos;
}

int main(int argc, char const *argv[]) {

    int pos = find_in_file(argv[1], argv[2]);
    printf("La palabra %s está en la posición %d en el archivo %s\n",
           argv[2], pos, argv[1]);
}
\end{lstlisting}
\end{minipage}

Aquí puedes ver un uso típico de la instrucción \verb!goto!, como necesitamos
hacer lo mismo encontremos la palabra o no, lo que hacemos es establecer
una etiqueta y saltar allí para liberar recursos y devolver el resultado.

\item Reescribe el ejercicio 15 prescindiendo del array estático de punteros
a \verb!char!. (Usa \verb!realloc! y \verb!strdup!.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Solución al ejercicio 18},
label={lst:solution18}]
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

int main(int argc, char const *argv[]) {
    char word[1024];
    char **word_set = NULL;
    int word_length = 0;
    do {
        word_set = realloc(word_set, ++word_length * sizeof(char *));
        scanf("%s", word);
        word_set[word_length - 1] = strdup(word);
    } while (strcmp(word, "!!"));

    srand(time(NULL));
    for (int ii = 0; ii < word_length - 1; ++ii) {
        char *aux            = word_set[ii];
        int rand_index       = rand() % (word_length - 1);
        word_set[ii]         = word_set[rand_index];
        word_set[rand_index] = aux;
    }
    for (int ii = 0; ii < word_length - 1; ++ii) {
        printf("%s\n", word_set[ii]);
    }
    for (int ii = 0; ii < word_length; ++ii) {
        free(word_set[ii]);
    }
    free(word_set);
}
\end{lstlisting}
\end{minipage}


\item Escribe un programa que reciba un número indeterminado de palabras como
argumentos y los ordene alfabéticamente y que, después, los imprima.


\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Solución al ejercicio 19},
label={lst:solution19}]
void generic_swap(void *one, void *other, size_t type_size) {
//...

void generic_bubble_sort(void *array, size_t array_size,
//...

int compare_strings(const void *one, const void *two) {
//...

int compare_strings(const void* one, const void* two) {
//...

int main(int argc, char const *argv[]) {

    generic_bubble_sort(argv + 1, argc - 1, sizeof(char *),
                        compare_strings);

    for (int ii = 1; ii < argc; ++ii) {
        printf("%s\n", argv[ii]);
    }
}
\end{lstlisting}
\end{minipage}

He usado las funciones de ejemplo para ordenar, así que omito su contenido,
simplemente tenemos que utilizar el comparador adecuado y tener en cuenta que
el primer argumento es el nombre de programa, que no queremos ordenar. Además,
puedes ver que podemos modificar el orden de los argumentos, pero no su
contenido, al haber declarado \texttt{argv} como \verb!char const*argv[]! que
quiere decir un array (puntero) no constante a \verb!char! constante. Es decir,
como ya vimos en la figura \ref{img:constcharpointerpointer}.


\item Haz un programa que reciba como argumento una palabra y un número. Si el
número es cero, debe convertir la palabra a minúscula, si el número es distinto
de cero, debe convertirla a mayúscula.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Solución al ejercicio 20},
label={lst:solution20}]
#include <stdio.h>
#include <stdlib.h>

char char_to_upper_case(char c) {
    if (c < 123 && c > 96) {
        return c - 32;
    }
    return c;
}

char char_to_lower_case(char c) {
    if (c < 91 && c > 64) {
        return c + 32;
    }
    return c;
}

char string_to_upper_case(char *message) {
    int length = strlen(message);
    for (int ii = 0; ii < length; ++ii) {
        message[ii] = char_to_upper_case(message[ii]);
    }
}

char string_to_lower_case(char *message) {
    int length = strlen(message);
    for (int ii = 0; ii < length; ++ii) {
        message[ii] = char_to_lower_case(message[ii]);
    }
}

int main(int argc, char const *argv[]) {

    char *message = strdup(argv[1]);
    int code = atoi(argv[2]);
    if(code){
        string_to_upper_case(message);
    }else{
        string_to_lower_case(message);
    }
    printf("%s\n", message);
    free(message);
}
\end{lstlisting}
\end{minipage}

Aquí hemos utilizado dos funciones diferentes para poner a mayúscula y
minúscula, otra opción sería utilizar un parámetro lógico (o incluso un
enumerado) para indicar qué tipo de letras se quiere y llamar a una función
que reciba ese parámetro y actúe en consecuencia. Puedes implementarlo así
como ejercicio extra.

\item Crea un programa que dado un número como argumento imprima una pirámide
como esta de tantos pisos como el número indicado.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Solución al ejercicio 21},
label={lst:solution21}]
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

char **make_pyramid(int steps) {
    char **result = malloc(sizeof(*result) * steps);
    for (int ii = 0; ii < steps; ++ii) {
        result[ii] = malloc(sizeof(**result) * (steps * 2));
        memset(result[ii], ' ', steps * 2 - 1);
        memset(result[ii] + ii, '%', (steps * 2 - 1) - 2 * ii);
        result[ii][(steps - 1) * 2 + 1] = 0;
    }
    return result;
}

void free_pyramid(char **pyramid, int steps) {
    for (int ii = 0; ii < steps; ++ii) {
        free(pyramid[ii]);
    }
    free(pyramid);
}

int main(int argc, char const *argv[]) {
    int steps      = atoi(argv[1]);
    char **pyramid = make_pyramid(steps);
    for (int ii = 0; ii < steps; ++ii) {
        printf("%s\n", pyramid[ii]);
    }
    free_pyramid(pyramid, steps);
}
\end{lstlisting}
\end{minipage}




\item Escribe un programa que reciba una serie de puntos y de nombres para
cada uno y después los imprima en orden de su distancia al origen de menor a
mayor.

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Solución al ejercicio 23 -- \texttt{tagged\_point.h}},
label={lst:solution23}]
#ifndef TAGGED_POINT_H
#define TAGGED_POINT_H
typedef struct tagged_point_s tagged_point_t;

tagged_point_t *tagged_point_create(const char *tag, double x,
                                    double y);

void tagged_point_set_tag(const char *tag, tagged_point_t *tp);

void tagged_point_set_x(double x, tagged_point_t *tp);

void tagged_point_set_y(double y, tagged_point_t *tp);

const char *tagged_point_get_tag(const tagged_point_t *tp);

double tagged_point_get_x(const tagged_point_t *tp);

double tagged_point_get_y(const tagged_point_t *tp);

void tagged_point_destroy(tagged_point_t *tp);

double tagged_point_distance(const tagged_point_t *a,
                             const tagged_point_t *b);
#endif
\end{lstlisting}
\end{minipage}

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Solución al ejercicio 22 -- \texttt{tagged\_point.c}},
label={lst:solution22}]
#include "tagged_point.h"
#include <math.h>
#include <stdlib.h>
#include <string.h>

struct tagged_point_s {
    char *tag;
    double x, y;
};

tagged_point_t *tagged_point_create(const char *tag, double x,
                                    double y) {
    tagged_point_t *res = malloc(sizeof(tagged_point_t));
    res->x              = x;
    res->y              = y;
    res->tag            = strdup(tag);
}

void tagged_point_set_tag(const char *tag, tagged_point_t *tp) {
    free(tp->tag);
    tp->tag = strdup(tag);
}

void tagged_point_set_x(double x, tagged_point_t *tp) { tp->x = x; }

void tagged_point_set_y(double y, tagged_point_t *tp) { tp->y = y; }

const char *tagged_point_get_tag(const tagged_point_t *tp) {
    return tp->tag;
}

double tagged_point_get_x(const tagged_point_t *tp) { return tp->x; }

double tagged_point_get_y(const tagged_point_t *tp) { return tp->y; }

void tagged_point_destroy(tagged_point_t *tp) {
    free(tp->tag);
    free(tp);
}

double tagged_point_distance(const tagged_point_t *a,
                             const tagged_point_t *b) {
    tagged_point_t origin = {"origin", 0.0, 0.0};
    if (NULL == a) {
        a = &origin;
    }
    if (NULL == b) {
        b = &origin;
    }
    return sqrt((a->x - b->x) * (a->x - b->x) +
                (a->y - b->y) * (a->y - b->y));
}
\end{lstlisting}
\end{minipage}

\noindent
\begin{minipage}[H]{\linewidth}
\mbox{}
\begin{lstlisting}[style=C,
caption={Solución al ejercicio 22 -- \texttt{main.c}},
label={lst:solution22}]
#include "tagged_point.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef int(comparator_t)(const void *, const void *);

void generic_swap(void *one, void *other, size_t type_size) {
// ...

void generic_bubble_sort(void *array, size_t array_size,
// ...

int compare_distance(const void *a, const void *b) {
    tagged_point_t *p1 = *(tagged_point_t **)a;
    tagged_point_t *p2 = *(tagged_point_t **)b;
    return tagged_point_distance(NULL, p1) <
           tagged_point_distance(NULL, p2);
}

int main(int argc, char const *argv[]) {

    int point_lenght = 0;
    if ((argc - 1) % 3 != 0) {
        printf("Algo parece estar mal.");
        return EXIT_FAILURE;
    }
    point_lenght = (argc - 1) / 3;
    tagged_point_t *points[point_lenght];
    for (int ii = 0; ii < point_lenght; ++ii) {
        double x        = atof(argv[1 + ii * 3 + 0]);
        double y        = atof(argv[1 + ii * 3 + 1]);
        const char *tag = argv[1 + ii * 3 + 2];
        points[ii]      = tagged_point_create(tag, x, y);
    }

    generic_bubble_sort(points, point_lenght, sizeof(tagged_point_t *),
                        compare_distance);

    for (int ii = 0; ii < point_lenght; ++ii) {
        printf("%f %f %s\n", tagged_point_get_x(points[ii]),
               tagged_point_get_y(points[ii]),
               tagged_point_get_tag(points[ii]));
        tagged_point_destroy(points[ii]);
    }
}
\end{lstlisting}
\end{minipage}










\end{exercises}

\end{document}




